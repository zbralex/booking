import { __rest } from "tslib";
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { from, fromEvent, merge, throwError } from 'rxjs';
import { map, switchMap, take } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export const YA_CONFIG = new InjectionToken('YA_CONFIG');
/**
 * The `YaApiLoader` service handles loading of Yandex.Maps API.
 *
 * @example
 * ```ts
 * import { YaApiLoaderService } from 'angular8-yandex-maps';
 *
 * export class AppComponent {
 *   constructor(private yaApiLoaderService: YaApiLoaderService) {
 *     this.yaApiLoaderService.load()
 *       .subscribe(v => console.log(v))
 *   }
 * }
 *```
 *
 * @dynamic
 */
export class YaApiLoaderService {
    constructor(config, _document) {
        this._document = _document;
        this._defaultConfig = { lang: 'ru_RU' };
        this._config = Object.assign(Object.assign({}, this._defaultConfig), config);
    }
    /**
     * Loads Yandex.Maps API
     */
    load() {
        if (window.ymaps) {
            return from(ymaps.ready()).pipe(map(() => ymaps));
        }
        if (!this._script) {
            const script = this._document.createElement('script');
            script.type = 'text/javascript';
            script.src = this._getScriptSource(this._config);
            script.id = 'yandexMapsApiScript';
            script.async = true;
            script.defer = true;
            this._script = this._document.body.appendChild(script);
        }
        const load = fromEvent(this._script, 'load').pipe(switchMap(() => from(ymaps.ready()).pipe(map(() => ymaps))));
        const error = fromEvent(this._script, 'error').pipe(switchMap((e) => throwError(e)));
        return merge(load, error).pipe(take(1));
    }
    /**
     * Returns script source by config
     * @param config config with parameters that will be added in source
     * @example
     * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'
     * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })
     */
    _getScriptSource(config) {
        const { enterprise, version = '2.1' } = config, rest = __rest(config, ["enterprise", "version"]);
        const params = this._convertConfigIntoQueryParams(rest);
        return `https://${enterprise ? 'enterprise.' : ''}api-maps.yandex.ru/${version}/?${params}`;
    }
    /**
     * Converts a config into a query string parameters
     * @param config object for converting
     * @example
     * // returns "lang=ru_RU&apikey=XXX"
     * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })
     */
    _convertConfigIntoQueryParams(config) {
        return Object.entries(config)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');
    }
}
YaApiLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function YaApiLoaderService_Factory() { return new YaApiLoaderService(i0.ɵɵinject(YA_CONFIG, 8), i0.ɵɵinject(i1.DOCUMENT)); }, token: YaApiLoaderService, providedIn: "root" });
YaApiLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
YaApiLoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [YA_CONFIG,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWEtYXBpLWxvYWRlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhcjgteWFuZGV4LW1hcHMvc3JjL2xpYi9zZXJ2aWNlcy95YS1hcGktbG9hZGVyL3lhLWFwaS1sb2FkZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0UsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFjLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBRXRELE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBVyxXQUFXLENBQUMsQ0FBQztBQWlDbkU7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFJSCxNQUFNLE9BQU8sa0JBQWtCO0lBTzdCLFlBQ2lDLE1BQXVCLEVBQ25CLFNBQW1CO1FBQW5CLGNBQVMsR0FBVCxTQUFTLENBQVU7UUFOdkMsbUJBQWMsR0FBYSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztRQVE1RCxJQUFJLENBQUMsT0FBTyxtQ0FDUCxJQUFJLENBQUMsY0FBYyxHQUNuQixNQUFNLENBQ1YsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUk7UUFDRixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDakIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFdEQsTUFBTSxDQUFDLElBQUksR0FBRyxpQkFBaUIsQ0FBQztZQUNoQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDakQsTUFBTSxDQUFDLEVBQUUsR0FBRyxxQkFBcUIsQ0FBQztZQUNsQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztZQUNwQixNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztZQUVwQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN4RDtRQUVELE1BQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FDL0MsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FDNUQsQ0FBQztRQUVGLE1BQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFckYsT0FBTyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssZ0JBQWdCLENBQUMsTUFBZ0I7UUFDdkMsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLEdBQUcsS0FBSyxLQUFjLE1BQU0sRUFBZixJQUFJLFVBQUssTUFBTSxFQUFqRCx5QkFBd0MsQ0FBUyxDQUFDO1FBQ3hELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV4RCxPQUFPLFdBQVcsVUFBVSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUUsc0JBQXNCLE9BQU8sS0FBSyxNQUFNLEVBQUUsQ0FBQztJQUM5RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssNkJBQTZCLENBQUMsTUFBZ0I7UUFDcEQsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQzthQUMxQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7YUFDeEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQzs7OztZQTFFRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7Ozs0Q0FTSSxRQUFRLFlBQUksTUFBTSxTQUFDLFNBQVM7WUFDaUIsUUFBUSx1QkFBckQsTUFBTSxTQUFDLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGZyb20sIGZyb21FdmVudCwgbWVyZ2UsIE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwLCBzd2l0Y2hNYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5leHBvcnQgY29uc3QgWUFfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuPFlhQ29uZmlnPignWUFfQ09ORklHJyk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFlhQ29uZmlnIHtcclxuICAvKipcclxuICAgKiBBUEkga2V5LiBZb3UgY2FuIGdldCBhIGtleSBpbiB0aGUgZGV2ZWxvcGVyJ3MgZGFzaGJvYXJkLlxyXG4gICAqL1xyXG4gIGFwaWtleT86IHN0cmluZztcclxuICAvKipcclxuICAgKiBMb2NhbGUuXHJcbiAgICovXHJcbiAgbGFuZz86ICdydV9SVScgfCAnZW5fVVMnIHwgJ2VuX1JVJyB8ICdydV9VQScgfCAndWtfVUEnIHwgJ3RyX1RSJztcclxuICAvKipcclxuICAgKiBUaGUgb3JkZXIgZm9yIHNldHRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGluIEFQSSBmdW5jdGlvbnMgdGhhdCBhY2NlcHQgbG9uZ2l0dWRlLWxhdGl0dWRlIGlucHV0LlxyXG4gICAqL1xyXG4gIGNvb3Jkb3JkZXI/OiAnbGF0bG9uZycgfCAnbG9uZ2xhdCc7XHJcbiAgLyoqXHJcbiAgICogTGlzdCBvZiBtb2R1bGVzIHRvIGxvYWQuXHJcbiAgICovXHJcbiAgbG9hZD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBBUEkgbG9hZGluZyBtb2RlLlxyXG4gICAqL1xyXG4gIG1vZGU/OiAncmVsZWFzZScgfCAnZGVidWcnO1xyXG4gIC8qKlxyXG4gICAqIFVzZSBjb21tZXJjaWFsIHZlcnNpb24gb2YgdGhlIEFQSS5cclxuICAgKi9cclxuICBlbnRlcnByaXNlPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBWZXJzaW9uIG51bWJlciBvZiB0aGUgQVBJLlxyXG4gICAqL1xyXG4gIHZlcnNpb24/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFlhQXBpTG9hZGVyYCBzZXJ2aWNlIGhhbmRsZXMgbG9hZGluZyBvZiBZYW5kZXguTWFwcyBBUEkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IFlhQXBpTG9hZGVyU2VydmljZSB9IGZyb20gJ2FuZ3VsYXI4LXlhbmRleC1tYXBzJztcclxuICpcclxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XHJcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSB5YUFwaUxvYWRlclNlcnZpY2U6IFlhQXBpTG9hZGVyU2VydmljZSkge1xyXG4gKiAgICAgdGhpcy55YUFwaUxvYWRlclNlcnZpY2UubG9hZCgpXHJcbiAqICAgICAgIC5zdWJzY3JpYmUodiA9PiBjb25zb2xlLmxvZyh2KSlcclxuICogICB9XHJcbiAqIH1cclxuICpgYGBcclxuICpcclxuICogQGR5bmFtaWNcclxuICovXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBZYUFwaUxvYWRlclNlcnZpY2Uge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogWWFDb25maWc7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2RlZmF1bHRDb25maWc6IFlhQ29uZmlnID0geyBsYW5nOiAncnVfUlUnIH07XHJcblxyXG4gIHByaXZhdGUgX3NjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChZQV9DT05GSUcpIGNvbmZpZzogWWFDb25maWcgfCBudWxsLFxyXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSByZWFkb25seSBfZG9jdW1lbnQ6IERvY3VtZW50LFxyXG4gICkge1xyXG4gICAgdGhpcy5fY29uZmlnID0ge1xyXG4gICAgICAuLi50aGlzLl9kZWZhdWx0Q29uZmlnLFxyXG4gICAgICAuLi5jb25maWcsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgWWFuZGV4Lk1hcHMgQVBJXHJcbiAgICovXHJcbiAgbG9hZCgpOiBPYnNlcnZhYmxlPHR5cGVvZiB5bWFwcz4ge1xyXG4gICAgaWYgKHdpbmRvdy55bWFwcykge1xyXG4gICAgICByZXR1cm4gZnJvbSh5bWFwcy5yZWFkeSgpKS5waXBlKG1hcCgoKSA9PiB5bWFwcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fc2NyaXB0KSB7XHJcbiAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG5cclxuICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuX2dldFNjcmlwdFNvdXJjZSh0aGlzLl9jb25maWcpO1xyXG4gICAgICBzY3JpcHQuaWQgPSAneWFuZGV4TWFwc0FwaVNjcmlwdCc7XHJcbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XHJcbiAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XHJcblxyXG4gICAgICB0aGlzLl9zY3JpcHQgPSB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbG9hZCA9IGZyb21FdmVudCh0aGlzLl9zY3JpcHQsICdsb2FkJykucGlwZShcclxuICAgICAgc3dpdGNoTWFwKCgpID0+IGZyb20oeW1hcHMucmVhZHkoKSkucGlwZShtYXAoKCkgPT4geW1hcHMpKSksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGVycm9yID0gZnJvbUV2ZW50KHRoaXMuX3NjcmlwdCwgJ2Vycm9yJykucGlwZShzd2l0Y2hNYXAoKGUpID0+IHRocm93RXJyb3IoZSkpKTtcclxuXHJcbiAgICByZXR1cm4gbWVyZ2UobG9hZCwgZXJyb3IpLnBpcGUodGFrZSgxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHNjcmlwdCBzb3VyY2UgYnkgY29uZmlnXHJcbiAgICogQHBhcmFtIGNvbmZpZyBjb25maWcgd2l0aCBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCBpbiBzb3VyY2VcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIC8vIHJldHVybnMgJ2h0dHBzOi8vYXBpLW1hcHMueWFuZGV4LnJ1LzIuMS8/YXBpa2V5PTY1OGY2N2EyLWZkNzctNDJlOS1iOTllLTJiZDQ4YzRjY2FkNCZsYW5nPWVuX1VTJ1xyXG4gICAqIGdldFNjcmlwdFNvdXJjZSh7IGFwaWtleTogJzY1OGY2N2EyLWZkNzctNDJlOS1iOTllLTJiZDQ4YzRjY2FkNCcsIGxhbmc6ICdlbl9VUycgfSlcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRTY3JpcHRTb3VyY2UoY29uZmlnOiBZYUNvbmZpZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCB7IGVudGVycHJpc2UsIHZlcnNpb24gPSAnMi4xJywgLi4ucmVzdCB9ID0gY29uZmlnO1xyXG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5fY29udmVydENvbmZpZ0ludG9RdWVyeVBhcmFtcyhyZXN0KTtcclxuXHJcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtlbnRlcnByaXNlID8gJ2VudGVycHJpc2UuJyA6ICcnfWFwaS1tYXBzLnlhbmRleC5ydS8ke3ZlcnNpb259Lz8ke3BhcmFtc31gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBjb25maWcgaW50byBhIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXHJcbiAgICogQHBhcmFtIGNvbmZpZyBvYmplY3QgZm9yIGNvbnZlcnRpbmdcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIC8vIHJldHVybnMgXCJsYW5nPXJ1X1JVJmFwaWtleT1YWFhcIlxyXG4gICAqIGNvbnZlcnRJbnRvUXVlcnlQYXJhbXMoeyBsYW5nOiAncnVfUlUnLCBhcGlrZXk6ICdYWFgnIH0pXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfY29udmVydENvbmZpZ0ludG9RdWVyeVBhcmFtcyhjb25maWc6IFlhQ29uZmlnKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhjb25maWcpXHJcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0ke3ZhbHVlfWApXHJcbiAgICAgIC5qb2luKCcmJyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==