import { Injectable, NgZone } from '@angular/core';
import { switchMap } from 'rxjs/operators';
import { from, Observable } from 'rxjs';
import { YaApiLoaderService } from '../ya-api-loader/ya-api-loader.service';
import * as i0 from "@angular/core";
import * as i1 from "../ya-api-loader/ya-api-loader.service";
/**
 * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex Maps API.
 *
 * @example
 * ```ts
 * import { YaGeocoderService } from 'angular8-yandex-maps';
 *
 * export class AppComponent {
 *   constructor(private yaGeocoderService: YaGeocoderService) {
 *     this.yaGeocoderService.geocode('Moscow')
 *       .subscribe(v => console.log(v))
 *   }
 * }
 * ```
 */
export class YaGeocoderService {
    constructor(_ngZone, _yaApiLoaderService) {
        this._ngZone = _ngZone;
        this._yaApiLoaderService = _yaApiLoaderService;
    }
    /**
     * Processes geocoding requests
     * @param request
     * @param options
     */
    geocode(request, options) {
        return this._yaApiLoaderService.load().pipe(switchMap(() => from(ymaps.geocode(request, options))), switchMap((result) => new Observable((observer) => {
            this._ngZone.run(() => {
                observer.next(result);
                observer.complete();
            });
        })));
    }
}
YaGeocoderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function YaGeocoderService_Factory() { return new YaGeocoderService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.YaApiLoaderService)); }, token: YaGeocoderService, providedIn: "root" });
YaGeocoderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
YaGeocoderService.ctorParameters = () => [
    { type: NgZone },
    { type: YaApiLoaderService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWEtZ2VvY29kZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXI4LXlhbmRleC1tYXBzL3NyYy9saWIvc2VydmljZXMveWEtZ2VvY29kZXIveWEtZ2VvY29kZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDeEMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7OztBQUU1RTs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUlILE1BQU0sT0FBTyxpQkFBaUI7SUFDNUIsWUFDbUIsT0FBZSxFQUNmLG1CQUF1QztRQUR2QyxZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ2Ysd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFvQjtJQUN2RCxDQUFDO0lBRUo7Ozs7T0FJRztJQUNILE9BQU8sQ0FBQyxPQUEwQixFQUFFLE9BQStCO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FDekMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQ3RELFNBQVMsQ0FDUCxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ1QsSUFBSSxVQUFVLENBQVMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUNsQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ3BCLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3RCLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN0QixDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUNMLENBQ0YsQ0FBQztJQUNKLENBQUM7Ozs7WUEzQkYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUF0Qm9CLE1BQU07WUFHbEIsa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBZYUFwaUxvYWRlclNlcnZpY2UgfSBmcm9tICcuLi95YS1hcGktbG9hZGVyL3lhLWFwaS1sb2FkZXIuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogVGhlIGBZYUdlb2NvZGVyYCBzZXJ2aWNlIHdyYXBzIGB5bWFwcy5nZW9jb2RlYCBzdGF0aWMgZnVuY3Rpb24gZnJvbSB0aGUgWWFuZGV4IE1hcHMgQVBJLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyBZYUdlb2NvZGVyU2VydmljZSB9IGZyb20gJ2FuZ3VsYXI4LXlhbmRleC1tYXBzJztcclxuICpcclxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XHJcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSB5YUdlb2NvZGVyU2VydmljZTogWWFHZW9jb2RlclNlcnZpY2UpIHtcclxuICogICAgIHRoaXMueWFHZW9jb2RlclNlcnZpY2UuZ2VvY29kZSgnTW9zY293JylcclxuICogICAgICAgLnN1YnNjcmliZSh2ID0+IGNvbnNvbGUubG9nKHYpKVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBZYUdlb2NvZGVyU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uZ1pvbmU6IE5nWm9uZSxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3lhQXBpTG9hZGVyU2VydmljZTogWWFBcGlMb2FkZXJTZXJ2aWNlLFxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2Vzc2VzIGdlb2NvZGluZyByZXF1ZXN0c1xyXG4gICAqIEBwYXJhbSByZXF1ZXN0XHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKi9cclxuICBnZW9jb2RlKHJlcXVlc3Q6IHN0cmluZyB8IG51bWJlcltdLCBvcHRpb25zPzogeW1hcHMuSUdlb2NvZGVPcHRpb25zKTogT2JzZXJ2YWJsZTxvYmplY3Q+IHtcclxuICAgIHJldHVybiB0aGlzLl95YUFwaUxvYWRlclNlcnZpY2UubG9hZCgpLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiBmcm9tKHltYXBzLmdlb2NvZGUocmVxdWVzdCwgb3B0aW9ucykpKSxcclxuICAgICAgc3dpdGNoTWFwKFxyXG4gICAgICAgIChyZXN1bHQpID0+XHJcbiAgICAgICAgICBuZXcgT2JzZXJ2YWJsZTxvYmplY3Q+KChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgKSxcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==