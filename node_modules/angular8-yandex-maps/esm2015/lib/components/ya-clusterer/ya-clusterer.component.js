import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, Input, NgZone, Output, } from '@angular/core';
import { Subscription } from 'rxjs';
import { YaGeoObjectDirective } from '../ya-geoobject/ya-geoobject.directive';
import { YaMapComponent } from '../ya-map/ya-map.component';
import { YaPlacemarkDirective } from '../ya-placemark/ya-placemark.directive';
import { EventManager } from '../../event-manager';
/**
 * The `ya-clusterer` component wraps `ymaps.Clusterer` class from the Yandex Maps API.
 * You can configure it via the component's inputs.
 * Events can be bound using the outputs of the component.
 *
 * <example-url>https://stackblitz.com/edit/placemark-clusterer?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map [center]="[55.761952, 37.620739]">
 *   <ya-clusterer [options]="{ minClusterSize: 5 }">
 *     <ya-placemark [geometry]="[55.74, 37.5]"></ya-placemark>
 *     <ya-placemark [geometry]="[55.64, 37.46]"></ya-placemark>
 *     <ya-placemark [geometry]="[55.75, 37.38]"></ya-placemark>
 *
 *     <ya-geoobject
 *       [feature]="{ geometry: { type: 'Point', coordinates: [55.81, 37.4] } }"
 *      ></ya-geoobject>
 *
 *     <ya-geoobject
 *       [feature]="{ geometry: { type: 'Point', coordinates: [55.7, 37.39] } }"
 *      ></ya-geoobject>
 *   </ya-clusterer>
 * </ya-map>
 * ```
 */
export class YaClustererComponent {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        /**
         * Clusterer instance is added in a Map.
         */
        this.ready = new EventEmitter();
        /**
         * Closing the hint.
         */
        this.hintclose = this._eventManager.getLazyEmitter('hintclose');
        /**
         * Opening a hint on a map.
         */
        this.hintopen = this._eventManager.getLazyEmitter('hintopen');
        /**
         * Map reference changed.
         */
        this.mapchange = this._eventManager.getLazyEmitter('mapchange');
        /**
         * Change to the object options.
         */
        this.optionschange = this._eventManager.getLazyEmitter('optionschange');
        /**
         * The parent object reference changed.
         */
        this.parentchange = this._eventManager.getLazyEmitter('parentchange');
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        const clusterer = this._clusterer;
        if (clusterer) {
            const { options } = changes;
            if (options) {
                clusterer.options.set(options.currentValue);
            }
        }
    }
    ngAfterContentInit() {
        if (this._yaMapComponent.isBrowser) {
            const sub = this._yaMapComponent.map$.subscribe((map) => {
                if (map) {
                    const clusterer = this._createClusterer();
                    this._clusterer = clusterer;
                    map.geoObjects.add(clusterer);
                    this._eventManager.setTarget(clusterer);
                    this._watchForContentChanges(clusterer);
                    this._ngZone.run(() => this.ready.emit({ ymaps, target: clusterer }));
                }
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        this._eventManager.destroy();
        this._sub.unsubscribe();
    }
    /**
     * Creates Clusterer.
     */
    _createClusterer() {
        return new ymaps.Clusterer(this.options);
    }
    _watchForContentChanges(clusterer) {
        /**
         * Adds new Placemarks to the clusterer on changes.
         */
        const currentPlacemarks = new Set();
        this._getInternalPlacemarks(this._placemarks.toArray()).forEach((placemark) => {
            currentPlacemarks.add(placemark);
            clusterer.add(placemark);
        });
        const placemarksSub = this._placemarks.changes.subscribe((placemarkDirectives) => {
            const newPlacemarks = new Set(this._getInternalPlacemarks(placemarkDirectives));
            const difference = this._getDifference(newPlacemarks, currentPlacemarks);
            clusterer.add(difference.toAdd);
            clusterer.remove(difference.toRemove);
        });
        this._sub.add(placemarksSub);
        /**
         * Adds new GeoObjects to the clusterer on changes.
         */
        const currentGeoObjects = new Set();
        this._getInternalGeoObjects(this._geoObjects.toArray()).forEach((geoObject) => {
            currentGeoObjects.add(geoObject);
            clusterer.add(geoObject);
        });
        const geoObjectsSub = this._geoObjects.changes.subscribe((geoObjectDirectives) => {
            const newGeoObjects = new Set(this._getInternalGeoObjects(geoObjectDirectives));
            const difference = this._getDifference(newGeoObjects, currentGeoObjects);
            clusterer.add(difference.toAdd);
            clusterer.remove(difference.toRemove);
        });
        this._sub.add(geoObjectsSub);
    }
    /**
     * Determines what should be added/removed in current set to equal new set
     *
     * @param newSet
     * @param currentSet
     */
    _getDifference(newSet, currentSet) {
        const toAdd = [];
        const toRemove = [];
        newSet.forEach((component) => {
            if (!currentSet.has(component)) {
                toAdd.push(component);
                currentSet.add(component);
            }
        });
        currentSet.forEach((component) => {
            if (!newSet.has(component)) {
                toRemove.push(component);
                currentSet.delete(component);
            }
        });
        return {
            toAdd,
            toRemove,
        };
    }
    _getInternalPlacemarks(placemarks) {
        return placemarks
            .filter((component) => !!component.placemark)
            .map((component) => component.placemark);
    }
    _getInternalGeoObjects(geoObjects) {
        return geoObjects
            .filter((component) => !!component.geoObject)
            .map((component) => component.geoObject);
    }
}
YaClustererComponent.decorators = [
    { type: Component, args: [{
                selector: 'ya-clusterer',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
YaClustererComponent.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaClustererComponent.propDecorators = {
    _placemarks: [{ type: ContentChildren, args: [YaPlacemarkDirective,] }],
    _geoObjects: [{ type: ContentChildren, args: [YaGeoObjectDirective,] }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    hintclose: [{ type: Output }],
    hintopen: [{ type: Output }],
    mapchange: [{ type: Output }],
    optionschange: [{ type: Output }],
    parentchange: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWEtY2x1c3RlcmVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXI4LXlhbmRleC1tYXBzL3NyYy9saWIvY29tcG9uZW50cy95YS1jbHVzdGVyZXIveWEtY2x1c3RlcmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBR04sTUFBTSxHQUdQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDaEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzVELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUluRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQU1ILE1BQU0sT0FBTyxvQkFBb0I7SUF3RC9CLFlBQTZCLE9BQWUsRUFBbUIsZUFBK0I7UUFBakUsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFtQixvQkFBZSxHQUFmLGVBQWUsQ0FBZ0I7UUFqRDdFLFNBQUksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTFCLGtCQUFhLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBVWhFOztXQUVHO1FBQ08sVUFBSyxHQUFnRCxJQUFJLFlBQVksRUFFNUUsQ0FBQztRQUVKOztXQUVHO1FBQ08sY0FBUyxHQUNqQixJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVqRDs7V0FFRztRQUNP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RSxDQUFDLFNBQVMsQ0FBQyxTQUFVLENBQUMsQ0FBQztJQUM5QyxDQUFDOzs7WUF6TUYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxjQUFjO2dCQUN4QixRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7O1lBN0NDLE1BQU07WUFTQyxjQUFjOzs7MEJBc0NwQixlQUFlLFNBQUMsb0JBQW9COzBCQUdwQyxlQUFlLFNBQUMsb0JBQW9CO3NCQWFwQyxLQUFLO29CQUtMLE1BQU07d0JBT04sTUFBTTt1QkFNTixNQUFNO3dCQU1OLE1BQU07NEJBTU4sTUFBTTsyQkFNTixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBZnRlckNvbnRlbnRJbml0LFxyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBDb250ZW50Q2hpbGRyZW4sXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIElucHV0LFxyXG4gIE5nWm9uZSxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25EZXN0cm95LFxyXG4gIE91dHB1dCxcclxuICBRdWVyeUxpc3QsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IFlhR2VvT2JqZWN0RGlyZWN0aXZlIH0gZnJvbSAnLi4veWEtZ2Vvb2JqZWN0L3lhLWdlb29iamVjdC5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBZYU1hcENvbXBvbmVudCB9IGZyb20gJy4uL3lhLW1hcC95YS1tYXAuY29tcG9uZW50JztcclxuaW1wb3J0IHsgWWFQbGFjZW1hcmtEaXJlY3RpdmUgfSBmcm9tICcuLi95YS1wbGFjZW1hcmsveWEtcGxhY2VtYXJrLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJy4uLy4uL2V2ZW50LW1hbmFnZXInO1xyXG5pbXBvcnQgeyBZYVJlYWR5RXZlbnQgfSBmcm9tICcuLi8uLi90eXBpbmdzL3lhLXJlYWR5LWV2ZW50JztcclxuaW1wb3J0IHsgWWFFdmVudCB9IGZyb20gJy4uLy4uL3R5cGluZ3MveWEtZXZlbnQnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgeWEtY2x1c3RlcmVyYCBjb21wb25lbnQgd3JhcHMgYHltYXBzLkNsdXN0ZXJlcmAgY2xhc3MgZnJvbSB0aGUgWWFuZGV4IE1hcHMgQVBJLlxyXG4gKiBZb3UgY2FuIGNvbmZpZ3VyZSBpdCB2aWEgdGhlIGNvbXBvbmVudCdzIGlucHV0cy5cclxuICogRXZlbnRzIGNhbiBiZSBib3VuZCB1c2luZyB0aGUgb3V0cHV0cyBvZiB0aGUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiA8ZXhhbXBsZS11cmw+aHR0cHM6Ly9zdGFja2JsaXR6LmNvbS9lZGl0L3BsYWNlbWFyay1jbHVzdGVyZXI/ZW1iZWQ9MTwvZXhhbXBsZS11cmw+XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGh0bWxcclxuICogPHlhLW1hcCBbY2VudGVyXT1cIls1NS43NjE5NTIsIDM3LjYyMDczOV1cIj5cclxuICogICA8eWEtY2x1c3RlcmVyIFtvcHRpb25zXT1cInsgbWluQ2x1c3RlclNpemU6IDUgfVwiPlxyXG4gKiAgICAgPHlhLXBsYWNlbWFyayBbZ2VvbWV0cnldPVwiWzU1Ljc0LCAzNy41XVwiPjwveWEtcGxhY2VtYXJrPlxyXG4gKiAgICAgPHlhLXBsYWNlbWFyayBbZ2VvbWV0cnldPVwiWzU1LjY0LCAzNy40Nl1cIj48L3lhLXBsYWNlbWFyaz5cclxuICogICAgIDx5YS1wbGFjZW1hcmsgW2dlb21ldHJ5XT1cIls1NS43NSwgMzcuMzhdXCI+PC95YS1wbGFjZW1hcms+XHJcbiAqXHJcbiAqICAgICA8eWEtZ2Vvb2JqZWN0XHJcbiAqICAgICAgIFtmZWF0dXJlXT1cInsgZ2VvbWV0cnk6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFs1NS44MSwgMzcuNF0gfSB9XCJcclxuICogICAgICA+PC95YS1nZW9vYmplY3Q+XHJcbiAqXHJcbiAqICAgICA8eWEtZ2Vvb2JqZWN0XHJcbiAqICAgICAgIFtmZWF0dXJlXT1cInsgZ2VvbWV0cnk6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFs1NS43LCAzNy4zOV0gfSB9XCJcclxuICogICAgICA+PC95YS1nZW9vYmplY3Q+XHJcbiAqICAgPC95YS1jbHVzdGVyZXI+XHJcbiAqIDwveWEtbWFwPlxyXG4gKiBgYGBcclxuICovXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAneWEtY2x1c3RlcmVyJyxcclxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgWWFDbHVzdGVyZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcbiAgQENvbnRlbnRDaGlsZHJlbihZYVBsYWNlbWFya0RpcmVjdGl2ZSlcclxuICBwcml2YXRlIHJlYWRvbmx5IF9wbGFjZW1hcmtzOiBRdWVyeUxpc3Q8WWFQbGFjZW1hcmtEaXJlY3RpdmU+O1xyXG5cclxuICBAQ29udGVudENoaWxkcmVuKFlhR2VvT2JqZWN0RGlyZWN0aXZlKVxyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2dlb09iamVjdHM6IFF1ZXJ5TGlzdDxZYUdlb09iamVjdERpcmVjdGl2ZT47XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3N1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0aGlzLl9uZ1pvbmUpO1xyXG5cclxuICBwcml2YXRlIF9jbHVzdGVyZXI/OiB5bWFwcy5DbHVzdGVyZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wdGlvbnMgZm9yIHRoZSBjbHVzdGVyZXIuXHJcbiAgICoge0BsaW5rIGh0dHBzOi8veWFuZGV4LmNvbS9kZXYvbWFwcy9qc2FwaS9kb2MvMi4xL3JlZi9yZWZlcmVuY2UvQ2x1c3RlcmVyLmh0bWwjQ2x1c3RlcmVyX19wYXJhbS1vcHRpb25zfVxyXG4gICAqL1xyXG4gIEBJbnB1dCgpIG9wdGlvbnM6IHltYXBzLklDbHVzdGVyZXJPcHRpb25zO1xyXG5cclxuICAvKipcclxuICAgKiBDbHVzdGVyZXIgaW5zdGFuY2UgaXMgYWRkZWQgaW4gYSBNYXAuXHJcbiAgICovXHJcbiAgQE91dHB1dCgpIHJlYWR5OiBFdmVudEVtaXR0ZXI8WWFSZWFkeUV2ZW50PHltYXBzLkNsdXN0ZXJlcj4+ID0gbmV3IEV2ZW50RW1pdHRlcjxcclxuICAgIFlhUmVhZHlFdmVudDx5bWFwcy5DbHVzdGVyZXI+XHJcbiAgPigpO1xyXG5cclxuICAvKipcclxuICAgKiBDbG9zaW5nIHRoZSBoaW50LlxyXG4gICAqL1xyXG4gIEBPdXRwdXQoKSBoaW50Y2xvc2U6IE9ic2VydmFibGU8WWFFdmVudDx5bWFwcy5DbHVzdGVyZXI+PiA9XHJcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIuZ2V0TGF6eUVtaXR0ZXIoJ2hpbnRjbG9zZScpO1xyXG5cclxuICAvKipcclxuICAgKiBPcGVuaW5nIGEgaGludCBvbiBhIG1hcC5cclxuICAgKi9cclxuICBAT3V0cHV0KCkgaGludG9wZW46IE9ic2VydmFibGU8WWFFdmVudDx5bWFwcy5DbHVzdGVyZXI+PiA9XHJcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIuZ2V0TGF6eUVtaXR0ZXIoJ2hpbnRvcGVuJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcCByZWZlcmVuY2UgY2hhbmdlZC5cclxuICAgKi9cclxuICBAT3V0cHV0KCkgbWFwY2hhbmdlOiBPYnNlcnZhYmxlPFlhRXZlbnQ8eW1hcHMuQ2x1c3RlcmVyPj4gPVxyXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmdldExhenlFbWl0dGVyKCdtYXBjaGFuZ2UnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHRvIHRoZSBvYmplY3Qgb3B0aW9ucy5cclxuICAgKi9cclxuICBAT3V0cHV0KCkgb3B0aW9uc2NoYW5nZTogT2JzZXJ2YWJsZTxZYUV2ZW50PHltYXBzLkNsdXN0ZXJlcj4+ID1cclxuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5nZXRMYXp5RW1pdHRlcignb3B0aW9uc2NoYW5nZScpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcGFyZW50IG9iamVjdCByZWZlcmVuY2UgY2hhbmdlZC5cclxuICAgKi9cclxuICBAT3V0cHV0KCkgcGFyZW50Y2hhbmdlOiBPYnNlcnZhYmxlPFlhRXZlbnQ8eW1hcHMuQ2x1c3RlcmVyPj4gPVxyXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmdldExhenlFbWl0dGVyKCdwYXJlbnRjaGFuZ2UnKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgcmVhZG9ubHkgX3lhTWFwQ29tcG9uZW50OiBZYU1hcENvbXBvbmVudCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBpbnB1dCBjaGFuZ2VzIGFuZCBwYXNzZXMgdGhlbSBpbiBBUEkuXHJcbiAgICogQHBhcmFtIGNoYW5nZXNcclxuICAgKi9cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICBjb25zdCBjbHVzdGVyZXIgPSB0aGlzLl9jbHVzdGVyZXI7XHJcblxyXG4gICAgaWYgKGNsdXN0ZXJlcikge1xyXG4gICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNoYW5nZXM7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgIGNsdXN0ZXJlci5vcHRpb25zLnNldChvcHRpb25zLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl95YU1hcENvbXBvbmVudC5pc0Jyb3dzZXIpIHtcclxuICAgICAgY29uc3Qgc3ViID0gdGhpcy5feWFNYXBDb21wb25lbnQubWFwJC5zdWJzY3JpYmUoKG1hcCkgPT4ge1xyXG4gICAgICAgIGlmIChtYXApIHtcclxuICAgICAgICAgIGNvbnN0IGNsdXN0ZXJlciA9IHRoaXMuX2NyZWF0ZUNsdXN0ZXJlcigpO1xyXG4gICAgICAgICAgdGhpcy5fY2x1c3RlcmVyID0gY2x1c3RlcmVyO1xyXG5cclxuICAgICAgICAgIG1hcC5nZW9PYmplY3RzLmFkZChjbHVzdGVyZXIpO1xyXG4gICAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLnNldFRhcmdldChjbHVzdGVyZXIpO1xyXG4gICAgICAgICAgdGhpcy5fd2F0Y2hGb3JDb250ZW50Q2hhbmdlcyhjbHVzdGVyZXIpO1xyXG4gICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLnJlYWR5LmVtaXQoeyB5bWFwcywgdGFyZ2V0OiBjbHVzdGVyZXIgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9zdWIuYWRkKHN1Yik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9zdWIudW5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgQ2x1c3RlcmVyLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2NyZWF0ZUNsdXN0ZXJlcigpOiB5bWFwcy5DbHVzdGVyZXIge1xyXG4gICAgcmV0dXJuIG5ldyB5bWFwcy5DbHVzdGVyZXIodGhpcy5vcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3dhdGNoRm9yQ29udGVudENoYW5nZXMoY2x1c3RlcmVyOiB5bWFwcy5DbHVzdGVyZXIpOiB2b2lkIHtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBuZXcgUGxhY2VtYXJrcyB0byB0aGUgY2x1c3RlcmVyIG9uIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1hcmtzID0gbmV3IFNldDx5bWFwcy5QbGFjZW1hcms+KCk7XHJcblxyXG4gICAgdGhpcy5fZ2V0SW50ZXJuYWxQbGFjZW1hcmtzKHRoaXMuX3BsYWNlbWFya3MudG9BcnJheSgpKS5mb3JFYWNoKChwbGFjZW1hcmspID0+IHtcclxuICAgICAgY3VycmVudFBsYWNlbWFya3MuYWRkKHBsYWNlbWFyayk7XHJcbiAgICAgIGNsdXN0ZXJlci5hZGQocGxhY2VtYXJrKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHBsYWNlbWFya3NTdWIgPSB0aGlzLl9wbGFjZW1hcmtzLmNoYW5nZXMuc3Vic2NyaWJlKFxyXG4gICAgICAocGxhY2VtYXJrRGlyZWN0aXZlczogWWFQbGFjZW1hcmtEaXJlY3RpdmVbXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld1BsYWNlbWFya3MgPSBuZXcgU2V0PHltYXBzLlBsYWNlbWFyaz4oXHJcbiAgICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbFBsYWNlbWFya3MocGxhY2VtYXJrRGlyZWN0aXZlcyksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMuX2dldERpZmZlcmVuY2U8eW1hcHMuUGxhY2VtYXJrPihuZXdQbGFjZW1hcmtzLCBjdXJyZW50UGxhY2VtYXJrcyk7XHJcblxyXG4gICAgICAgIGNsdXN0ZXJlci5hZGQoZGlmZmVyZW5jZS50b0FkZCk7XHJcbiAgICAgICAgY2x1c3RlcmVyLnJlbW92ZShkaWZmZXJlbmNlLnRvUmVtb3ZlKTtcclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5fc3ViLmFkZChwbGFjZW1hcmtzU3ViKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgbmV3IEdlb09iamVjdHMgdG8gdGhlIGNsdXN0ZXJlciBvbiBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBjdXJyZW50R2VvT2JqZWN0cyA9IG5ldyBTZXQ8eW1hcHMuR2VvT2JqZWN0PigpO1xyXG5cclxuICAgIHRoaXMuX2dldEludGVybmFsR2VvT2JqZWN0cyh0aGlzLl9nZW9PYmplY3RzLnRvQXJyYXkoKSkuZm9yRWFjaCgoZ2VvT2JqZWN0KSA9PiB7XHJcbiAgICAgIGN1cnJlbnRHZW9PYmplY3RzLmFkZChnZW9PYmplY3QpO1xyXG4gICAgICBjbHVzdGVyZXIuYWRkKGdlb09iamVjdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBnZW9PYmplY3RzU3ViID0gdGhpcy5fZ2VvT2JqZWN0cy5jaGFuZ2VzLnN1YnNjcmliZShcclxuICAgICAgKGdlb09iamVjdERpcmVjdGl2ZXM6IFlhR2VvT2JqZWN0RGlyZWN0aXZlW10pID0+IHtcclxuICAgICAgICBjb25zdCBuZXdHZW9PYmplY3RzID0gbmV3IFNldDx5bWFwcy5HZW9PYmplY3Q+KFxyXG4gICAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxHZW9PYmplY3RzKGdlb09iamVjdERpcmVjdGl2ZXMpLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLl9nZXREaWZmZXJlbmNlPHltYXBzLkdlb09iamVjdD4obmV3R2VvT2JqZWN0cywgY3VycmVudEdlb09iamVjdHMpO1xyXG5cclxuICAgICAgICBjbHVzdGVyZXIuYWRkKGRpZmZlcmVuY2UudG9BZGQpO1xyXG4gICAgICAgIGNsdXN0ZXJlci5yZW1vdmUoZGlmZmVyZW5jZS50b1JlbW92ZSk7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuX3N1Yi5hZGQoZ2VvT2JqZWN0c1N1Yik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoYXQgc2hvdWxkIGJlIGFkZGVkL3JlbW92ZWQgaW4gY3VycmVudCBzZXQgdG8gZXF1YWwgbmV3IHNldFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5ld1NldFxyXG4gICAqIEBwYXJhbSBjdXJyZW50U2V0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0RGlmZmVyZW5jZTxUPihuZXdTZXQ6IFNldDxUPiwgY3VycmVudFNldDogU2V0PFQ+KSB7XHJcbiAgICBjb25zdCB0b0FkZDogVFtdID0gW107XHJcbiAgICBjb25zdCB0b1JlbW92ZTogVFtdID0gW107XHJcblxyXG4gICAgbmV3U2V0LmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICBpZiAoIWN1cnJlbnRTZXQuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICB0b0FkZC5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgY3VycmVudFNldC5hZGQoY29tcG9uZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY3VycmVudFNldC5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcclxuICAgICAgaWYgKCFuZXdTZXQuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICB0b1JlbW92ZS5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgY3VycmVudFNldC5kZWxldGUoY29tcG9uZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9BZGQsXHJcbiAgICAgIHRvUmVtb3ZlLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2dldEludGVybmFsUGxhY2VtYXJrcyhwbGFjZW1hcmtzOiBZYVBsYWNlbWFya0RpcmVjdGl2ZVtdKTogeW1hcHMuUGxhY2VtYXJrW10ge1xyXG4gICAgcmV0dXJuIHBsYWNlbWFya3NcclxuICAgICAgLmZpbHRlcigoY29tcG9uZW50KSA9PiAhIWNvbXBvbmVudC5wbGFjZW1hcmspXHJcbiAgICAgIC5tYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnBsYWNlbWFyayEpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfZ2V0SW50ZXJuYWxHZW9PYmplY3RzKGdlb09iamVjdHM6IFlhR2VvT2JqZWN0RGlyZWN0aXZlW10pOiB5bWFwcy5HZW9PYmplY3RbXSB7XHJcbiAgICByZXR1cm4gZ2VvT2JqZWN0c1xyXG4gICAgICAuZmlsdGVyKChjb21wb25lbnQpID0+ICEhY29tcG9uZW50Lmdlb09iamVjdClcclxuICAgICAgLm1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQuZ2VvT2JqZWN0ISk7XHJcbiAgfVxyXG59XHJcbiJdfQ==