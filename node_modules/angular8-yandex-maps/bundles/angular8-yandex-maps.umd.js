(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('angular8-yandex-maps', ['exports', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['angular8-yandex-maps'] = {}, global.ng.common, global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (exports, i1, i0, rxjs, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var YA_CONFIG = new i0.InjectionToken('YA_CONFIG');
    /**
     * The `YaApiLoader` service handles loading of Yandex.Maps API.
     *
     * @example
     * ```ts
     * import { YaApiLoaderService } from 'angular8-yandex-maps';
     *
     * export class AppComponent {
     *   constructor(private yaApiLoaderService: YaApiLoaderService) {
     *     this.yaApiLoaderService.load()
     *       .subscribe(v => console.log(v))
     *   }
     * }
     *```
     *
     * @dynamic
     */
    var YaApiLoaderService = /** @class */ (function () {
        function YaApiLoaderService(config, _document) {
            this._document = _document;
            this._defaultConfig = { lang: 'ru_RU' };
            this._config = Object.assign(Object.assign({}, this._defaultConfig), config);
        }
        /**
         * Loads Yandex.Maps API
         */
        YaApiLoaderService.prototype.load = function () {
            if (window.ymaps) {
                return rxjs.from(ymaps.ready()).pipe(operators.map(function () { return ymaps; }));
            }
            if (!this._script) {
                var script = this._document.createElement('script');
                script.type = 'text/javascript';
                script.src = this._getScriptSource(this._config);
                script.id = 'yandexMapsApiScript';
                script.async = true;
                script.defer = true;
                this._script = this._document.body.appendChild(script);
            }
            var load = rxjs.fromEvent(this._script, 'load').pipe(operators.switchMap(function () { return rxjs.from(ymaps.ready()).pipe(operators.map(function () { return ymaps; })); }));
            var error = rxjs.fromEvent(this._script, 'error').pipe(operators.switchMap(function (e) { return rxjs.throwError(e); }));
            return rxjs.merge(load, error).pipe(operators.take(1));
        };
        /**
         * Returns script source by config
         * @param config config with parameters that will be added in source
         * @example
         * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'
         * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })
         */
        YaApiLoaderService.prototype._getScriptSource = function (config) {
            var enterprise = config.enterprise, _a = config.version, version = _a === void 0 ? '2.1' : _a, rest = __rest(config, ["enterprise", "version"]);
            var params = this._convertConfigIntoQueryParams(rest);
            return "https://" + (enterprise ? 'enterprise.' : '') + "api-maps.yandex.ru/" + version + "/?" + params;
        };
        /**
         * Converts a config into a query string parameters
         * @param config object for converting
         * @example
         * // returns "lang=ru_RU&apikey=XXX"
         * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })
         */
        YaApiLoaderService.prototype._convertConfigIntoQueryParams = function (config) {
            return Object.entries(config)
                .map(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                return key + "=" + value;
            })
                .join('&');
        };
        return YaApiLoaderService;
    }());
    YaApiLoaderService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function YaApiLoaderService_Factory() { return new YaApiLoaderService(i0__namespace.ɵɵinject(YA_CONFIG, 8), i0__namespace.ɵɵinject(i1__namespace.DOCUMENT)); }, token: YaApiLoaderService, providedIn: "root" });
    YaApiLoaderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    YaApiLoaderService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [YA_CONFIG,] }] },
        { type: Document, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }
    ]; };

    /**
     * Copied from angular/components/google-maps and edited for Yandex Maps API.
     * {@link https://github.com/angular/components/blob/master/src/google-maps/map-event-manager.ts}
     */
    /**
     * Manages event on a Yandex Maps object, ensuring that events are added only when necessary.
     * @internal
     */
    var EventManager = /** @class */ (function () {
        function EventManager(_ngZone) {
            this._ngZone = _ngZone;
            /**
             * Listeners that were added before the target was set.
             */
            this._pending = [];
            this._listeners = [];
            this._targetStream = new rxjs.BehaviorSubject(undefined);
        }
        /**
         * Gets an observable that adds an event listener to the map when a consumer subscribes to it.
         * @param name
         */
        EventManager.prototype.getLazyEmitter = function (name) {
            var _this = this;
            return this._targetStream.pipe(operators.switchMap(function (target) {
                var observable = new rxjs.Observable(function (observer) {
                    // If the target hasn't been initialized yet, cache the observer so it can be added later.
                    if (!target) {
                        _this._pending.push({ observable: observable, observer: observer });
                        return undefined;
                    }
                    var callback = function (event) {
                        var e = {
                            event: event,
                            target: target,
                            ymaps: ymaps,
                        };
                        _this._ngZone.run(function () { return observer.next(e); });
                    };
                    var listener = target.events.add(name, callback);
                    _this._listeners.push({ name: name, callback: callback, manager: listener });
                    // Unsubscribe function
                    return function () { return listener.remove(name, callback); };
                });
                return observable;
            }));
        };
        /**
         * Sets the current target that the manager should bind events to.
         * @param target
         */
        EventManager.prototype.setTarget = function (target) {
            var currentTarget = this._targetStream.value;
            if (target === currentTarget) {
                return;
            }
            // Clear the listeners from the pre-existing target.
            if (currentTarget) {
                this._clearListeners();
                this._pending = [];
            }
            this._targetStream.next(target);
            // Add the listeners that were bound before the map was initialized.
            this._pending.forEach(function (subscriber) { return subscriber.observable.subscribe(subscriber.observer); });
            this._pending = [];
        };
        /**
         * Destroys the manager and clears the event listeners.
         */
        EventManager.prototype.destroy = function () {
            this._clearListeners();
            this._pending = [];
            this._targetStream.complete();
        };
        /**
         * Clears all currently-registered event listeners.
         */
        EventManager.prototype._clearListeners = function () {
            this._listeners.forEach(function (listener) {
                var name = listener.name, callback = listener.callback, manager = listener.manager;
                manager.remove(name, callback);
            });
            this._listeners = [];
        };
        return EventManager;
    }());

    /**
     * Generates a random string based on Date in hexadecimal numeral system
     * @example f175517fa4f3
     * @internal
     */
    var generateRandomId = function () {
        return "f" + Number(new Date()).toString(16);
    };

    /**
     * The `ya-map` component wraps `ymaps.Map` class from the Yandex Maps API.
     * You can configure the map via the component's inputs.
     * Events can be bound using the outputs of the component.
     *
     * <example-url>https://stackblitz.com/edit/map-onload-event?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map
     *   [center]="[55.751952, 37.600739]"
     *   [state]="{type: 'yandex#satellite'}"
     * ></ya-map>
     * ```
     */
    var YaMapComponent = /** @class */ (function () {
        function YaMapComponent(_ngZone, _yaApiLoaderService, platformId) {
            this._ngZone = _ngZone;
            this._yaApiLoaderService = _yaApiLoaderService;
            this._sub = new rxjs.Subscription();
            this._eventManager = new EventManager(this._ngZone);
            this.map$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Map instance is created.
             */
            this.ready = new i0.EventEmitter();
            /**
             * The start of a new smooth map movement.
             */
            this.actionbegin = this._eventManager.getLazyEmitter('actionbegin');
            /**
             * Event that occurs when an action step was prematurely stopped.
             */
            this.actionbreak = this._eventManager.getLazyEmitter('actionbreak');
            /**
             * The end of smooth map movement.
             */
            this.actionend = this._eventManager.getLazyEmitter('actionend');
            /**
             * The start of a new step of smooth movement.
             */
            this.actiontick = this._eventManager.getLazyEmitter('actiontick');
            /**
             * The end of performing a step of smooth movement.
             */
            this.actiontickcomplete = this._eventManager.getLazyEmitter('actiontickcomplete');
            /**
             * Closing the balloon.
             */
            this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
            /**
             * Opening a balloon on a map.
             */
            this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
            /**
             * Event for a change to the map viewport.
             */
            this.boundschange = this._eventManager.getLazyEmitter('boundschange');
            /**
             * Single left-click on the object.
             */
            this.yaclick = this._eventManager.getLazyEmitter('click');
            /**
             * Calls the element's context menu.
             */
            this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
            /**
             * Double left-click on the object.
             */
            this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
            /**
             * The map was destroyed.
             */
            this.destroy = this._eventManager.getLazyEmitter('destroy');
            /**
             * Closing the hint.
             */
            this.hintclose = this._eventManager.getLazyEmitter('hintclose');
            /**
             * Opening a hint on a map.
             */
            this.hintopen = this._eventManager.getLazyEmitter('hintopen');
            /**
             * Map margins changed.
             */
            this.marginchange = this._eventManager.getLazyEmitter('marginchange');
            /**
             * Pressing the mouse button over the object.
             */
            this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
            /**
             * Pointing the cursor at the object.
             */
            this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
            /**
             * Moving the cursor off of the object.
             */
            this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
            /**
             * Moving the cursor over the object.
             */
            this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
            /**
             * Letting go of the mouse button over an object.
             */
            this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
            /**
             * End of multitouch.
             */
            this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
            /**
             * Repeating event during multitouch.
             */
            this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
            /**
             * Start of multitouch.
             */
            this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
            /**
             * Map options changed.
             */
            this.optionschange = this._eventManager.getLazyEmitter('optionschange');
            /**
             * Map size changed.
             */
            this.sizechange = this._eventManager.getLazyEmitter('sizechange');
            /**
             * The map type changed.
             */
            this.typechange = this._eventManager.getLazyEmitter('typechange');
            /**
             * Mouse wheel scrolling.
             */
            this.yawheel = this._eventManager.getLazyEmitter('wheel');
            this.isBrowser = i1.isPlatformBrowser(platformId);
        }
        /**
         * Handles input changes and passes them in API.
         * @param changes
         */
        YaMapComponent.prototype.ngOnChanges = function (changes) {
            var map = this.map$.value;
            if (map) {
                var center = changes.center, zoom = changes.zoom, state = changes.state, options = changes.options;
                if (state) {
                    this._setState(this._combineState(), map);
                }
                if (center) {
                    map.setCenter(center.currentValue);
                }
                if (zoom) {
                    map.setZoom(zoom.currentValue);
                }
                if (options) {
                    map.options.set(options.currentValue);
                }
            }
        };
        YaMapComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            /**
             * It should be a noop during server-side rendering.
             */
            if (this.isBrowser) {
                var sub = this._yaApiLoaderService.load().subscribe(function () {
                    var id = generateRandomId();
                    var map = _this._createMap(id);
                    _this.map$.next(map);
                    _this._eventManager.setTarget(map);
                    _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: map }); });
                });
                this._sub.add(sub);
            }
        };
        YaMapComponent.prototype.ngOnDestroy = function () {
            this._eventManager.destroy();
            this._sub.unsubscribe();
        };
        /**
         * Destructs state and passes it in API.
         * @param state
         * @param map
         */
        YaMapComponent.prototype._setState = function (state, map) {
            var behaviors = state.behaviors, bounds = state.bounds, center = state.center, controls = state.controls, margin = state.margin, type = state.type, zoom = state.zoom;
            if (behaviors) {
                map.behaviors.enable(behaviors);
            }
            if (bounds) {
                map.setBounds(bounds);
            }
            if (center) {
                map.setCenter(center);
            }
            if (controls) {
                controls.forEach(function (control) { return map.controls.add(control); });
            }
            if (margin) {
                map.margin.setDefaultMargin(margin);
            }
            if (type) {
                map.setType(type);
            }
            if (zoom) {
                map.setZoom(zoom);
            }
        };
        /**
         * Creates a map.
         * @param id ID which will be set to the map container.
         */
        YaMapComponent.prototype._createMap = function (id) {
            var containerElem = this.container.nativeElement;
            containerElem.setAttribute('id', id);
            containerElem.style.cssText = 'width: 100%; height: 100%;';
            return new ymaps.Map(id, this._combineState(), this.options || {});
        };
        /**
         * Combines the center and zoom into single object.
         */
        YaMapComponent.prototype._combineState = function () {
            var _a, _b;
            var state = this.state || {};
            return Object.assign(Object.assign({}, state), { center: this.center || state.center || [0, 0], zoom: (_b = (_a = this.zoom) !== null && _a !== void 0 ? _a : state.zoom) !== null && _b !== void 0 ? _b : 10 });
        };
        return YaMapComponent;
    }());
    YaMapComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ya-map',
                    template: '<div #container></div>',
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    YaMapComponent.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaApiLoaderService },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    YaMapComponent.propDecorators = {
        container: [{ type: i0.ViewChild, args: ['container',] }],
        center: [{ type: i0.Input }],
        zoom: [{ type: i0.Input }],
        state: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        ready: [{ type: i0.Output }],
        actionbegin: [{ type: i0.Output }],
        actionbreak: [{ type: i0.Output }],
        actionend: [{ type: i0.Output }],
        actiontick: [{ type: i0.Output }],
        actiontickcomplete: [{ type: i0.Output }],
        balloonclose: [{ type: i0.Output }],
        balloonopen: [{ type: i0.Output }],
        boundschange: [{ type: i0.Output }],
        yaclick: [{ type: i0.Output }],
        yacontextmenu: [{ type: i0.Output }],
        yadblclick: [{ type: i0.Output }],
        destroy: [{ type: i0.Output }],
        hintclose: [{ type: i0.Output }],
        hintopen: [{ type: i0.Output }],
        marginchange: [{ type: i0.Output }],
        yamousedown: [{ type: i0.Output }],
        yamouseenter: [{ type: i0.Output }],
        yamouseleave: [{ type: i0.Output }],
        yamousemove: [{ type: i0.Output }],
        yamouseup: [{ type: i0.Output }],
        multitouchend: [{ type: i0.Output }],
        multitouchmove: [{ type: i0.Output }],
        multitouchstart: [{ type: i0.Output }],
        optionschange: [{ type: i0.Output }],
        sizechange: [{ type: i0.Output }],
        typechange: [{ type: i0.Output }],
        yawheel: [{ type: i0.Output }]
    };

    /**
     * The `ya-geoobject` component wraps `ymaps.GeoObject` class from the Yandex Maps API.
     * You can configure it via the component's inputs.
     * Events can be bound using the outputs of the component.
     *
     * <example-url>https://stackblitz.com/edit/geoobject-polygon?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map [center]="[55.761952, 37.620739]">
     *   <ya-geoobject
     *     [feature]="{ geometry: { type: 'Rectangle', coordinates: [[55.665, 37.66], [55.64,37.53]] } }"
     *   ></ya-geoobject>
     * </ya-map>
     * ```
     */
    var YaGeoObjectDirective = /** @class */ (function () {
        function YaGeoObjectDirective(_ngZone, _yaMapComponent) {
            this._ngZone = _ngZone;
            this._yaMapComponent = _yaMapComponent;
            this._sub = new rxjs.Subscription();
            this._eventManager = new EventManager(this._ngZone);
            /**
             * GeoObject instance is added in a Map.
             */
            this.ready = new i0.EventEmitter();
            /**
             * Closing the balloon.
             */
            this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
            /**
             * Opening a balloon on a map.
             */
            this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
            /**
             * Event preceding the "drag" event.
             */
            this.beforedrag = this._eventManager.getLazyEmitter('beforedrag');
            /**
             * Event preceding the "dragstart" event.
             */
            this.beforedragstart = this._eventManager.getLazyEmitter('beforedragstart');
            /**
             * Single left-click on the object.
             */
            this.yaclick = this._eventManager.getLazyEmitter('click');
            /**
             * Calls the element's context menu.
             */
            this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
            /**
             * Double left-click on the object.
             */
            this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
            /**
             * Dragging a geo object.
             */
            this.yadrag = this._eventManager.getLazyEmitter('drag');
            /**
             * End of geo object dragging.
             */
            this.yadragend = this._eventManager.getLazyEmitter('dragend');
            /**
             * Start of geo object dragging.
             */
            this.yadragstart = this._eventManager.getLazyEmitter('dragstart');
            /**
             * Change in the state of the editor for the geo object's geometry.
             */
            this.editorstatechange = this._eventManager.getLazyEmitter('editorstatechange');
            /**
             * Change to the geo object geometry
             */
            this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');
            /**
             * Closing the hint.
             */
            this.hintclose = this._eventManager.getLazyEmitter('hintclose');
            /**
             * Opening a hint on a map.
             */
            this.hintopen = this._eventManager.getLazyEmitter('hintopen');
            /**
             * Map reference changed.
             */
            this.mapchange = this._eventManager.getLazyEmitter('mapchange');
            /**
             * Pressing the mouse button over the object.
             */
            this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
            /**
             * Pointing the cursor at the object.
             */
            this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
            /**
             * Moving the cursor off of the object.
             */
            this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
            /**
             * Moving the cursor over the object.
             */
            this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
            /**
             * Letting go of the mouse button over an object.
             */
            this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
            /**
             * End of multitouch.
             */
            this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
            /**
             * Repeating event during multitouch.
             */
            this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
            /**
             * Start of multitouch.
             */
            this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
            /**
             * Change to the object options.
             */
            this.optionschange = this._eventManager.getLazyEmitter('optionschange');
            /**
             * Change to the geo object overlay.
             */
            this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');
            /**
             * The parent object reference changed.
             */
            this.parentchange = this._eventManager.getLazyEmitter('parentchange');
            /**
             * Change to the geo object data.
             */
            this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');
            /**
             * Mouse wheel scrolling.
             */
            this.yawheel = this._eventManager.getLazyEmitter('wheel');
        }
        /**
         * Handles input changes and passes them in API.
         * @param changes
         */
        YaGeoObjectDirective.prototype.ngOnChanges = function (changes) {
            var geoObject = this.geoObject;
            if (geoObject) {
                var feature = changes.feature, options = changes.options;
                if (feature) {
                    this._setFeature(feature.currentValue, geoObject);
                }
                if (options) {
                    geoObject.options.set(options.currentValue);
                }
            }
        };
        YaGeoObjectDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this._yaMapComponent.isBrowser) {
                var sub = this._yaMapComponent.map$.subscribe(function (map) {
                    if (map) {
                        var geoObject_1 = _this._createGeoObject();
                        _this.geoObject = geoObject_1;
                        map.geoObjects.add(geoObject_1);
                        _this._eventManager.setTarget(geoObject_1);
                        _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: geoObject_1 }); });
                    }
                });
                this._sub.add(sub);
            }
        };
        YaGeoObjectDirective.prototype.ngOnDestroy = function () {
            var _a, _b;
            if (this.geoObject) {
                (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this.geoObject);
                this._eventManager.destroy();
            }
            this._sub.unsubscribe();
        };
        /**
         * Destructs feature and passes it in API.
         * @param feature
         * @param geoObject
         */
        YaGeoObjectDirective.prototype._setFeature = function (feature, geoObject) {
            var geometry = feature.geometry, properties = feature.properties;
            if (geometry) {
                console.warn('The geometry can not be changed after entity init. To set it, you should recreate a GeoObject with new feature.geometry');
            }
            if (properties) {
                geoObject.properties.set(properties);
            }
        };
        /**
         * Creates GeoObject.
         */
        YaGeoObjectDirective.prototype._createGeoObject = function () {
            return new ymaps.GeoObject(this.feature, this.options);
        };
        return YaGeoObjectDirective;
    }());
    YaGeoObjectDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ya-geoobject',
                },] }
    ];
    YaGeoObjectDirective.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaMapComponent }
    ]; };
    YaGeoObjectDirective.propDecorators = {
        feature: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        ready: [{ type: i0.Output }],
        balloonclose: [{ type: i0.Output }],
        balloonopen: [{ type: i0.Output }],
        beforedrag: [{ type: i0.Output }],
        beforedragstart: [{ type: i0.Output }],
        yaclick: [{ type: i0.Output }],
        yacontextmenu: [{ type: i0.Output }],
        yadblclick: [{ type: i0.Output }],
        yadrag: [{ type: i0.Output }],
        yadragend: [{ type: i0.Output }],
        yadragstart: [{ type: i0.Output }],
        editorstatechange: [{ type: i0.Output }],
        geometrychange: [{ type: i0.Output }],
        hintclose: [{ type: i0.Output }],
        hintopen: [{ type: i0.Output }],
        mapchange: [{ type: i0.Output }],
        yamousedown: [{ type: i0.Output }],
        yamouseenter: [{ type: i0.Output }],
        yamouseleave: [{ type: i0.Output }],
        yamousemove: [{ type: i0.Output }],
        yamouseup: [{ type: i0.Output }],
        multitouchend: [{ type: i0.Output }],
        multitouchmove: [{ type: i0.Output }],
        multitouchstart: [{ type: i0.Output }],
        optionschange: [{ type: i0.Output }],
        overlaychange: [{ type: i0.Output }],
        parentchange: [{ type: i0.Output }],
        propertieschange: [{ type: i0.Output }],
        yawheel: [{ type: i0.Output }]
    };

    /**
     * The `ya-placemark` directive wraps `ymaps.Placemark` class from the Yandex Maps API.
     * You can configure it via the directive's inputs.
     * Events can be bound using the outputs of the directive.
     *
     * <example-url>https://stackblitz.com/edit/custom-placemark?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map [center]="[55.751952, 37.600739]">
     *   <ya-placemark [geometry]="[55.751952, 37.600739]"></ya-placemark>
     * </ya-map>
     * ```
     */
    var YaPlacemarkDirective = /** @class */ (function () {
        function YaPlacemarkDirective(_ngZone, _yaMapComponent) {
            this._ngZone = _ngZone;
            this._yaMapComponent = _yaMapComponent;
            this._sub = new rxjs.Subscription();
            this._eventManager = new EventManager(this._ngZone);
            /**
             * Placemark instance is added in a Map.
             */
            this.ready = new i0.EventEmitter();
            /**
             * Closing the balloon.
             */
            this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
            /**
             * Opening a balloon on a map.
             */
            this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
            /**
             * Event preceding the "drag" event.
             */
            this.beforedrag = this._eventManager.getLazyEmitter('beforedrag');
            /**
             * Event preceding the "dragstart" event.
             */
            this.beforedragstart = this._eventManager.getLazyEmitter('beforedragstart');
            /**
             * Single left-click on the object.
             */
            this.yaclick = this._eventManager.getLazyEmitter('click');
            /**
             * Calls the element's context menu.
             */
            this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
            /**
             * Double left-click on the object.
             */
            this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
            /**
             * Dragging a geo object.
             */
            this.yadrag = this._eventManager.getLazyEmitter('drag');
            /**
             * End of geo object dragging.
             */
            this.yadragend = this._eventManager.getLazyEmitter('dragend');
            /**
             * Start of geo object dragging.
             */
            this.yadragstart = this._eventManager.getLazyEmitter('dragstart');
            /**
             * Change in the state of the editor for the geo object's geometry.
             */
            this.editorstatechange = this._eventManager.getLazyEmitter('editorstatechange');
            /**
             * Change to the geo object geometry
             */
            this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');
            /**
             * Closing the hint.
             */
            this.hintclose = this._eventManager.getLazyEmitter('hintclose');
            /**
             * Opening a hint on a map.
             */
            this.hintopen = this._eventManager.getLazyEmitter('hintopen');
            /**
             * Map reference changed.
             */
            this.mapchange = this._eventManager.getLazyEmitter('mapchange');
            /**
             * Pressing the mouse button over the object.
             */
            this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
            /**
             * Pointing the cursor at the object.
             */
            this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
            /**
             * Moving the cursor off of the object.
             */
            this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
            /**
             * Moving the cursor over the object.
             */
            this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
            /**
             * Letting go of the mouse button over an object.
             */
            this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
            /**
             * End of multitouch.
             */
            this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
            /**
             * Repeating event during multitouch.
             */
            this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
            /**
             * Start of multitouch.
             */
            this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
            /**
             * Change to the object options.
             */
            this.optionschange = this._eventManager.getLazyEmitter('optionschange');
            /**
             * Change to the geo object overlay.
             */
            this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');
            /**
             * The parent object reference changed.
             */
            this.parentchange = this._eventManager.getLazyEmitter('parentchange');
            /**
             * Change to the geo object data.
             */
            this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');
            /**
             * Mouse wheel scrolling.
             */
            this.yawheel = this._eventManager.getLazyEmitter('wheel');
        }
        /**
         * Handles input changes and passes them in API.
         * @param changes
         */
        YaPlacemarkDirective.prototype.ngOnChanges = function (changes) {
            var _a;
            var placemark = this.placemark;
            if (placemark) {
                var geometry = changes.geometry, properties = changes.properties, options = changes.options;
                if (geometry) {
                    (_a = placemark.geometry) === null || _a === void 0 ? void 0 : _a.setCoordinates(geometry.currentValue);
                }
                if (properties) {
                    placemark.properties.set(properties.currentValue);
                }
                if (options) {
                    placemark.options.set(options.currentValue);
                }
            }
        };
        YaPlacemarkDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this._yaMapComponent.isBrowser) {
                var sub = this._yaMapComponent.map$.subscribe(function (map) {
                    if (map) {
                        var placemark_1 = _this._createPlacemark();
                        _this.placemark = placemark_1;
                        map.geoObjects.add(placemark_1);
                        _this._eventManager.setTarget(placemark_1);
                        _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: placemark_1 }); });
                    }
                });
                this._sub.add(sub);
            }
        };
        YaPlacemarkDirective.prototype.ngOnDestroy = function () {
            var _a, _b;
            if (this.placemark) {
                (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this.placemark);
                this._eventManager.destroy();
            }
            this._sub.unsubscribe();
        };
        /**
         * Creates a placemark.
         */
        YaPlacemarkDirective.prototype._createPlacemark = function () {
            return new ymaps.Placemark(this.geometry, this.properties, this.options);
        };
        return YaPlacemarkDirective;
    }());
    YaPlacemarkDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ya-placemark',
                },] }
    ];
    YaPlacemarkDirective.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaMapComponent }
    ]; };
    YaPlacemarkDirective.propDecorators = {
        geometry: [{ type: i0.Input }],
        properties: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        ready: [{ type: i0.Output }],
        balloonclose: [{ type: i0.Output }],
        balloonopen: [{ type: i0.Output }],
        beforedrag: [{ type: i0.Output }],
        beforedragstart: [{ type: i0.Output }],
        yaclick: [{ type: i0.Output }],
        yacontextmenu: [{ type: i0.Output }],
        yadblclick: [{ type: i0.Output }],
        yadrag: [{ type: i0.Output }],
        yadragend: [{ type: i0.Output }],
        yadragstart: [{ type: i0.Output }],
        editorstatechange: [{ type: i0.Output }],
        geometrychange: [{ type: i0.Output }],
        hintclose: [{ type: i0.Output }],
        hintopen: [{ type: i0.Output }],
        mapchange: [{ type: i0.Output }],
        yamousedown: [{ type: i0.Output }],
        yamouseenter: [{ type: i0.Output }],
        yamouseleave: [{ type: i0.Output }],
        yamousemove: [{ type: i0.Output }],
        yamouseup: [{ type: i0.Output }],
        multitouchend: [{ type: i0.Output }],
        multitouchmove: [{ type: i0.Output }],
        multitouchstart: [{ type: i0.Output }],
        optionschange: [{ type: i0.Output }],
        overlaychange: [{ type: i0.Output }],
        parentchange: [{ type: i0.Output }],
        propertieschange: [{ type: i0.Output }],
        yawheel: [{ type: i0.Output }]
    };

    /**
     * The `ya-clusterer` component wraps `ymaps.Clusterer` class from the Yandex Maps API.
     * You can configure it via the component's inputs.
     * Events can be bound using the outputs of the component.
     *
     * <example-url>https://stackblitz.com/edit/placemark-clusterer?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map [center]="[55.761952, 37.620739]">
     *   <ya-clusterer [options]="{ minClusterSize: 5 }">
     *     <ya-placemark [geometry]="[55.74, 37.5]"></ya-placemark>
     *     <ya-placemark [geometry]="[55.64, 37.46]"></ya-placemark>
     *     <ya-placemark [geometry]="[55.75, 37.38]"></ya-placemark>
     *
     *     <ya-geoobject
     *       [feature]="{ geometry: { type: 'Point', coordinates: [55.81, 37.4] } }"
     *      ></ya-geoobject>
     *
     *     <ya-geoobject
     *       [feature]="{ geometry: { type: 'Point', coordinates: [55.7, 37.39] } }"
     *      ></ya-geoobject>
     *   </ya-clusterer>
     * </ya-map>
     * ```
     */
    var YaClustererComponent = /** @class */ (function () {
        function YaClustererComponent(_ngZone, _yaMapComponent) {
            this._ngZone = _ngZone;
            this._yaMapComponent = _yaMapComponent;
            this._sub = new rxjs.Subscription();
            this._eventManager = new EventManager(this._ngZone);
            /**
             * Clusterer instance is added in a Map.
             */
            this.ready = new i0.EventEmitter();
            /**
             * Closing the hint.
             */
            this.hintclose = this._eventManager.getLazyEmitter('hintclose');
            /**
             * Opening a hint on a map.
             */
            this.hintopen = this._eventManager.getLazyEmitter('hintopen');
            /**
             * Map reference changed.
             */
            this.mapchange = this._eventManager.getLazyEmitter('mapchange');
            /**
             * Change to the object options.
             */
            this.optionschange = this._eventManager.getLazyEmitter('optionschange');
            /**
             * The parent object reference changed.
             */
            this.parentchange = this._eventManager.getLazyEmitter('parentchange');
        }
        /**
         * Handles input changes and passes them in API.
         * @param changes
         */
        YaClustererComponent.prototype.ngOnChanges = function (changes) {
            var clusterer = this._clusterer;
            if (clusterer) {
                var options = changes.options;
                if (options) {
                    clusterer.options.set(options.currentValue);
                }
            }
        };
        YaClustererComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this._yaMapComponent.isBrowser) {
                var sub = this._yaMapComponent.map$.subscribe(function (map) {
                    if (map) {
                        var clusterer_1 = _this._createClusterer();
                        _this._clusterer = clusterer_1;
                        map.geoObjects.add(clusterer_1);
                        _this._eventManager.setTarget(clusterer_1);
                        _this._watchForContentChanges(clusterer_1);
                        _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: clusterer_1 }); });
                    }
                });
                this._sub.add(sub);
            }
        };
        YaClustererComponent.prototype.ngOnDestroy = function () {
            this._eventManager.destroy();
            this._sub.unsubscribe();
        };
        /**
         * Creates Clusterer.
         */
        YaClustererComponent.prototype._createClusterer = function () {
            return new ymaps.Clusterer(this.options);
        };
        YaClustererComponent.prototype._watchForContentChanges = function (clusterer) {
            var _this = this;
            /**
             * Adds new Placemarks to the clusterer on changes.
             */
            var currentPlacemarks = new Set();
            this._getInternalPlacemarks(this._placemarks.toArray()).forEach(function (placemark) {
                currentPlacemarks.add(placemark);
                clusterer.add(placemark);
            });
            var placemarksSub = this._placemarks.changes.subscribe(function (placemarkDirectives) {
                var newPlacemarks = new Set(_this._getInternalPlacemarks(placemarkDirectives));
                var difference = _this._getDifference(newPlacemarks, currentPlacemarks);
                clusterer.add(difference.toAdd);
                clusterer.remove(difference.toRemove);
            });
            this._sub.add(placemarksSub);
            /**
             * Adds new GeoObjects to the clusterer on changes.
             */
            var currentGeoObjects = new Set();
            this._getInternalGeoObjects(this._geoObjects.toArray()).forEach(function (geoObject) {
                currentGeoObjects.add(geoObject);
                clusterer.add(geoObject);
            });
            var geoObjectsSub = this._geoObjects.changes.subscribe(function (geoObjectDirectives) {
                var newGeoObjects = new Set(_this._getInternalGeoObjects(geoObjectDirectives));
                var difference = _this._getDifference(newGeoObjects, currentGeoObjects);
                clusterer.add(difference.toAdd);
                clusterer.remove(difference.toRemove);
            });
            this._sub.add(geoObjectsSub);
        };
        /**
         * Determines what should be added/removed in current set to equal new set
         *
         * @param newSet
         * @param currentSet
         */
        YaClustererComponent.prototype._getDifference = function (newSet, currentSet) {
            var toAdd = [];
            var toRemove = [];
            newSet.forEach(function (component) {
                if (!currentSet.has(component)) {
                    toAdd.push(component);
                    currentSet.add(component);
                }
            });
            currentSet.forEach(function (component) {
                if (!newSet.has(component)) {
                    toRemove.push(component);
                    currentSet.delete(component);
                }
            });
            return {
                toAdd: toAdd,
                toRemove: toRemove,
            };
        };
        YaClustererComponent.prototype._getInternalPlacemarks = function (placemarks) {
            return placemarks
                .filter(function (component) { return !!component.placemark; })
                .map(function (component) { return component.placemark; });
        };
        YaClustererComponent.prototype._getInternalGeoObjects = function (geoObjects) {
            return geoObjects
                .filter(function (component) { return !!component.geoObject; })
                .map(function (component) { return component.geoObject; });
        };
        return YaClustererComponent;
    }());
    YaClustererComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ya-clusterer',
                    template: '<ng-content></ng-content>',
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    YaClustererComponent.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaMapComponent }
    ]; };
    YaClustererComponent.propDecorators = {
        _placemarks: [{ type: i0.ContentChildren, args: [YaPlacemarkDirective,] }],
        _geoObjects: [{ type: i0.ContentChildren, args: [YaGeoObjectDirective,] }],
        options: [{ type: i0.Input }],
        ready: [{ type: i0.Output }],
        hintclose: [{ type: i0.Output }],
        hintopen: [{ type: i0.Output }],
        mapchange: [{ type: i0.Output }],
        optionschange: [{ type: i0.Output }],
        parentchange: [{ type: i0.Output }]
    };

    /**
     * The `ya-control` component wraps `ymaps.control[YaControlType]` classes from the Yandex Maps API.
     * You can configure `ymaps.control[YaControlType]` via the component's inputs.
     * API Events can be bound only manually. You can use `ready` event to get an instance.
     *
     * <example-url>https://stackblitz.com/edit/searchcontrol?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map [center]="[55.761952, 37.620739]">
     *   <ya-control
     *     type="RoutePanel"
     *     [parameters]="{ options: { float: 'right' } }"
     *   ></ya-control>
     * </ya-map>
     * ```
     */
    var YaControlDirective = /** @class */ (function () {
        function YaControlDirective(_ngZone, _yaMapComponent) {
            this._ngZone = _ngZone;
            this._yaMapComponent = _yaMapComponent;
            this._sub = new rxjs.Subscription();
            /**
             * Control instance is added in a Map.
             */
            this.ready = new i0.EventEmitter();
        }
        YaControlDirective.prototype.ngOnChanges = function () {
            if (this._control) {
                console.warn('Control does not support dynamic configuration. You can config it manually using ymaps or recreate the component with new configuration');
            }
        };
        YaControlDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this._yaMapComponent.isBrowser) {
                var sub = this._yaMapComponent.map$.subscribe(function (map) {
                    if (map) {
                        var control_1 = new ymaps.control[_this.type](_this.parameters);
                        _this._control = control_1;
                        /**
                         * RoutePanel ignores state in parameters. API bug
                         */
                        if (control_1 instanceof ymaps.control.RoutePanel &&
                            _this.parameters &&
                            _this.parameters.state) {
                            control_1.routePanel.state.set(Object.assign({}, _this.parameters.state));
                        }
                        map.controls.add(control_1);
                        _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: control_1 }); });
                    }
                });
                this._sub.add(sub);
            }
        };
        YaControlDirective.prototype.ngOnDestroy = function () {
            var _a, _b;
            if (this._control) {
                (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.controls.remove(this._control);
            }
        };
        return YaControlDirective;
    }());
    YaControlDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ya-control',
                },] }
    ];
    YaControlDirective.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaMapComponent }
    ]; };
    YaControlDirective.propDecorators = {
        type: [{ type: i0.Input }],
        parameters: [{ type: i0.Input }],
        ready: [{ type: i0.Output }]
    };

    /**
     * The `ya-multiroute` component wraps `ymaps.multiRouter.MultiRoute` class from the Yandex Maps API.
     * You can configure it via the component's inputs.
     * Events can be bound using the outputs of the component.
     *
     * <example-url>https://stackblitz.com/edit/multiroute-pedestrian?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map [center]="[55.761952, 37.620739]">
     *   <ya-multiroute
     *     [referencePoints]="[[55.751952, 37.600739], 'Красные ворота, Москва']"
     *     [model]="{ params: { routingMode: 'pedestrian' } }"
     *   ></ya-multiroute>
     * </ya-map>
     * ```
     */
    var YaMultirouteDirective = /** @class */ (function () {
        function YaMultirouteDirective(_ngZone, _yaMapComponent) {
            this._ngZone = _ngZone;
            this._yaMapComponent = _yaMapComponent;
            this._sub = new rxjs.Subscription();
            this._eventManager = new EventManager(this._ngZone);
            /**
             * Multiroute instance is added in a Map.
             */
            this.ready = new i0.EventEmitter();
            /**
             * Change to the active route.
             */
            this.activeroutechange = this._eventManager.getLazyEmitter('activeroutechange');
            /**
             * Closing the balloon.
             */
            this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
            /**
             * Opening a balloon on a map.
             */
            this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
            /**
             * The event occurs at the time of setting the map center and its zoom level for optimal display of the multi-route.
             */
            this.boundsautoapply = this._eventManager.getLazyEmitter('boundsautoapply');
            /**
             * Changing coordinates of the geographical area covering the multi-route.
             */
            this.boundschange = this._eventManager.getLazyEmitter('boundschange');
            /**
             * Single left-click on the object.
             */
            this.yaclick = this._eventManager.getLazyEmitter('click');
            /**
             * Calls the element's context menu.
             */
            this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
            /**
             * Double left-click on the object.
             */
            this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
            /**
             * Change to the geo object geometry.
             */
            this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');
            /**
             * Map reference changed.
             */
            this.mapchange = this._eventManager.getLazyEmitter('mapchange');
            /**
             * Pressing the mouse button over the object.
             */
            this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
            /**
             * Pointing the cursor at the object.
             */
            this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
            /**
             * Moving the cursor off of the object.
             */
            this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
            /**
             * Moving the cursor over the object.
             */
            this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
            /**
             * Letting go of the mouse button over an object.
             */
            this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
            /**
             * End of multitouch.
             */
            this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
            /**
             * Repeating event during multitouch.
             */
            this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
            /**
             * Start of multitouch.
             */
            this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
            /**
             * Change to the object options.
             */
            this.optionschange = this._eventManager.getLazyEmitter('optionschange');
            /**
             * Change to the geo object overlay.
             */
            this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');
            /**
             * The parent object reference changed.
             */
            this.parentchange = this._eventManager.getLazyEmitter('parentchange');
            /**
             * Changing pixel coordinates of the area covering the multi-route.
             */
            this.pixelboundschange = this._eventManager.getLazyEmitter('pixelboundschange');
            /**
             * Change to the geo object data.
             */
            this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');
            /**
             * Updating the multi-route.
             */
            this.update = this._eventManager.getLazyEmitter('update');
            /**
             * Mouse wheel scrolling.
             */
            this.yawheel = this._eventManager.getLazyEmitter('wheel');
        }
        /**
         * Handles input changes and passes them in API.
         * @param changes
         */
        YaMultirouteDirective.prototype.ngOnChanges = function (changes) {
            var multiroute = this._multiroute;
            if (multiroute) {
                var referencePoints = changes.referencePoints, model = changes.model, options = changes.options;
                if (model) {
                    this._setModel(model.currentValue, multiroute);
                }
                if (referencePoints) {
                    multiroute.model.setReferencePoints(referencePoints.currentValue);
                }
                if (options) {
                    multiroute.options.set(options.currentValue);
                }
            }
        };
        YaMultirouteDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this._yaMapComponent.isBrowser) {
                var sub = this._yaMapComponent.map$.subscribe(function (map) {
                    if (map) {
                        var multiroute_1 = _this._createMultiroute();
                        _this._multiroute = multiroute_1;
                        map.geoObjects.add(multiroute_1);
                        _this._eventManager.setTarget(multiroute_1);
                        _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: multiroute_1 }); });
                    }
                });
                this._sub.add(sub);
            }
        };
        YaMultirouteDirective.prototype.ngOnDestroy = function () {
            var _a, _b;
            if (this._multiroute) {
                (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this._multiroute);
                this._eventManager.destroy();
            }
            this._sub.unsubscribe();
        };
        /**
         * Destructs state and passes them in API.
         * @param model
         * @param multiroute
         */
        YaMultirouteDirective.prototype._setModel = function (model, multiroute) {
            var referencePoints = model.referencePoints, params = model.params;
            if (referencePoints) {
                multiroute.model.setReferencePoints(referencePoints);
            }
            if (params) {
                multiroute.model.setParams(params);
            }
        };
        /**
         * Creates Multiroute.
         */
        YaMultirouteDirective.prototype._createMultiroute = function () {
            return new ymaps.multiRouter.MultiRoute(this._combineModel(), this.options);
        };
        /**
         * Combines the model and reference points into single object
         */
        YaMultirouteDirective.prototype._combineModel = function () {
            var model = (this.model || {});
            return Object.assign(Object.assign({}, model), { referencePoints: this.referencePoints || model.referencePoints });
        };
        return YaMultirouteDirective;
    }());
    YaMultirouteDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ya-multiroute',
                },] }
    ];
    YaMultirouteDirective.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaMapComponent }
    ]; };
    YaMultirouteDirective.propDecorators = {
        referencePoints: [{ type: i0.Input }],
        model: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        ready: [{ type: i0.Output }],
        activeroutechange: [{ type: i0.Output }],
        balloonclose: [{ type: i0.Output }],
        balloonopen: [{ type: i0.Output }],
        boundsautoapply: [{ type: i0.Output }],
        boundschange: [{ type: i0.Output }],
        yaclick: [{ type: i0.Output }],
        yacontextmenu: [{ type: i0.Output }],
        yadblclick: [{ type: i0.Output }],
        geometrychange: [{ type: i0.Output }],
        mapchange: [{ type: i0.Output }],
        yamousedown: [{ type: i0.Output }],
        yamouseenter: [{ type: i0.Output }],
        yamouseleave: [{ type: i0.Output }],
        yamousemove: [{ type: i0.Output }],
        yamouseup: [{ type: i0.Output }],
        multitouchend: [{ type: i0.Output }],
        multitouchmove: [{ type: i0.Output }],
        multitouchstart: [{ type: i0.Output }],
        optionschange: [{ type: i0.Output }],
        overlaychange: [{ type: i0.Output }],
        parentchange: [{ type: i0.Output }],
        pixelboundschange: [{ type: i0.Output }],
        propertieschange: [{ type: i0.Output }],
        update: [{ type: i0.Output }],
        yawheel: [{ type: i0.Output }]
    };

    /**
     * The `ya-panorama` component wraps `ymaps.panorama.Player` class from the Yandex Maps API.
     * You can configure it via the component's inputs.
     * Events can be bound using the outputs of the component.
     *
     * <example-url>https://stackblitz.com/edit/panorama?embed=1</example-url>
     *
     * @example
     * ```html
     * <ya-map>
     *   <ya-panorama [point]="[59.938557, 30.316198]" layer="yandex#airPanorama"></ya-panorama>
     * </ya-map>
     * ```
     */
    var YaPanoramaDirective = /** @class */ (function () {
        function YaPanoramaDirective(_ngZone, _yaMapComponent) {
            this._ngZone = _ngZone;
            this._yaMapComponent = _yaMapComponent;
            this._sub = new rxjs.Subscription();
            this._eventManager = new EventManager(this._ngZone);
            /**
             * Panorama instance is created.
             */
            this.ready = new i0.EventEmitter();
            /**
             * The player was closed by the user or destroyed using the panorama.Player.destroy method.
             */
            this.destroy = this._eventManager.getLazyEmitter('destroy');
            /**
             * The view direction changed.
             */
            this.directionchange = this._eventManager.getLazyEmitter('directionchange');
            /**
             * An error occurred during operation of the player. The user will be shown the appropriate screen.
             */
            this.yaerror = this._eventManager.getLazyEmitter('error');
            /**
             * The panorama player switched to full-screen mode.
             */
            this.fullscreenenter = this._eventManager.getLazyEmitter('fullscreenenter');
            /**
             * The panorama player exited full-screen mode.
             */
            this.fullscreenexit = this._eventManager.getLazyEmitter('fullscreenexit');
            /**
             * The user clicked on an expanded marker.
             */
            this.markercollapse = this._eventManager.getLazyEmitter('markercollapse');
            /**
             * The user clicked on a collapsed marker.
             */
            this.markerexpand = this._eventManager.getLazyEmitter('markerexpand');
            /**
             * The user's cursor hovered over a marker.
             */
            this.markermouseenter = this._eventManager.getLazyEmitter('markermouseenter');
            /**
             * The user's cursor left a marker.
             */
            this.markermouseleave = this._eventManager.getLazyEmitter('markermouseleave');
            /**
             * The open panorama changed.
             */
            this.panoramachange = this._eventManager.getLazyEmitter('panoramachange');
            /**
             * The size of the viewport has been changed.
             */
            this.spanchange = this._eventManager.getLazyEmitter('spanchange');
        }
        /**
         * Handles input changes and passes them in API.
         * @param changes
         */
        YaPanoramaDirective.prototype.ngOnChanges = function (changes) {
            var player = this._player;
            if (player) {
                var point = changes.point, layer = changes.layer, options = changes.options;
                /**
                 * player.moveTo resets values to default if any of them isn't passed.
                 * That's why we use value from currentValue OR previous value from input.
                 * With that logic it's possible to pass only point, layer or options.
                 */
                if (point || layer) {
                    var combinedPoint = (point === null || point === void 0 ? void 0 : point.currentValue) || this.point;
                    var combinedLayer = (layer === null || layer === void 0 ? void 0 : layer.currentValue) || this.layer;
                    player.moveTo(combinedPoint, { layer: combinedLayer });
                }
                if (options) {
                    this._setOptions(options.currentValue, player);
                }
            }
        };
        YaPanoramaDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this._yaMapComponent.isBrowser) {
                var panorama$ = this._yaMapComponent.map$.pipe(operators.filter(function (m) { return Boolean(m); }), operators.switchMap(function (m) {
                    /**
                     * Map and panorama use the same container, so need to destroy/remove map
                     */
                    m.destroy();
                    return _this._createPanorama();
                }));
                var sub = panorama$.subscribe(function (panorama) {
                    var id = _this._yaMapComponent.container.nativeElement.id;
                    var player = new ymaps.panorama.Player(id, panorama, _this.options);
                    _this._player = player;
                    _this._eventManager.setTarget(player);
                    _this._ngZone.run(function () { return _this.ready.emit({ ymaps: ymaps, target: player }); });
                });
                this._sub.add(sub);
            }
        };
        YaPanoramaDirective.prototype.ngOnDestroy = function () {
            this._eventManager.destroy();
            this._sub.unsubscribe();
        };
        /**
         * Destructs state and passes it in API.
         * @param options
         * @param player
         */
        YaPanoramaDirective.prototype._setOptions = function (options, player) {
            var autoFitToViewport = options.autoFitToViewport, controls = options.controls, direction = options.direction, hotkeysEnabled = options.hotkeysEnabled, span = options.span, scrollZoomBehavior = options.scrollZoomBehavior, suppressMapOpenBlock = options.suppressMapOpenBlock;
            if (autoFitToViewport ||
                controls ||
                hotkeysEnabled ||
                scrollZoomBehavior ||
                suppressMapOpenBlock) {
                console.warn('Only direction and span can be set after entity init. To set other options, you should recreate a Panorama with new options');
            }
            if (direction) {
                player.setDirection(direction);
            }
            if (span) {
                player.setSpan(span);
            }
        };
        /**
         * Searches for a panorama and returns first
         */
        YaPanoramaDirective.prototype._createPanorama = function () {
            return rxjs.from(ymaps.panorama.locate(this.point, { layer: this.layer })).pipe(operators.map(function (panoramas) { return panoramas[0]; }));
        };
        return YaPanoramaDirective;
    }());
    YaPanoramaDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ya-panorama',
                },] }
    ];
    YaPanoramaDirective.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaMapComponent }
    ]; };
    YaPanoramaDirective.propDecorators = {
        point: [{ type: i0.Input }],
        layer: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        ready: [{ type: i0.Output }],
        destroy: [{ type: i0.Output }],
        directionchange: [{ type: i0.Output }],
        yaerror: [{ type: i0.Output }],
        fullscreenenter: [{ type: i0.Output }],
        fullscreenexit: [{ type: i0.Output }],
        markercollapse: [{ type: i0.Output }],
        markerexpand: [{ type: i0.Output }],
        markermouseenter: [{ type: i0.Output }],
        markermouseleave: [{ type: i0.Output }],
        panoramachange: [{ type: i0.Output }],
        spanchange: [{ type: i0.Output }]
    };

    var AngularYandexMapsModule = /** @class */ (function () {
        function AngularYandexMapsModule() {
        }
        /**
         * Please use this method when you register the module at the root level
         * @param config
         */
        AngularYandexMapsModule.forRoot = function (config) {
            return {
                ngModule: AngularYandexMapsModule,
                providers: [{ provide: YA_CONFIG, useValue: config }],
            };
        };
        return AngularYandexMapsModule;
    }());
    AngularYandexMapsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        YaClustererComponent,
                        YaControlDirective,
                        YaGeoObjectDirective,
                        YaMapComponent,
                        YaMultirouteDirective,
                        YaPanoramaDirective,
                        YaPlacemarkDirective,
                    ],
                    imports: [i1.CommonModule],
                    exports: [
                        YaClustererComponent,
                        YaControlDirective,
                        YaGeoObjectDirective,
                        YaMapComponent,
                        YaMultirouteDirective,
                        YaPanoramaDirective,
                        YaPlacemarkDirective,
                    ],
                },] }
    ];

    /**
     * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex Maps API.
     *
     * @example
     * ```ts
     * import { YaGeocoderService } from 'angular8-yandex-maps';
     *
     * export class AppComponent {
     *   constructor(private yaGeocoderService: YaGeocoderService) {
     *     this.yaGeocoderService.geocode('Moscow')
     *       .subscribe(v => console.log(v))
     *   }
     * }
     * ```
     */
    var YaGeocoderService = /** @class */ (function () {
        function YaGeocoderService(_ngZone, _yaApiLoaderService) {
            this._ngZone = _ngZone;
            this._yaApiLoaderService = _yaApiLoaderService;
        }
        /**
         * Processes geocoding requests
         * @param request
         * @param options
         */
        YaGeocoderService.prototype.geocode = function (request, options) {
            var _this = this;
            return this._yaApiLoaderService.load().pipe(operators.switchMap(function () { return rxjs.from(ymaps.geocode(request, options)); }), operators.switchMap(function (result) { return new rxjs.Observable(function (observer) {
                _this._ngZone.run(function () {
                    observer.next(result);
                    observer.complete();
                });
            }); }));
        };
        return YaGeocoderService;
    }());
    YaGeocoderService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function YaGeocoderService_Factory() { return new YaGeocoderService(i0__namespace.ɵɵinject(i0__namespace.NgZone), i0__namespace.ɵɵinject(YaApiLoaderService)); }, token: YaGeocoderService, providedIn: "root" });
    YaGeocoderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    YaGeocoderService.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: YaApiLoaderService }
    ]; };

    /// <reference path="./lib/typings/yandex-maps/index.ts" />

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AngularYandexMapsModule = AngularYandexMapsModule;
    exports.YA_CONFIG = YA_CONFIG;
    exports.YaApiLoaderService = YaApiLoaderService;
    exports.YaClustererComponent = YaClustererComponent;
    exports.YaControlDirective = YaControlDirective;
    exports.YaGeoObjectDirective = YaGeoObjectDirective;
    exports.YaGeocoderService = YaGeocoderService;
    exports.YaMapComponent = YaMapComponent;
    exports.YaMultirouteDirective = YaMultirouteDirective;
    exports.YaPanoramaDirective = YaPanoramaDirective;
    exports.YaPlacemarkDirective = YaPlacemarkDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular8-yandex-maps.umd.js.map
