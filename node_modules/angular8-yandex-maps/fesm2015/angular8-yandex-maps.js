import * as i1 from '@angular/common';
import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, EventEmitter, Component, ChangeDetectionStrategy, NgZone, PLATFORM_ID, ViewChild, Input, Output, Directive, ContentChildren, NgModule } from '@angular/core';
import { __rest } from 'tslib';
import { from, fromEvent, throwError, merge, BehaviorSubject, Observable, Subscription } from 'rxjs';
import { map, switchMap, take, filter } from 'rxjs/operators';

const YA_CONFIG = new InjectionToken('YA_CONFIG');
/**
 * The `YaApiLoader` service handles loading of Yandex.Maps API.
 *
 * @example
 * ```ts
 * import { YaApiLoaderService } from 'angular8-yandex-maps';
 *
 * export class AppComponent {
 *   constructor(private yaApiLoaderService: YaApiLoaderService) {
 *     this.yaApiLoaderService.load()
 *       .subscribe(v => console.log(v))
 *   }
 * }
 *```
 *
 * @dynamic
 */
class YaApiLoaderService {
    constructor(config, _document) {
        this._document = _document;
        this._defaultConfig = { lang: 'ru_RU' };
        this._config = Object.assign(Object.assign({}, this._defaultConfig), config);
    }
    /**
     * Loads Yandex.Maps API
     */
    load() {
        if (window.ymaps) {
            return from(ymaps.ready()).pipe(map(() => ymaps));
        }
        if (!this._script) {
            const script = this._document.createElement('script');
            script.type = 'text/javascript';
            script.src = this._getScriptSource(this._config);
            script.id = 'yandexMapsApiScript';
            script.async = true;
            script.defer = true;
            this._script = this._document.body.appendChild(script);
        }
        const load = fromEvent(this._script, 'load').pipe(switchMap(() => from(ymaps.ready()).pipe(map(() => ymaps))));
        const error = fromEvent(this._script, 'error').pipe(switchMap((e) => throwError(e)));
        return merge(load, error).pipe(take(1));
    }
    /**
     * Returns script source by config
     * @param config config with parameters that will be added in source
     * @example
     * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'
     * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })
     */
    _getScriptSource(config) {
        const { enterprise, version = '2.1' } = config, rest = __rest(config, ["enterprise", "version"]);
        const params = this._convertConfigIntoQueryParams(rest);
        return `https://${enterprise ? 'enterprise.' : ''}api-maps.yandex.ru/${version}/?${params}`;
    }
    /**
     * Converts a config into a query string parameters
     * @param config object for converting
     * @example
     * // returns "lang=ru_RU&apikey=XXX"
     * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })
     */
    _convertConfigIntoQueryParams(config) {
        return Object.entries(config)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');
    }
}
YaApiLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function YaApiLoaderService_Factory() { return new YaApiLoaderService(i0.ɵɵinject(YA_CONFIG, 8), i0.ɵɵinject(i1.DOCUMENT)); }, token: YaApiLoaderService, providedIn: "root" });
YaApiLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
YaApiLoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [YA_CONFIG,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * Copied from angular/components/google-maps and edited for Yandex Maps API.
 * {@link https://github.com/angular/components/blob/master/src/google-maps/map-event-manager.ts}
 */
/**
 * Manages event on a Yandex Maps object, ensuring that events are added only when necessary.
 * @internal
 */
class EventManager {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        /**
         * Listeners that were added before the target was set.
         */
        this._pending = [];
        this._listeners = [];
        this._targetStream = new BehaviorSubject(undefined);
    }
    /**
     * Gets an observable that adds an event listener to the map when a consumer subscribes to it.
     * @param name
     */
    getLazyEmitter(name) {
        return this._targetStream.pipe(switchMap((target) => {
            const observable = new Observable((observer) => {
                // If the target hasn't been initialized yet, cache the observer so it can be added later.
                if (!target) {
                    this._pending.push({ observable, observer });
                    return undefined;
                }
                const callback = (event) => {
                    const e = {
                        event,
                        target,
                        ymaps,
                    };
                    this._ngZone.run(() => observer.next(e));
                };
                const listener = target.events.add(name, callback);
                this._listeners.push({ name, callback, manager: listener });
                // Unsubscribe function
                return () => listener.remove(name, callback);
            });
            return observable;
        }));
    }
    /**
     * Sets the current target that the manager should bind events to.
     * @param target
     */
    setTarget(target) {
        const currentTarget = this._targetStream.value;
        if (target === currentTarget) {
            return;
        }
        // Clear the listeners from the pre-existing target.
        if (currentTarget) {
            this._clearListeners();
            this._pending = [];
        }
        this._targetStream.next(target);
        // Add the listeners that were bound before the map was initialized.
        this._pending.forEach((subscriber) => subscriber.observable.subscribe(subscriber.observer));
        this._pending = [];
    }
    /**
     * Destroys the manager and clears the event listeners.
     */
    destroy() {
        this._clearListeners();
        this._pending = [];
        this._targetStream.complete();
    }
    /**
     * Clears all currently-registered event listeners.
     */
    _clearListeners() {
        this._listeners.forEach((listener) => {
            const { name, callback, manager } = listener;
            manager.remove(name, callback);
        });
        this._listeners = [];
    }
}

/**
 * Generates a random string based on Date in hexadecimal numeral system
 * @example f175517fa4f3
 * @internal
 */
const generateRandomId = () => {
    return `f${Number(new Date()).toString(16)}`;
};

/**
 * The `ya-map` component wraps `ymaps.Map` class from the Yandex Maps API.
 * You can configure the map via the component's inputs.
 * Events can be bound using the outputs of the component.
 *
 * <example-url>https://stackblitz.com/edit/map-onload-event?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map
 *   [center]="[55.751952, 37.600739]"
 *   [state]="{type: 'yandex#satellite'}"
 * ></ya-map>
 * ```
 */
class YaMapComponent {
    constructor(_ngZone, _yaApiLoaderService, platformId) {
        this._ngZone = _ngZone;
        this._yaApiLoaderService = _yaApiLoaderService;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        this.map$ = new BehaviorSubject(undefined);
        /**
         * Map instance is created.
         */
        this.ready = new EventEmitter();
        /**
         * The start of a new smooth map movement.
         */
        this.actionbegin = this._eventManager.getLazyEmitter('actionbegin');
        /**
         * Event that occurs when an action step was prematurely stopped.
         */
        this.actionbreak = this._eventManager.getLazyEmitter('actionbreak');
        /**
         * The end of smooth map movement.
         */
        this.actionend = this._eventManager.getLazyEmitter('actionend');
        /**
         * The start of a new step of smooth movement.
         */
        this.actiontick = this._eventManager.getLazyEmitter('actiontick');
        /**
         * The end of performing a step of smooth movement.
         */
        this.actiontickcomplete = this._eventManager.getLazyEmitter('actiontickcomplete');
        /**
         * Closing the balloon.
         */
        this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
        /**
         * Opening a balloon on a map.
         */
        this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
        /**
         * Event for a change to the map viewport.
         */
        this.boundschange = this._eventManager.getLazyEmitter('boundschange');
        /**
         * Single left-click on the object.
         */
        this.yaclick = this._eventManager.getLazyEmitter('click');
        /**
         * Calls the element's context menu.
         */
        this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
        /**
         * Double left-click on the object.
         */
        this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
        /**
         * The map was destroyed.
         */
        this.destroy = this._eventManager.getLazyEmitter('destroy');
        /**
         * Closing the hint.
         */
        this.hintclose = this._eventManager.getLazyEmitter('hintclose');
        /**
         * Opening a hint on a map.
         */
        this.hintopen = this._eventManager.getLazyEmitter('hintopen');
        /**
         * Map margins changed.
         */
        this.marginchange = this._eventManager.getLazyEmitter('marginchange');
        /**
         * Pressing the mouse button over the object.
         */
        this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
        /**
         * Pointing the cursor at the object.
         */
        this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
        /**
         * Moving the cursor off of the object.
         */
        this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
        /**
         * Moving the cursor over the object.
         */
        this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
        /**
         * Letting go of the mouse button over an object.
         */
        this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
        /**
         * End of multitouch.
         */
        this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
        /**
         * Repeating event during multitouch.
         */
        this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
        /**
         * Start of multitouch.
         */
        this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
        /**
         * Map options changed.
         */
        this.optionschange = this._eventManager.getLazyEmitter('optionschange');
        /**
         * Map size changed.
         */
        this.sizechange = this._eventManager.getLazyEmitter('sizechange');
        /**
         * The map type changed.
         */
        this.typechange = this._eventManager.getLazyEmitter('typechange');
        /**
         * Mouse wheel scrolling.
         */
        this.yawheel = this._eventManager.getLazyEmitter('wheel');
        this.isBrowser = isPlatformBrowser(platformId);
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        const map = this.map$.value;
        if (map) {
            const { center, zoom, state, options } = changes;
            if (state) {
                this._setState(this._combineState(), map);
            }
            if (center) {
                map.setCenter(center.currentValue);
            }
            if (zoom) {
                map.setZoom(zoom.currentValue);
            }
            if (options) {
                map.options.set(options.currentValue);
            }
        }
    }
    ngAfterViewInit() {
        /**
         * It should be a noop during server-side rendering.
         */
        if (this.isBrowser) {
            const sub = this._yaApiLoaderService.load().subscribe(() => {
                const id = generateRandomId();
                const map = this._createMap(id);
                this.map$.next(map);
                this._eventManager.setTarget(map);
                this._ngZone.run(() => this.ready.emit({ ymaps, target: map }));
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        this._eventManager.destroy();
        this._sub.unsubscribe();
    }
    /**
     * Destructs state and passes it in API.
     * @param state
     * @param map
     */
    _setState(state, map) {
        const { behaviors, bounds, center, controls, margin, type, zoom } = state;
        if (behaviors) {
            map.behaviors.enable(behaviors);
        }
        if (bounds) {
            map.setBounds(bounds);
        }
        if (center) {
            map.setCenter(center);
        }
        if (controls) {
            controls.forEach((control) => map.controls.add(control));
        }
        if (margin) {
            map.margin.setDefaultMargin(margin);
        }
        if (type) {
            map.setType(type);
        }
        if (zoom) {
            map.setZoom(zoom);
        }
    }
    /**
     * Creates a map.
     * @param id ID which will be set to the map container.
     */
    _createMap(id) {
        const containerElem = this.container.nativeElement;
        containerElem.setAttribute('id', id);
        containerElem.style.cssText = 'width: 100%; height: 100%;';
        return new ymaps.Map(id, this._combineState(), this.options || {});
    }
    /**
     * Combines the center and zoom into single object.
     */
    _combineState() {
        var _a, _b;
        const state = this.state || {};
        return Object.assign(Object.assign({}, state), { center: this.center || state.center || [0, 0], zoom: (_b = (_a = this.zoom) !== null && _a !== void 0 ? _a : state.zoom) !== null && _b !== void 0 ? _b : 10 });
    }
}
YaMapComponent.decorators = [
    { type: Component, args: [{
                selector: 'ya-map',
                template: '<div #container></div>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
YaMapComponent.ctorParameters = () => [
    { type: NgZone },
    { type: YaApiLoaderService },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
YaMapComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container',] }],
    center: [{ type: Input }],
    zoom: [{ type: Input }],
    state: [{ type: Input }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    actionbegin: [{ type: Output }],
    actionbreak: [{ type: Output }],
    actionend: [{ type: Output }],
    actiontick: [{ type: Output }],
    actiontickcomplete: [{ type: Output }],
    balloonclose: [{ type: Output }],
    balloonopen: [{ type: Output }],
    boundschange: [{ type: Output }],
    yaclick: [{ type: Output }],
    yacontextmenu: [{ type: Output }],
    yadblclick: [{ type: Output }],
    destroy: [{ type: Output }],
    hintclose: [{ type: Output }],
    hintopen: [{ type: Output }],
    marginchange: [{ type: Output }],
    yamousedown: [{ type: Output }],
    yamouseenter: [{ type: Output }],
    yamouseleave: [{ type: Output }],
    yamousemove: [{ type: Output }],
    yamouseup: [{ type: Output }],
    multitouchend: [{ type: Output }],
    multitouchmove: [{ type: Output }],
    multitouchstart: [{ type: Output }],
    optionschange: [{ type: Output }],
    sizechange: [{ type: Output }],
    typechange: [{ type: Output }],
    yawheel: [{ type: Output }]
};

/**
 * The `ya-geoobject` component wraps `ymaps.GeoObject` class from the Yandex Maps API.
 * You can configure it via the component's inputs.
 * Events can be bound using the outputs of the component.
 *
 * <example-url>https://stackblitz.com/edit/geoobject-polygon?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map [center]="[55.761952, 37.620739]">
 *   <ya-geoobject
 *     [feature]="{ geometry: { type: 'Rectangle', coordinates: [[55.665, 37.66], [55.64,37.53]] } }"
 *   ></ya-geoobject>
 * </ya-map>
 * ```
 */
class YaGeoObjectDirective {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        /**
         * GeoObject instance is added in a Map.
         */
        this.ready = new EventEmitter();
        /**
         * Closing the balloon.
         */
        this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
        /**
         * Opening a balloon on a map.
         */
        this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
        /**
         * Event preceding the "drag" event.
         */
        this.beforedrag = this._eventManager.getLazyEmitter('beforedrag');
        /**
         * Event preceding the "dragstart" event.
         */
        this.beforedragstart = this._eventManager.getLazyEmitter('beforedragstart');
        /**
         * Single left-click on the object.
         */
        this.yaclick = this._eventManager.getLazyEmitter('click');
        /**
         * Calls the element's context menu.
         */
        this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
        /**
         * Double left-click on the object.
         */
        this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
        /**
         * Dragging a geo object.
         */
        this.yadrag = this._eventManager.getLazyEmitter('drag');
        /**
         * End of geo object dragging.
         */
        this.yadragend = this._eventManager.getLazyEmitter('dragend');
        /**
         * Start of geo object dragging.
         */
        this.yadragstart = this._eventManager.getLazyEmitter('dragstart');
        /**
         * Change in the state of the editor for the geo object's geometry.
         */
        this.editorstatechange = this._eventManager.getLazyEmitter('editorstatechange');
        /**
         * Change to the geo object geometry
         */
        this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');
        /**
         * Closing the hint.
         */
        this.hintclose = this._eventManager.getLazyEmitter('hintclose');
        /**
         * Opening a hint on a map.
         */
        this.hintopen = this._eventManager.getLazyEmitter('hintopen');
        /**
         * Map reference changed.
         */
        this.mapchange = this._eventManager.getLazyEmitter('mapchange');
        /**
         * Pressing the mouse button over the object.
         */
        this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
        /**
         * Pointing the cursor at the object.
         */
        this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
        /**
         * Moving the cursor off of the object.
         */
        this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
        /**
         * Moving the cursor over the object.
         */
        this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
        /**
         * Letting go of the mouse button over an object.
         */
        this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
        /**
         * End of multitouch.
         */
        this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
        /**
         * Repeating event during multitouch.
         */
        this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
        /**
         * Start of multitouch.
         */
        this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
        /**
         * Change to the object options.
         */
        this.optionschange = this._eventManager.getLazyEmitter('optionschange');
        /**
         * Change to the geo object overlay.
         */
        this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');
        /**
         * The parent object reference changed.
         */
        this.parentchange = this._eventManager.getLazyEmitter('parentchange');
        /**
         * Change to the geo object data.
         */
        this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');
        /**
         * Mouse wheel scrolling.
         */
        this.yawheel = this._eventManager.getLazyEmitter('wheel');
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        const { geoObject } = this;
        if (geoObject) {
            const { feature, options } = changes;
            if (feature) {
                this._setFeature(feature.currentValue, geoObject);
            }
            if (options) {
                geoObject.options.set(options.currentValue);
            }
        }
    }
    ngOnInit() {
        if (this._yaMapComponent.isBrowser) {
            const sub = this._yaMapComponent.map$.subscribe((map) => {
                if (map) {
                    const geoObject = this._createGeoObject();
                    this.geoObject = geoObject;
                    map.geoObjects.add(geoObject);
                    this._eventManager.setTarget(geoObject);
                    this._ngZone.run(() => this.ready.emit({ ymaps, target: geoObject }));
                }
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        var _a, _b;
        if (this.geoObject) {
            (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this.geoObject);
            this._eventManager.destroy();
        }
        this._sub.unsubscribe();
    }
    /**
     * Destructs feature and passes it in API.
     * @param feature
     * @param geoObject
     */
    _setFeature(feature, geoObject) {
        const { geometry, properties } = feature;
        if (geometry) {
            console.warn('The geometry can not be changed after entity init. To set it, you should recreate a GeoObject with new feature.geometry');
        }
        if (properties) {
            geoObject.properties.set(properties);
        }
    }
    /**
     * Creates GeoObject.
     */
    _createGeoObject() {
        return new ymaps.GeoObject(this.feature, this.options);
    }
}
YaGeoObjectDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ya-geoobject',
            },] }
];
YaGeoObjectDirective.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaGeoObjectDirective.propDecorators = {
    feature: [{ type: Input }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    balloonclose: [{ type: Output }],
    balloonopen: [{ type: Output }],
    beforedrag: [{ type: Output }],
    beforedragstart: [{ type: Output }],
    yaclick: [{ type: Output }],
    yacontextmenu: [{ type: Output }],
    yadblclick: [{ type: Output }],
    yadrag: [{ type: Output }],
    yadragend: [{ type: Output }],
    yadragstart: [{ type: Output }],
    editorstatechange: [{ type: Output }],
    geometrychange: [{ type: Output }],
    hintclose: [{ type: Output }],
    hintopen: [{ type: Output }],
    mapchange: [{ type: Output }],
    yamousedown: [{ type: Output }],
    yamouseenter: [{ type: Output }],
    yamouseleave: [{ type: Output }],
    yamousemove: [{ type: Output }],
    yamouseup: [{ type: Output }],
    multitouchend: [{ type: Output }],
    multitouchmove: [{ type: Output }],
    multitouchstart: [{ type: Output }],
    optionschange: [{ type: Output }],
    overlaychange: [{ type: Output }],
    parentchange: [{ type: Output }],
    propertieschange: [{ type: Output }],
    yawheel: [{ type: Output }]
};

/**
 * The `ya-placemark` directive wraps `ymaps.Placemark` class from the Yandex Maps API.
 * You can configure it via the directive's inputs.
 * Events can be bound using the outputs of the directive.
 *
 * <example-url>https://stackblitz.com/edit/custom-placemark?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map [center]="[55.751952, 37.600739]">
 *   <ya-placemark [geometry]="[55.751952, 37.600739]"></ya-placemark>
 * </ya-map>
 * ```
 */
class YaPlacemarkDirective {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        /**
         * Placemark instance is added in a Map.
         */
        this.ready = new EventEmitter();
        /**
         * Closing the balloon.
         */
        this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
        /**
         * Opening a balloon on a map.
         */
        this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
        /**
         * Event preceding the "drag" event.
         */
        this.beforedrag = this._eventManager.getLazyEmitter('beforedrag');
        /**
         * Event preceding the "dragstart" event.
         */
        this.beforedragstart = this._eventManager.getLazyEmitter('beforedragstart');
        /**
         * Single left-click on the object.
         */
        this.yaclick = this._eventManager.getLazyEmitter('click');
        /**
         * Calls the element's context menu.
         */
        this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
        /**
         * Double left-click on the object.
         */
        this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
        /**
         * Dragging a geo object.
         */
        this.yadrag = this._eventManager.getLazyEmitter('drag');
        /**
         * End of geo object dragging.
         */
        this.yadragend = this._eventManager.getLazyEmitter('dragend');
        /**
         * Start of geo object dragging.
         */
        this.yadragstart = this._eventManager.getLazyEmitter('dragstart');
        /**
         * Change in the state of the editor for the geo object's geometry.
         */
        this.editorstatechange = this._eventManager.getLazyEmitter('editorstatechange');
        /**
         * Change to the geo object geometry
         */
        this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');
        /**
         * Closing the hint.
         */
        this.hintclose = this._eventManager.getLazyEmitter('hintclose');
        /**
         * Opening a hint on a map.
         */
        this.hintopen = this._eventManager.getLazyEmitter('hintopen');
        /**
         * Map reference changed.
         */
        this.mapchange = this._eventManager.getLazyEmitter('mapchange');
        /**
         * Pressing the mouse button over the object.
         */
        this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
        /**
         * Pointing the cursor at the object.
         */
        this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
        /**
         * Moving the cursor off of the object.
         */
        this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
        /**
         * Moving the cursor over the object.
         */
        this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
        /**
         * Letting go of the mouse button over an object.
         */
        this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
        /**
         * End of multitouch.
         */
        this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
        /**
         * Repeating event during multitouch.
         */
        this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
        /**
         * Start of multitouch.
         */
        this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
        /**
         * Change to the object options.
         */
        this.optionschange = this._eventManager.getLazyEmitter('optionschange');
        /**
         * Change to the geo object overlay.
         */
        this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');
        /**
         * The parent object reference changed.
         */
        this.parentchange = this._eventManager.getLazyEmitter('parentchange');
        /**
         * Change to the geo object data.
         */
        this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');
        /**
         * Mouse wheel scrolling.
         */
        this.yawheel = this._eventManager.getLazyEmitter('wheel');
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        var _a;
        const { placemark } = this;
        if (placemark) {
            const { geometry, properties, options } = changes;
            if (geometry) {
                (_a = placemark.geometry) === null || _a === void 0 ? void 0 : _a.setCoordinates(geometry.currentValue);
            }
            if (properties) {
                placemark.properties.set(properties.currentValue);
            }
            if (options) {
                placemark.options.set(options.currentValue);
            }
        }
    }
    ngOnInit() {
        if (this._yaMapComponent.isBrowser) {
            const sub = this._yaMapComponent.map$.subscribe((map) => {
                if (map) {
                    const placemark = this._createPlacemark();
                    this.placemark = placemark;
                    map.geoObjects.add(placemark);
                    this._eventManager.setTarget(placemark);
                    this._ngZone.run(() => this.ready.emit({ ymaps, target: placemark }));
                }
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        var _a, _b;
        if (this.placemark) {
            (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this.placemark);
            this._eventManager.destroy();
        }
        this._sub.unsubscribe();
    }
    /**
     * Creates a placemark.
     */
    _createPlacemark() {
        return new ymaps.Placemark(this.geometry, this.properties, this.options);
    }
}
YaPlacemarkDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ya-placemark',
            },] }
];
YaPlacemarkDirective.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaPlacemarkDirective.propDecorators = {
    geometry: [{ type: Input }],
    properties: [{ type: Input }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    balloonclose: [{ type: Output }],
    balloonopen: [{ type: Output }],
    beforedrag: [{ type: Output }],
    beforedragstart: [{ type: Output }],
    yaclick: [{ type: Output }],
    yacontextmenu: [{ type: Output }],
    yadblclick: [{ type: Output }],
    yadrag: [{ type: Output }],
    yadragend: [{ type: Output }],
    yadragstart: [{ type: Output }],
    editorstatechange: [{ type: Output }],
    geometrychange: [{ type: Output }],
    hintclose: [{ type: Output }],
    hintopen: [{ type: Output }],
    mapchange: [{ type: Output }],
    yamousedown: [{ type: Output }],
    yamouseenter: [{ type: Output }],
    yamouseleave: [{ type: Output }],
    yamousemove: [{ type: Output }],
    yamouseup: [{ type: Output }],
    multitouchend: [{ type: Output }],
    multitouchmove: [{ type: Output }],
    multitouchstart: [{ type: Output }],
    optionschange: [{ type: Output }],
    overlaychange: [{ type: Output }],
    parentchange: [{ type: Output }],
    propertieschange: [{ type: Output }],
    yawheel: [{ type: Output }]
};

/**
 * The `ya-clusterer` component wraps `ymaps.Clusterer` class from the Yandex Maps API.
 * You can configure it via the component's inputs.
 * Events can be bound using the outputs of the component.
 *
 * <example-url>https://stackblitz.com/edit/placemark-clusterer?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map [center]="[55.761952, 37.620739]">
 *   <ya-clusterer [options]="{ minClusterSize: 5 }">
 *     <ya-placemark [geometry]="[55.74, 37.5]"></ya-placemark>
 *     <ya-placemark [geometry]="[55.64, 37.46]"></ya-placemark>
 *     <ya-placemark [geometry]="[55.75, 37.38]"></ya-placemark>
 *
 *     <ya-geoobject
 *       [feature]="{ geometry: { type: 'Point', coordinates: [55.81, 37.4] } }"
 *      ></ya-geoobject>
 *
 *     <ya-geoobject
 *       [feature]="{ geometry: { type: 'Point', coordinates: [55.7, 37.39] } }"
 *      ></ya-geoobject>
 *   </ya-clusterer>
 * </ya-map>
 * ```
 */
class YaClustererComponent {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        /**
         * Clusterer instance is added in a Map.
         */
        this.ready = new EventEmitter();
        /**
         * Closing the hint.
         */
        this.hintclose = this._eventManager.getLazyEmitter('hintclose');
        /**
         * Opening a hint on a map.
         */
        this.hintopen = this._eventManager.getLazyEmitter('hintopen');
        /**
         * Map reference changed.
         */
        this.mapchange = this._eventManager.getLazyEmitter('mapchange');
        /**
         * Change to the object options.
         */
        this.optionschange = this._eventManager.getLazyEmitter('optionschange');
        /**
         * The parent object reference changed.
         */
        this.parentchange = this._eventManager.getLazyEmitter('parentchange');
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        const clusterer = this._clusterer;
        if (clusterer) {
            const { options } = changes;
            if (options) {
                clusterer.options.set(options.currentValue);
            }
        }
    }
    ngAfterContentInit() {
        if (this._yaMapComponent.isBrowser) {
            const sub = this._yaMapComponent.map$.subscribe((map) => {
                if (map) {
                    const clusterer = this._createClusterer();
                    this._clusterer = clusterer;
                    map.geoObjects.add(clusterer);
                    this._eventManager.setTarget(clusterer);
                    this._watchForContentChanges(clusterer);
                    this._ngZone.run(() => this.ready.emit({ ymaps, target: clusterer }));
                }
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        this._eventManager.destroy();
        this._sub.unsubscribe();
    }
    /**
     * Creates Clusterer.
     */
    _createClusterer() {
        return new ymaps.Clusterer(this.options);
    }
    _watchForContentChanges(clusterer) {
        /**
         * Adds new Placemarks to the clusterer on changes.
         */
        const currentPlacemarks = new Set();
        this._getInternalPlacemarks(this._placemarks.toArray()).forEach((placemark) => {
            currentPlacemarks.add(placemark);
            clusterer.add(placemark);
        });
        const placemarksSub = this._placemarks.changes.subscribe((placemarkDirectives) => {
            const newPlacemarks = new Set(this._getInternalPlacemarks(placemarkDirectives));
            const difference = this._getDifference(newPlacemarks, currentPlacemarks);
            clusterer.add(difference.toAdd);
            clusterer.remove(difference.toRemove);
        });
        this._sub.add(placemarksSub);
        /**
         * Adds new GeoObjects to the clusterer on changes.
         */
        const currentGeoObjects = new Set();
        this._getInternalGeoObjects(this._geoObjects.toArray()).forEach((geoObject) => {
            currentGeoObjects.add(geoObject);
            clusterer.add(geoObject);
        });
        const geoObjectsSub = this._geoObjects.changes.subscribe((geoObjectDirectives) => {
            const newGeoObjects = new Set(this._getInternalGeoObjects(geoObjectDirectives));
            const difference = this._getDifference(newGeoObjects, currentGeoObjects);
            clusterer.add(difference.toAdd);
            clusterer.remove(difference.toRemove);
        });
        this._sub.add(geoObjectsSub);
    }
    /**
     * Determines what should be added/removed in current set to equal new set
     *
     * @param newSet
     * @param currentSet
     */
    _getDifference(newSet, currentSet) {
        const toAdd = [];
        const toRemove = [];
        newSet.forEach((component) => {
            if (!currentSet.has(component)) {
                toAdd.push(component);
                currentSet.add(component);
            }
        });
        currentSet.forEach((component) => {
            if (!newSet.has(component)) {
                toRemove.push(component);
                currentSet.delete(component);
            }
        });
        return {
            toAdd,
            toRemove,
        };
    }
    _getInternalPlacemarks(placemarks) {
        return placemarks
            .filter((component) => !!component.placemark)
            .map((component) => component.placemark);
    }
    _getInternalGeoObjects(geoObjects) {
        return geoObjects
            .filter((component) => !!component.geoObject)
            .map((component) => component.geoObject);
    }
}
YaClustererComponent.decorators = [
    { type: Component, args: [{
                selector: 'ya-clusterer',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
YaClustererComponent.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaClustererComponent.propDecorators = {
    _placemarks: [{ type: ContentChildren, args: [YaPlacemarkDirective,] }],
    _geoObjects: [{ type: ContentChildren, args: [YaGeoObjectDirective,] }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    hintclose: [{ type: Output }],
    hintopen: [{ type: Output }],
    mapchange: [{ type: Output }],
    optionschange: [{ type: Output }],
    parentchange: [{ type: Output }]
};

/**
 * The `ya-control` component wraps `ymaps.control[YaControlType]` classes from the Yandex Maps API.
 * You can configure `ymaps.control[YaControlType]` via the component's inputs.
 * API Events can be bound only manually. You can use `ready` event to get an instance.
 *
 * <example-url>https://stackblitz.com/edit/searchcontrol?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map [center]="[55.761952, 37.620739]">
 *   <ya-control
 *     type="RoutePanel"
 *     [parameters]="{ options: { float: 'right' } }"
 *   ></ya-control>
 * </ya-map>
 * ```
 */
class YaControlDirective {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        /**
         * Control instance is added in a Map.
         */
        this.ready = new EventEmitter();
    }
    ngOnChanges() {
        if (this._control) {
            console.warn('Control does not support dynamic configuration. You can config it manually using ymaps or recreate the component with new configuration');
        }
    }
    ngOnInit() {
        if (this._yaMapComponent.isBrowser) {
            const sub = this._yaMapComponent.map$.subscribe((map) => {
                if (map) {
                    const control = new ymaps.control[this.type](this.parameters);
                    this._control = control;
                    /**
                     * RoutePanel ignores state in parameters. API bug
                     */
                    if (control instanceof ymaps.control.RoutePanel &&
                        this.parameters &&
                        this.parameters.state) {
                        control.routePanel.state.set(Object.assign({}, this.parameters.state));
                    }
                    map.controls.add(control);
                    this._ngZone.run(() => this.ready.emit({ ymaps, target: control }));
                }
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        var _a, _b;
        if (this._control) {
            (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.controls.remove(this._control);
        }
    }
}
YaControlDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ya-control',
            },] }
];
YaControlDirective.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaControlDirective.propDecorators = {
    type: [{ type: Input }],
    parameters: [{ type: Input }],
    ready: [{ type: Output }]
};

/**
 * The `ya-multiroute` component wraps `ymaps.multiRouter.MultiRoute` class from the Yandex Maps API.
 * You can configure it via the component's inputs.
 * Events can be bound using the outputs of the component.
 *
 * <example-url>https://stackblitz.com/edit/multiroute-pedestrian?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map [center]="[55.761952, 37.620739]">
 *   <ya-multiroute
 *     [referencePoints]="[[55.751952, 37.600739], 'Красные ворота, Москва']"
 *     [model]="{ params: { routingMode: 'pedestrian' } }"
 *   ></ya-multiroute>
 * </ya-map>
 * ```
 */
class YaMultirouteDirective {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        /**
         * Multiroute instance is added in a Map.
         */
        this.ready = new EventEmitter();
        /**
         * Change to the active route.
         */
        this.activeroutechange = this._eventManager.getLazyEmitter('activeroutechange');
        /**
         * Closing the balloon.
         */
        this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');
        /**
         * Opening a balloon on a map.
         */
        this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');
        /**
         * The event occurs at the time of setting the map center and its zoom level for optimal display of the multi-route.
         */
        this.boundsautoapply = this._eventManager.getLazyEmitter('boundsautoapply');
        /**
         * Changing coordinates of the geographical area covering the multi-route.
         */
        this.boundschange = this._eventManager.getLazyEmitter('boundschange');
        /**
         * Single left-click on the object.
         */
        this.yaclick = this._eventManager.getLazyEmitter('click');
        /**
         * Calls the element's context menu.
         */
        this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');
        /**
         * Double left-click on the object.
         */
        this.yadblclick = this._eventManager.getLazyEmitter('dblclick');
        /**
         * Change to the geo object geometry.
         */
        this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');
        /**
         * Map reference changed.
         */
        this.mapchange = this._eventManager.getLazyEmitter('mapchange');
        /**
         * Pressing the mouse button over the object.
         */
        this.yamousedown = this._eventManager.getLazyEmitter('mousedown');
        /**
         * Pointing the cursor at the object.
         */
        this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');
        /**
         * Moving the cursor off of the object.
         */
        this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');
        /**
         * Moving the cursor over the object.
         */
        this.yamousemove = this._eventManager.getLazyEmitter('mousemove');
        /**
         * Letting go of the mouse button over an object.
         */
        this.yamouseup = this._eventManager.getLazyEmitter('mouseup');
        /**
         * End of multitouch.
         */
        this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');
        /**
         * Repeating event during multitouch.
         */
        this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');
        /**
         * Start of multitouch.
         */
        this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');
        /**
         * Change to the object options.
         */
        this.optionschange = this._eventManager.getLazyEmitter('optionschange');
        /**
         * Change to the geo object overlay.
         */
        this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');
        /**
         * The parent object reference changed.
         */
        this.parentchange = this._eventManager.getLazyEmitter('parentchange');
        /**
         * Changing pixel coordinates of the area covering the multi-route.
         */
        this.pixelboundschange = this._eventManager.getLazyEmitter('pixelboundschange');
        /**
         * Change to the geo object data.
         */
        this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');
        /**
         * Updating the multi-route.
         */
        this.update = this._eventManager.getLazyEmitter('update');
        /**
         * Mouse wheel scrolling.
         */
        this.yawheel = this._eventManager.getLazyEmitter('wheel');
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        const multiroute = this._multiroute;
        if (multiroute) {
            const { referencePoints, model, options } = changes;
            if (model) {
                this._setModel(model.currentValue, multiroute);
            }
            if (referencePoints) {
                multiroute.model.setReferencePoints(referencePoints.currentValue);
            }
            if (options) {
                multiroute.options.set(options.currentValue);
            }
        }
    }
    ngOnInit() {
        if (this._yaMapComponent.isBrowser) {
            const sub = this._yaMapComponent.map$.subscribe((map) => {
                if (map) {
                    const multiroute = this._createMultiroute();
                    this._multiroute = multiroute;
                    map.geoObjects.add(multiroute);
                    this._eventManager.setTarget(multiroute);
                    this._ngZone.run(() => this.ready.emit({ ymaps, target: multiroute }));
                }
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        var _a, _b;
        if (this._multiroute) {
            (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this._multiroute);
            this._eventManager.destroy();
        }
        this._sub.unsubscribe();
    }
    /**
     * Destructs state and passes them in API.
     * @param model
     * @param multiroute
     */
    _setModel(model, multiroute) {
        const { referencePoints, params } = model;
        if (referencePoints) {
            multiroute.model.setReferencePoints(referencePoints);
        }
        if (params) {
            multiroute.model.setParams(params);
        }
    }
    /**
     * Creates Multiroute.
     */
    _createMultiroute() {
        return new ymaps.multiRouter.MultiRoute(this._combineModel(), this.options);
    }
    /**
     * Combines the model and reference points into single object
     */
    _combineModel() {
        const model = (this.model || {});
        return Object.assign(Object.assign({}, model), { referencePoints: this.referencePoints || model.referencePoints });
    }
}
YaMultirouteDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ya-multiroute',
            },] }
];
YaMultirouteDirective.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaMultirouteDirective.propDecorators = {
    referencePoints: [{ type: Input }],
    model: [{ type: Input }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    activeroutechange: [{ type: Output }],
    balloonclose: [{ type: Output }],
    balloonopen: [{ type: Output }],
    boundsautoapply: [{ type: Output }],
    boundschange: [{ type: Output }],
    yaclick: [{ type: Output }],
    yacontextmenu: [{ type: Output }],
    yadblclick: [{ type: Output }],
    geometrychange: [{ type: Output }],
    mapchange: [{ type: Output }],
    yamousedown: [{ type: Output }],
    yamouseenter: [{ type: Output }],
    yamouseleave: [{ type: Output }],
    yamousemove: [{ type: Output }],
    yamouseup: [{ type: Output }],
    multitouchend: [{ type: Output }],
    multitouchmove: [{ type: Output }],
    multitouchstart: [{ type: Output }],
    optionschange: [{ type: Output }],
    overlaychange: [{ type: Output }],
    parentchange: [{ type: Output }],
    pixelboundschange: [{ type: Output }],
    propertieschange: [{ type: Output }],
    update: [{ type: Output }],
    yawheel: [{ type: Output }]
};

/**
 * The `ya-panorama` component wraps `ymaps.panorama.Player` class from the Yandex Maps API.
 * You can configure it via the component's inputs.
 * Events can be bound using the outputs of the component.
 *
 * <example-url>https://stackblitz.com/edit/panorama?embed=1</example-url>
 *
 * @example
 * ```html
 * <ya-map>
 *   <ya-panorama [point]="[59.938557, 30.316198]" layer="yandex#airPanorama"></ya-panorama>
 * </ya-map>
 * ```
 */
class YaPanoramaDirective {
    constructor(_ngZone, _yaMapComponent) {
        this._ngZone = _ngZone;
        this._yaMapComponent = _yaMapComponent;
        this._sub = new Subscription();
        this._eventManager = new EventManager(this._ngZone);
        /**
         * Panorama instance is created.
         */
        this.ready = new EventEmitter();
        /**
         * The player was closed by the user or destroyed using the panorama.Player.destroy method.
         */
        this.destroy = this._eventManager.getLazyEmitter('destroy');
        /**
         * The view direction changed.
         */
        this.directionchange = this._eventManager.getLazyEmitter('directionchange');
        /**
         * An error occurred during operation of the player. The user will be shown the appropriate screen.
         */
        this.yaerror = this._eventManager.getLazyEmitter('error');
        /**
         * The panorama player switched to full-screen mode.
         */
        this.fullscreenenter = this._eventManager.getLazyEmitter('fullscreenenter');
        /**
         * The panorama player exited full-screen mode.
         */
        this.fullscreenexit = this._eventManager.getLazyEmitter('fullscreenexit');
        /**
         * The user clicked on an expanded marker.
         */
        this.markercollapse = this._eventManager.getLazyEmitter('markercollapse');
        /**
         * The user clicked on a collapsed marker.
         */
        this.markerexpand = this._eventManager.getLazyEmitter('markerexpand');
        /**
         * The user's cursor hovered over a marker.
         */
        this.markermouseenter = this._eventManager.getLazyEmitter('markermouseenter');
        /**
         * The user's cursor left a marker.
         */
        this.markermouseleave = this._eventManager.getLazyEmitter('markermouseleave');
        /**
         * The open panorama changed.
         */
        this.panoramachange = this._eventManager.getLazyEmitter('panoramachange');
        /**
         * The size of the viewport has been changed.
         */
        this.spanchange = this._eventManager.getLazyEmitter('spanchange');
    }
    /**
     * Handles input changes and passes them in API.
     * @param changes
     */
    ngOnChanges(changes) {
        const player = this._player;
        if (player) {
            const { point, layer, options } = changes;
            /**
             * player.moveTo resets values to default if any of them isn't passed.
             * That's why we use value from currentValue OR previous value from input.
             * With that logic it's possible to pass only point, layer or options.
             */
            if (point || layer) {
                const combinedPoint = (point === null || point === void 0 ? void 0 : point.currentValue) || this.point;
                const combinedLayer = (layer === null || layer === void 0 ? void 0 : layer.currentValue) || this.layer;
                player.moveTo(combinedPoint, { layer: combinedLayer });
            }
            if (options) {
                this._setOptions(options.currentValue, player);
            }
        }
    }
    ngOnInit() {
        if (this._yaMapComponent.isBrowser) {
            const panorama$ = this._yaMapComponent.map$.pipe(filter((m) => Boolean(m)), switchMap((m) => {
                /**
                 * Map and panorama use the same container, so need to destroy/remove map
                 */
                m.destroy();
                return this._createPanorama();
            }));
            const sub = panorama$.subscribe((panorama) => {
                const { id } = this._yaMapComponent.container.nativeElement;
                const player = new ymaps.panorama.Player(id, panorama, this.options);
                this._player = player;
                this._eventManager.setTarget(player);
                this._ngZone.run(() => this.ready.emit({ ymaps, target: player }));
            });
            this._sub.add(sub);
        }
    }
    ngOnDestroy() {
        this._eventManager.destroy();
        this._sub.unsubscribe();
    }
    /**
     * Destructs state and passes it in API.
     * @param options
     * @param player
     */
    _setOptions(options, player) {
        const { autoFitToViewport, controls, direction, hotkeysEnabled, span, scrollZoomBehavior, suppressMapOpenBlock, } = options;
        if (autoFitToViewport ||
            controls ||
            hotkeysEnabled ||
            scrollZoomBehavior ||
            suppressMapOpenBlock) {
            console.warn('Only direction and span can be set after entity init. To set other options, you should recreate a Panorama with new options');
        }
        if (direction) {
            player.setDirection(direction);
        }
        if (span) {
            player.setSpan(span);
        }
    }
    /**
     * Searches for a panorama and returns first
     */
    _createPanorama() {
        return from(ymaps.panorama.locate(this.point, { layer: this.layer })).pipe(map((panoramas) => panoramas[0]));
    }
}
YaPanoramaDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ya-panorama',
            },] }
];
YaPanoramaDirective.ctorParameters = () => [
    { type: NgZone },
    { type: YaMapComponent }
];
YaPanoramaDirective.propDecorators = {
    point: [{ type: Input }],
    layer: [{ type: Input }],
    options: [{ type: Input }],
    ready: [{ type: Output }],
    destroy: [{ type: Output }],
    directionchange: [{ type: Output }],
    yaerror: [{ type: Output }],
    fullscreenenter: [{ type: Output }],
    fullscreenexit: [{ type: Output }],
    markercollapse: [{ type: Output }],
    markerexpand: [{ type: Output }],
    markermouseenter: [{ type: Output }],
    markermouseleave: [{ type: Output }],
    panoramachange: [{ type: Output }],
    spanchange: [{ type: Output }]
};

class AngularYandexMapsModule {
    /**
     * Please use this method when you register the module at the root level
     * @param config
     */
    static forRoot(config) {
        return {
            ngModule: AngularYandexMapsModule,
            providers: [{ provide: YA_CONFIG, useValue: config }],
        };
    }
}
AngularYandexMapsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    YaClustererComponent,
                    YaControlDirective,
                    YaGeoObjectDirective,
                    YaMapComponent,
                    YaMultirouteDirective,
                    YaPanoramaDirective,
                    YaPlacemarkDirective,
                ],
                imports: [CommonModule],
                exports: [
                    YaClustererComponent,
                    YaControlDirective,
                    YaGeoObjectDirective,
                    YaMapComponent,
                    YaMultirouteDirective,
                    YaPanoramaDirective,
                    YaPlacemarkDirective,
                ],
            },] }
];

/**
 * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex Maps API.
 *
 * @example
 * ```ts
 * import { YaGeocoderService } from 'angular8-yandex-maps';
 *
 * export class AppComponent {
 *   constructor(private yaGeocoderService: YaGeocoderService) {
 *     this.yaGeocoderService.geocode('Moscow')
 *       .subscribe(v => console.log(v))
 *   }
 * }
 * ```
 */
class YaGeocoderService {
    constructor(_ngZone, _yaApiLoaderService) {
        this._ngZone = _ngZone;
        this._yaApiLoaderService = _yaApiLoaderService;
    }
    /**
     * Processes geocoding requests
     * @param request
     * @param options
     */
    geocode(request, options) {
        return this._yaApiLoaderService.load().pipe(switchMap(() => from(ymaps.geocode(request, options))), switchMap((result) => new Observable((observer) => {
            this._ngZone.run(() => {
                observer.next(result);
                observer.complete();
            });
        })));
    }
}
YaGeocoderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function YaGeocoderService_Factory() { return new YaGeocoderService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(YaApiLoaderService)); }, token: YaGeocoderService, providedIn: "root" });
YaGeocoderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
YaGeocoderService.ctorParameters = () => [
    { type: NgZone },
    { type: YaApiLoaderService }
];

/// <reference path="./lib/typings/yandex-maps/index.ts" />

/**
 * Generated bundle index. Do not edit.
 */

export { AngularYandexMapsModule, YA_CONFIG, YaApiLoaderService, YaClustererComponent, YaControlDirective, YaGeoObjectDirective, YaGeocoderService, YaMapComponent, YaMultirouteDirective, YaPanoramaDirective, YaPlacemarkDirective };
//# sourceMappingURL=angular8-yandex-maps.js.map
