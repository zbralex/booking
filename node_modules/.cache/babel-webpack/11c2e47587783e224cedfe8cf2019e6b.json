{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for the\n * PhantomJS web browser. By default, it is expected that the PhantomJS\n * executable can be located on your\n * [PATH](https://en.wikipedia.org/wiki/PATH_(variable))\n *\n *  __Using a Custom PhantomJS Binary__\n *\n * If you have PhantomJS.exe placed somewhere other than the root of your\n * working directory, you can build a custom Capability and attach the\n * executable's location to the Capability\n *\n * For example, if you're using the\n * [phantomjs-prebuilt](https://www.npmjs.com/package/phantomjs-prebuilt) module\n * from npm:\n *\n *     //setup custom phantomJS capability\n *     var phantomjs_exe = require('phantomjs-prebuilt').path;\n *     var customPhantom = selenium.Capabilities.phantomjs();\n *     customPhantom.set(\"phantomjs.binary.path\", phantomjs_exe);\n *     //build custom phantomJS driver\n *     var driver = new selenium.Builder().\n *            withCapabilities(customPhantom).\n *            build();\n *\n */\n'use strict';\n\nconst fs = require('fs');\n\nconst http = require('./http'),\n      io = require('./io'),\n      capabilities = require('./lib/capabilities'),\n      command = require('./lib/command'),\n      logging = require('./lib/logging'),\n      promise = require('./lib/promise'),\n      webdriver = require('./lib/webdriver'),\n      portprober = require('./net/portprober'),\n      remote = require('./remote');\n/**\n * Name of the PhantomJS executable.\n * @type {string}\n * @const\n */\n\n\nconst PHANTOMJS_EXE = process.platform === 'win32' ? 'phantomjs.exe' : 'phantomjs';\n/**\n * Capability that designates the location of the PhantomJS executable to use.\n * @type {string}\n * @const\n */\n\nconst BINARY_PATH_CAPABILITY = 'phantomjs.binary.path';\n/**\n * Capability that designates the CLI arguments to pass to PhantomJS.\n * @type {string}\n * @const\n */\n\nconst CLI_ARGS_CAPABILITY = 'phantomjs.cli.args';\n/**\n * Custom command names supported by PhantomJS.\n * @enum {string}\n */\n\nconst Command = {\n  EXECUTE_PHANTOM_SCRIPT: 'executePhantomScript'\n};\n/**\n * Finds the PhantomJS executable.\n * @param {string=} opt_exe Path to the executable to use.\n * @return {string} The located executable.\n * @throws {Error} If the executable cannot be found on the PATH, or if the\n *     provided executable path does not exist.\n */\n\nfunction findExecutable(opt_exe) {\n  var exe = opt_exe || io.findInPath(PHANTOMJS_EXE, true);\n\n  if (!exe) {\n    throw Error('The PhantomJS executable could not be found on the current PATH. ' + 'Please download the latest version from ' + 'http://phantomjs.org/download.html and ensure it can be found on ' + 'your PATH. For more information, see ' + 'https://github.com/ariya/phantomjs/wiki');\n  }\n\n  if (!fs.existsSync(exe)) {\n    throw Error('File does not exist: ' + exe);\n  }\n\n  return exe;\n}\n/**\n * Maps WebDriver logging level name to those recognised by PhantomJS.\n * @const {!Map<string, string>}\n */\n\n\nconst WEBDRIVER_TO_PHANTOMJS_LEVEL = new Map([[logging.Level.ALL.name, 'DEBUG'], [logging.Level.DEBUG.name, 'DEBUG'], [logging.Level.INFO.name, 'INFO'], [logging.Level.WARNING.name, 'WARN'], [logging.Level.SEVERE.name, 'ERROR']]);\n/**\n * Creates a command executor with support for PhantomJS' custom commands.\n * @param {!Promise<string>} url The server's URL.\n * @return {!command.Executor} The new command executor.\n */\n\nfunction createExecutor(url) {\n  let client = url.then(url => new http.HttpClient(url));\n  let executor = new http.Executor(client);\n  executor.defineCommand(Command.EXECUTE_PHANTOM_SCRIPT, 'POST', '/session/:sessionId/phantom/execute');\n  return executor;\n}\n/**\n * Creates a new WebDriver client for PhantomJS.\n */\n\n\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new PhantomJS session.\n   *\n   * @param {capabilities.Capabilities=} opt_capabilities The desired\n   *     capabilities.\n   * @param {promise.ControlFlow=} opt_flow The control flow to use,\n   *     or {@code null} to use the currently active flow.\n   * @param {string=} opt_logFile Path to the log file for the phantomjs\n   *     executable's output. For convenience, this may be set at runtime with\n   *     the `SELENIUM_PHANTOMJS_LOG` environment variable.\n   * @return {!Driver} A new driver reference.\n   */\n  static createSession(opt_capabilities, opt_flow, opt_logFile) {\n    // TODO: add an Options class for consistency with the other driver types.\n    var caps = opt_capabilities || capabilities.Capabilities.phantomjs();\n    var exe = findExecutable(caps.get(BINARY_PATH_CAPABILITY));\n    var args = [];\n    var logPrefs = caps.get(capabilities.Capability.LOGGING_PREFS);\n\n    if (logPrefs instanceof logging.Preferences) {\n      logPrefs = logPrefs.toJSON();\n    }\n\n    if (logPrefs && logPrefs[logging.Type.DRIVER]) {\n      let level = WEBDRIVER_TO_PHANTOMJS_LEVEL.get(logPrefs[logging.Type.DRIVER]);\n\n      if (level) {\n        args.push('--webdriver-loglevel=' + level);\n      }\n    }\n\n    opt_logFile = process.env['SELENIUM_PHANTOMJS_LOG'] || opt_logFile;\n\n    if (typeof opt_logFile === 'string') {\n      args.push('--webdriver-logfile=' + opt_logFile);\n    }\n\n    var proxy = caps.get(capabilities.Capability.PROXY);\n\n    if (proxy) {\n      switch (proxy.proxyType) {\n        case 'manual':\n          if (proxy.httpProxy) {\n            args.push('--proxy-type=http', '--proxy=' + proxy.httpProxy);\n            console.log(args);\n          }\n\n          break;\n\n        case 'pac':\n          throw Error('PhantomJS does not support Proxy PAC files');\n\n        case 'system':\n          args.push('--proxy-type=system');\n          break;\n\n        case 'direct':\n          args.push('--proxy-type=none');\n          break;\n      }\n    }\n\n    args = args.concat(caps.get(CLI_ARGS_CAPABILITY) || []);\n    var port = portprober.findFreePort();\n    var service = new remote.DriverService(exe, {\n      port: port,\n      args: Promise.resolve(port).then(function (port) {\n        args.push('--webdriver=' + port);\n        return args;\n      })\n    });\n    var executor = createExecutor(service.start());\n    return super.createSession(executor, caps, opt_flow, () => service.kill());\n  }\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n\n\n  setFileDetector() {}\n  /**\n   * Executes a PhantomJS fragment. This method is similar to\n   * {@link #executeScript}, except it exposes the\n   * <a href=\"http://phantomjs.org/api/\">PhantomJS API</a> to the injected\n   * script.\n   *\n   * <p>The injected script will execute in the context of PhantomJS's\n   * {@code page} variable. If a page has not been loaded before calling this\n   * method, one will be created.</p>\n   *\n   * <p>Be sure to wrap callback definitions in a try/catch block, as failures\n   * may cause future WebDriver calls to fail.</p>\n   *\n   * <p>Certain callbacks are used by GhostDriver (the PhantomJS WebDriver\n   * implementation) and overriding these may cause the script to fail. It is\n   * recommended that you check for existing callbacks before defining your own.\n   * </p>\n   *\n   * As with {@link #executeScript}, the injected script may be defined as\n   * a string for an anonymous function body (e.g. \"return 123;\"), or as a\n   * function. If a function is provided, it will be decompiled to its original\n   * source. Note that injecting functions is provided as a convenience to\n   * simplify defining complex scripts. Care must be taken that the function\n   * only references variables that will be defined in the page's scope and\n   * that the function does not override {@code Function.prototype.toString}\n   * (overriding toString() will interfere with how the function is\n   * decompiled.\n   *\n   * @param {(string|!Function)} script The script to execute.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @return {!promise.Thenable<T>} A promise that resolve to the\n   *     script's return value.\n   * @template T\n   */\n\n\n  executePhantomJS(script, var_args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(this, arguments);';\n    }\n\n    var args = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : [];\n    return this.schedule(new command.Command(Command.EXECUTE_PHANTOM_SCRIPT).setParameter('script', script).setParameter('args', args), 'Driver.executePhantomJS()');\n  }\n\n} // PUBLIC API\n\n\nexports.Driver = Driver;","map":null,"metadata":{},"sourceType":"script"}