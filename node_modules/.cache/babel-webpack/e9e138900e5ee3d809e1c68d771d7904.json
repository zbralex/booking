{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n *  This is a base driver provider class.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\n\nconst q = require(\"q\");\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst bpRunner_1 = require(\"../bpRunner\");\n\nclass DriverProvider {\n  constructor(config) {\n    this.config_ = config;\n    this.drivers_ = [];\n    this.bpRunner = new bpRunner_1.BlockingProxyRunner(config);\n  }\n  /**\n   * Get all existing drivers.\n   *\n   * @public\n   * @return array of webdriver instances\n   */\n\n\n  getExistingDrivers() {\n    return this.drivers_.slice(); // Create a shallow copy\n  }\n\n  getBPUrl() {\n    if (this.config_.blockingProxyUrl) {\n      return this.config_.blockingProxyUrl;\n    }\n\n    return `http://localhost:${this.bpRunner.port}`;\n  }\n  /**\n   * Create a new driver.\n   *\n   * @public\n   * @return webdriver instance\n   */\n\n\n  getNewDriver() {\n    let builder;\n\n    if (this.config_.useBlockingProxy) {\n      builder = new selenium_webdriver_1.Builder().usingServer(this.getBPUrl()).withCapabilities(this.config_.capabilities);\n    } else {\n      builder = new selenium_webdriver_1.Builder().usingServer(this.config_.seleniumAddress).usingWebDriverProxy(this.config_.webDriverProxy).withCapabilities(this.config_.capabilities);\n    }\n\n    if (this.config_.disableEnvironmentOverrides === true) {\n      builder.disableEnvironmentOverrides();\n    }\n\n    let newDriver = builder.build();\n    this.drivers_.push(newDriver);\n    return newDriver;\n  }\n  /**\n   * Quit a driver.\n   *\n   * @public\n   * @param webdriver instance\n   */\n\n\n  quitDriver(driver) {\n    let driverIndex = this.drivers_.indexOf(driver);\n\n    if (driverIndex >= 0) {\n      this.drivers_.splice(driverIndex, 1);\n    }\n\n    if (driver.getSession() === undefined) {\n      return selenium_webdriver_1.promise.when(undefined);\n    } else {\n      return driver.getSession().then(session_ => {\n        if (session_) {\n          return driver.quit();\n        }\n      }).catch(function (err) {});\n    }\n  }\n  /**\n   * Quits an array of drivers and returns a q promise instead of a webdriver one\n   *\n   * @param drivers {webdriver.WebDriver[]} The webdriver instances\n   */\n\n\n  static quitDrivers(provider, drivers) {\n    let deferred = q.defer();\n    selenium_webdriver_1.promise.all(drivers.map(driver => {\n      return provider.quitDriver(driver);\n    })).then(() => {\n      deferred.resolve();\n    }, () => {\n      deferred.resolve();\n    });\n    return deferred.promise;\n  }\n  /**\n   * Default update job method.\n   * @return a promise\n   */\n\n\n  updateJob(update) {\n    return q.fcall(function () {});\n  }\n\n  /**\n   * Default setup environment method, common to all driver providers.\n   */\n  setupEnv() {\n    let driverPromise = this.setupDriverEnv();\n\n    if (this.config_.useBlockingProxy && !this.config_.blockingProxyUrl) {\n      // TODO(heathkit): If set, pass the webDriverProxy to BP.\n      return driverPromise.then(() => this.bpRunner.start());\n    }\n\n    return driverPromise;\n  }\n\n  /**\n   * Teardown and destroy the environment and do any associated cleanup.\n   * Shuts down the drivers.\n   *\n   * @public\n   * @return {q.Promise<any>} A promise which will resolve when the environment is down.\n   */\n  teardownEnv() {\n    return DriverProvider.quitDrivers(this, this.drivers_);\n  }\n\n}\n\nexports.DriverProvider = DriverProvider; //# sourceMappingURL=driverProvider.js.map","map":null,"metadata":{},"sourceType":"script"}