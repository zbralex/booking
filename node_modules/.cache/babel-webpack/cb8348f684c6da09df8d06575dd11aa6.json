{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The main user facing module. Exports WebDriver's primary\n * public API and provides convenience assessors to certain sub-modules.\n */\n'use strict';\n\nconst chrome = require('./chrome');\n\nconst edge = require('./edge');\n\nconst firefox = require('./firefox');\n\nconst _http = require('./http');\n\nconst ie = require('./ie');\n\nconst actions = require('./lib/actions');\n\nconst by = require('./lib/by');\n\nconst capabilities = require('./lib/capabilities');\n\nconst command = require('./lib/command');\n\nconst error = require('./lib/error');\n\nconst events = require('./lib/events');\n\nconst input = require('./lib/input');\n\nconst logging = require('./lib/logging');\n\nconst promise = require('./lib/promise');\n\nconst session = require('./lib/session');\n\nconst until = require('./lib/until');\n\nconst webdriver = require('./lib/webdriver');\n\nconst opera = require('./opera');\n\nconst phantomjs = require('./phantomjs');\n\nconst remote = require('./remote');\n\nconst safari = require('./safari');\n\nconst Browser = capabilities.Browser;\nconst Capabilities = capabilities.Capabilities;\nconst Capability = capabilities.Capability;\nconst Session = session.Session;\nconst WebDriver = webdriver.WebDriver;\nvar seleniumServer;\n/**\n * Starts an instance of the Selenium server if not yet running.\n * @param {string} jar Path to the server jar to use.\n * @return {!Promise<string>} A promise for the server's\n *     address once started.\n */\n\nfunction startSeleniumServer(jar) {\n  if (!seleniumServer) {\n    seleniumServer = new remote.SeleniumServer(jar);\n  }\n\n  return seleniumServer.start();\n}\n/**\n * {@linkplain webdriver.WebDriver#setFileDetector WebDriver's setFileDetector}\n * method uses a non-standard command to transfer files from the local client\n * to the remote end hosting the browser. Many of the WebDriver sub-types, like\n * the {@link chrome.Driver} and {@link firefox.Driver}, do not support this\n * command. Thus, these classes override the `setFileDetector` to no-op.\n *\n * This function uses a mixin to re-enable `setFileDetector` by calling the\n * original method on the WebDriver prototype directly. This is used only when\n * the builder creates a Chrome or Firefox instance that communicates with a\n * remote end (and thus, support for remote file detectors is unknown).\n *\n * @param {function(new: webdriver.WebDriver, ...?)} ctor\n * @return {function(new: webdriver.WebDriver, ...?)}\n */\n\n\nfunction ensureFileDetectorsAreEnabled(ctor) {\n  const mixin = class extends ctor {\n    /** @param {input.FileDetector} detector */\n    setFileDetector(detector) {\n      webdriver.WebDriver.prototype.setFileDetector.call(this, detector);\n    }\n\n  };\n  return mixin;\n}\n/**\n * A thenable wrapper around a {@linkplain webdriver.IWebDriver IWebDriver}\n * instance that allows commands to be issued directly instead of having to\n * repeatedly call `then`:\n *\n *     let driver = new Builder().build();\n *     driver.then(d => d.get(url));  // You can do this...\n *     driver.get(url);               // ...or this\n *\n * If the driver instance fails to resolve (e.g. the session cannot be created),\n * every issued command will fail.\n *\n * @extends {webdriver.IWebDriver}\n * @extends {promise.CancellableThenable<!webdriver.IWebDriver>}\n * @interface\n */\n\n\nclass ThenableWebDriver {\n  /** @param {...?} args */\n  static createSession(...args) {}\n\n}\n/**\n * @const {!Map<function(new: WebDriver, !IThenable<!Session>, ...?),\n *              function(new: ThenableWebDriver, !IThenable<!Session>, ...?)>}\n */\n\n\nconst THENABLE_DRIVERS = new Map();\n/**\n * @param {function(new: WebDriver, !IThenable<!Session>, ...?)} ctor\n * @param {...?} args\n * @return {!ThenableWebDriver}\n */\n\nfunction createDriver(ctor, ...args) {\n  let thenableWebDriverProxy = THENABLE_DRIVERS.get(ctor);\n\n  if (!thenableWebDriverProxy) {\n    /**\n     * @extends {WebDriver}  // Needed since `ctor` is dynamically typed.\n     * @implements {ThenableWebDriver}\n     */\n    thenableWebDriverProxy = class extends ctor {\n      /**\n       * @param {!IThenable<!Session>} session\n       * @param {...?} rest\n       */\n      constructor(session, ...rest) {\n        super(session, ...rest);\n        const pd = this.getSession().then(session => {\n          return new ctor(session, ...rest);\n        });\n        /**\n         * @param {(string|Error)=} opt_reason\n         * @override\n         */\n\n        this.cancel = function (opt_reason) {\n          if (promise.CancellableThenable.isImplementation(pd)) {\n            /** @type {!promise.CancellableThenable} */\n            pd.cancel(opt_reason);\n          }\n        };\n        /** @override */\n\n\n        this.then = pd.then.bind(pd);\n        /** @override */\n\n        this.catch = pd.then.bind(pd);\n      }\n\n    };\n    promise.CancellableThenable.addImplementation(thenableWebDriverProxy);\n    THENABLE_DRIVERS.set(ctor, thenableWebDriverProxy);\n  }\n\n  return thenableWebDriverProxy.createSession(...args);\n}\n/**\n * Creates new {@link webdriver.WebDriver WebDriver} instances. The environment\n * variables listed below may be used to override a builder's configuration,\n * allowing quick runtime changes.\n *\n * - {@code SELENIUM_BROWSER}: defines the target browser in the form\n *   {@code browser[:version][:platform]}.\n *\n * - {@code SELENIUM_REMOTE_URL}: defines the remote URL for all builder\n *   instances. This environment variable should be set to a fully qualified\n *   URL for a WebDriver server (e.g. http://localhost:4444/wd/hub). This\n *   option always takes precedence over {@code SELENIUM_SERVER_JAR}.\n *\n * - {@code SELENIUM_SERVER_JAR}: defines the path to the\n *   <a href=\"http://selenium-release.storage.googleapis.com/index.html\">\n *   standalone Selenium server</a> jar to use. The server will be started the\n *   first time a WebDriver instance and be killed when the process exits.\n *\n * Suppose you had mytest.js that created WebDriver with\n *\n *     var driver = new webdriver.Builder()\n *         .forBrowser('chrome')\n *         .build();\n *\n * This test could be made to use Firefox on the local machine by running with\n * `SELENIUM_BROWSER=firefox node mytest.js`. Rather than change the code to\n * target Google Chrome on a remote machine, you can simply set the\n * `SELENIUM_BROWSER` and `SELENIUM_REMOTE_URL` environment variables:\n *\n *     SELENIUM_BROWSER=chrome:36:LINUX \\\n *     SELENIUM_REMOTE_URL=http://www.example.com:4444/wd/hub \\\n *     node mytest.js\n *\n * You could also use a local copy of the standalone Selenium server:\n *\n *     SELENIUM_BROWSER=chrome:36:LINUX \\\n *     SELENIUM_SERVER_JAR=/path/to/selenium-server-standalone.jar \\\n *     node mytest.js\n */\n\n\nclass Builder {\n  constructor() {\n    /** @private @const */\n    this.log_ = logging.getLogger('webdriver.Builder');\n    /** @private {promise.ControlFlow} */\n\n    this.flow_ = null;\n    /** @private {string} */\n\n    this.url_ = '';\n    /** @private {?string} */\n\n    this.proxy_ = null;\n    /** @private {!Capabilities} */\n\n    this.capabilities_ = new Capabilities();\n    /** @private {chrome.Options} */\n\n    this.chromeOptions_ = null;\n    /** @private {firefox.Options} */\n\n    this.firefoxOptions_ = null;\n    /** @private {opera.Options} */\n\n    this.operaOptions_ = null;\n    /** @private {ie.Options} */\n\n    this.ieOptions_ = null;\n    /** @private {safari.Options} */\n\n    this.safariOptions_ = null;\n    /** @private {edge.Options} */\n\n    this.edgeOptions_ = null;\n    /** @private {boolean} */\n\n    this.ignoreEnv_ = false;\n    /** @private {http.Agent} */\n\n    this.agent_ = null;\n  }\n  /**\n   * Configures this builder to ignore any environment variable overrides and to\n   * only use the configuration specified through this instance's API.\n   *\n   * @return {!Builder} A self reference.\n   */\n\n\n  disableEnvironmentOverrides() {\n    this.ignoreEnv_ = true;\n    return this;\n  }\n  /**\n   * Sets the URL of a remote WebDriver server to use. Once a remote URL has\n   * been specified, the builder direct all new clients to that server. If this\n   * method is never called, the Builder will attempt to create all clients\n   * locally.\n   *\n   * As an alternative to this method, you may also set the\n   * `SELENIUM_REMOTE_URL` environment variable.\n   *\n   * @param {string} url The URL of a remote server to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  usingServer(url) {\n    this.url_ = url;\n    return this;\n  }\n  /**\n   * @return {string} The URL of the WebDriver server this instance is\n   *     configured to use.\n   */\n\n\n  getServerUrl() {\n    return this.url_;\n  }\n  /**\n   * Sets the URL of the proxy to use for the WebDriver's HTTP connections.\n   * If this method is never called, the Builder will create a connection\n   * without a proxy.\n   *\n   * @param {string} proxy The URL of a proxy to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  usingWebDriverProxy(proxy) {\n    this.proxy_ = proxy;\n    return this;\n  }\n  /**\n   * @return {?string} The URL of the proxy server to use for the WebDriver's\n   *    HTTP connections, or `null` if not set.\n   */\n\n\n  getWebDriverProxy() {\n    return this.proxy_;\n  }\n  /**\n   * Sets the http agent to use for each request.\n   * If this method is not called, the Builder will use http.globalAgent by default.\n   *\n   * @param {http.Agent} agent The agent to use for each request.\n   * @return {!Builder} A self reference.\n   */\n\n\n  usingHttpAgent(agent) {\n    this.agent_ = agent;\n    return this;\n  }\n  /**\n   * @return {http.Agent} The http agent used for each request\n   */\n\n\n  getHttpAgent() {\n    return this.agent_;\n  }\n  /**\n   * Sets the desired capabilities when requesting a new session. This will\n   * overwrite any previously set capabilities.\n   * @param {!(Object|Capabilities)} capabilities The desired capabilities for\n   *     a new session.\n   * @return {!Builder} A self reference.\n   */\n\n\n  withCapabilities(capabilities) {\n    this.capabilities_ = new Capabilities(capabilities);\n    return this;\n  }\n  /**\n   * Returns the base set of capabilities this instance is currently configured\n   * to use.\n   * @return {!Capabilities} The current capabilities for this builder.\n   */\n\n\n  getCapabilities() {\n    return this.capabilities_;\n  }\n  /**\n   * Configures the target browser for clients created by this instance.\n   * Any calls to {@link #withCapabilities} after this function will\n   * overwrite these settings.\n   *\n   * You may also define the target browser using the {@code SELENIUM_BROWSER}\n   * environment variable. If set, this environment variable should be of the\n   * form `browser[:[version][:platform]]`.\n   *\n   * @param {(string|Browser)} name The name of the target browser;\n   *     common defaults are available on the {@link webdriver.Browser} enum.\n   * @param {string=} opt_version A desired version; may be omitted if any\n   *     version should be used.\n   * @param {string=} opt_platform The desired platform; may be omitted if any\n   *     version may be used.\n   * @return {!Builder} A self reference.\n   */\n\n\n  forBrowser(name, opt_version, opt_platform) {\n    this.capabilities_.set(Capability.BROWSER_NAME, name);\n    this.capabilities_.set(Capability.VERSION, opt_version || null);\n    this.capabilities_.set(Capability.PLATFORM, opt_platform || null);\n    return this;\n  }\n  /**\n   * Sets the proxy configuration for the target browser.\n   * Any calls to {@link #withCapabilities} after this function will\n   * overwrite these settings.\n   *\n   * @param {!capabilities.ProxyConfig} config The configuration to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setProxy(config) {\n    this.capabilities_.setProxy(config);\n    return this;\n  }\n  /**\n   * Sets the logging preferences for the created session. Preferences may be\n   * changed by repeated calls, or by calling {@link #withCapabilities}.\n   * @param {!(./lib/logging.Preferences|Object<string, string>)} prefs The\n   *     desired logging preferences.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setLoggingPrefs(prefs) {\n    this.capabilities_.setLoggingPrefs(prefs);\n    return this;\n  }\n  /**\n   * Sets whether native events should be used.\n   * @param {boolean} enabled Whether to enable native events.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setEnableNativeEvents(enabled) {\n    this.capabilities_.setEnableNativeEvents(enabled);\n    return this;\n  }\n  /**\n   * Sets how elements should be scrolled into view for interaction.\n   * @param {number} behavior The desired scroll behavior: either 0 to align\n   *     with the top of the viewport or 1 to align with the bottom.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setScrollBehavior(behavior) {\n    this.capabilities_.setScrollBehavior(behavior);\n    return this;\n  }\n  /**\n   * Sets the default action to take with an unexpected alert before returning\n   * an error.\n   * @param {string} behavior The desired behavior; should be \"accept\",\n   *     \"dismiss\", or \"ignore\". Defaults to \"dismiss\".\n   * @return {!Builder} A self reference.\n   */\n\n\n  setAlertBehavior(behavior) {\n    this.capabilities_.setAlertBehavior(behavior);\n    return this;\n  }\n  /**\n   * Sets Chrome specific {@linkplain chrome.Options options} for drivers\n   * created by this builder. Any logging or proxy settings defined on the given\n   * options will take precedence over those set through\n   * {@link #setLoggingPrefs} and {@link #setProxy}, respectively.\n   *\n   * @param {!chrome.Options} options The ChromeDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setChromeOptions(options) {\n    this.chromeOptions_ = options;\n    return this;\n  }\n  /**\n   * Sets Firefox specific {@linkplain firefox.Options options} for drivers\n   * created by this builder. Any logging or proxy settings defined on the given\n   * options will take precedence over those set through\n   * {@link #setLoggingPrefs} and {@link #setProxy}, respectively.\n   *\n   * @param {!firefox.Options} options The FirefoxDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setFirefoxOptions(options) {\n    this.firefoxOptions_ = options;\n    return this;\n  }\n  /**\n   * @return {firefox.Options} the Firefox specific options currently configured\n   *     for this instance.\n   */\n\n\n  getFirefoxOptions() {\n    return this.firefoxOptions_;\n  }\n  /**\n   * Sets Opera specific {@linkplain opera.Options options} for drivers created\n   * by this builder. Any logging or proxy settings defined on the given options\n   * will take precedence over those set through {@link #setLoggingPrefs} and\n   * {@link #setProxy}, respectively.\n   *\n   * @param {!opera.Options} options The OperaDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setOperaOptions(options) {\n    this.operaOptions_ = options;\n    return this;\n  }\n  /**\n   * Set Internet Explorer specific {@linkplain ie.Options options} for drivers\n   * created by this builder. Any proxy settings defined on the given options\n   * will take precedence over those set through {@link #setProxy}.\n   *\n   * @param {!ie.Options} options The IEDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setIeOptions(options) {\n    this.ieOptions_ = options;\n    return this;\n  }\n  /**\n   * Set {@linkplain edge.Options options} specific to Microsoft's Edge browser\n   * for drivers created by this builder. Any proxy settings defined on the\n   * given options will take precedence over those set through\n   * {@link #setProxy}.\n   *\n   * @param {!edge.Options} options The MicrosoftEdgeDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setEdgeOptions(options) {\n    this.edgeOptions_ = options;\n    return this;\n  }\n  /**\n   * Sets Safari specific {@linkplain safari.Options options} for drivers\n   * created by this builder. Any logging settings defined on the given options\n   * will take precedence over those set through {@link #setLoggingPrefs}.\n   *\n   * @param {!safari.Options} options The Safari options to use.\n   * @return {!Builder} A self reference.\n   */\n\n\n  setSafariOptions(options) {\n    this.safariOptions_ = options;\n    return this;\n  }\n  /**\n   * @return {safari.Options} the Safari specific options currently configured\n   *     for this instance.\n   */\n\n\n  getSafariOptions() {\n    return this.safariOptions_;\n  }\n  /**\n   * Sets the control flow that created drivers should execute actions in. If\n   * the flow is never set, or is set to {@code null}, it will use the active\n   * flow at the time {@link #build()} is called.\n   * @param {promise.ControlFlow} flow The control flow to use, or\n   *     {@code null} to\n   * @return {!Builder} A self reference.\n   */\n\n\n  setControlFlow(flow) {\n    this.flow_ = flow;\n    return this;\n  }\n  /**\n   * Creates a new WebDriver client based on this builder's current\n   * configuration.\n   *\n   * This method will return a {@linkplain ThenableWebDriver} instance, allowing\n   * users to issue commands directly without calling `then()`. The returned\n   * thenable wraps a promise that will resolve to a concrete\n   * {@linkplain webdriver.WebDriver WebDriver} instance. The promise will be\n   * rejected if the remote end fails to create a new session.\n   *\n   * @return {!ThenableWebDriver} A new WebDriver instance.\n   * @throws {Error} If the current configuration is invalid.\n   */\n\n\n  build() {\n    // Create a copy for any changes we may need to make based on the current\n    // environment.\n    var capabilities = new Capabilities(this.capabilities_);\n    var browser;\n\n    if (!this.ignoreEnv_ && process.env.SELENIUM_BROWSER) {\n      this.log_.fine(`SELENIUM_BROWSER=${process.env.SELENIUM_BROWSER}`);\n      browser = process.env.SELENIUM_BROWSER.split(/:/, 3);\n      capabilities.set(Capability.BROWSER_NAME, browser[0]);\n      capabilities.set(Capability.VERSION, browser[1] || null);\n      capabilities.set(Capability.PLATFORM, browser[2] || null);\n    }\n\n    browser = capabilities.get(Capability.BROWSER_NAME);\n\n    if (typeof browser !== 'string') {\n      throw TypeError(`Target browser must be a string, but is <${typeof browser}>;` + ' did you forget to call forBrowser()?');\n    }\n\n    if (browser === 'ie') {\n      browser = Browser.INTERNET_EXPLORER;\n    } // Apply browser specific overrides.\n\n\n    if (browser === Browser.CHROME && this.chromeOptions_) {\n      capabilities.merge(this.chromeOptions_.toCapabilities());\n    } else if (browser === Browser.FIREFOX && this.firefoxOptions_) {\n      capabilities.merge(this.firefoxOptions_.toCapabilities());\n    } else if (browser === Browser.INTERNET_EXPLORER && this.ieOptions_) {\n      capabilities.merge(this.ieOptions_.toCapabilities());\n    } else if (browser === Browser.OPERA && this.operaOptions_) {\n      capabilities.merge(this.operaOptions_.toCapabilities());\n    } else if (browser === Browser.SAFARI && this.safariOptions_) {\n      capabilities.merge(this.safariOptions_.toCapabilities());\n    } else if (browser === Browser.EDGE && this.edgeOptions_) {\n      capabilities.merge(this.edgeOptions_.toCapabilities());\n    } // Check for a remote browser.\n\n\n    let url = this.url_;\n\n    if (!this.ignoreEnv_) {\n      if (process.env.SELENIUM_REMOTE_URL) {\n        this.log_.fine(`SELENIUM_REMOTE_URL=${process.env.SELENIUM_REMOTE_URL}`);\n        url = process.env.SELENIUM_REMOTE_URL;\n      } else if (process.env.SELENIUM_SERVER_JAR) {\n        this.log_.fine(`SELENIUM_SERVER_JAR=${process.env.SELENIUM_SERVER_JAR}`);\n        url = startSeleniumServer(process.env.SELENIUM_SERVER_JAR);\n      }\n    }\n\n    if (url) {\n      this.log_.fine('Creating session on remote server');\n      let client = Promise.resolve(url).then(url => new _http.HttpClient(url, this.agent_, this.proxy_));\n      let executor = new _http.Executor(client);\n\n      if (browser === Browser.CHROME) {\n        const driver = ensureFileDetectorsAreEnabled(chrome.Driver);\n        return createDriver(driver, capabilities, executor, this.flow_);\n      }\n\n      if (browser === Browser.FIREFOX) {\n        const driver = ensureFileDetectorsAreEnabled(firefox.Driver);\n        return createDriver(driver, capabilities, executor, this.flow_);\n      }\n\n      return createDriver(WebDriver, executor, capabilities, this.flow_);\n    } // Check for a native browser.\n\n\n    switch (browser) {\n      case Browser.CHROME:\n        return createDriver(chrome.Driver, capabilities, null, this.flow_);\n\n      case Browser.FIREFOX:\n        return createDriver(firefox.Driver, capabilities, null, this.flow_);\n\n      case Browser.INTERNET_EXPLORER:\n        return createDriver(ie.Driver, capabilities, this.flow_);\n\n      case Browser.EDGE:\n        return createDriver(edge.Driver, capabilities, null, this.flow_);\n\n      case Browser.OPERA:\n        return createDriver(opera.Driver, capabilities, null, this.flow_);\n\n      case Browser.PHANTOM_JS:\n        return createDriver(phantomjs.Driver, capabilities, this.flow_);\n\n      case Browser.SAFARI:\n        return createDriver(safari.Driver, capabilities, this.flow_);\n\n      default:\n        throw new Error('Do not know how to build driver: ' + browser + '; did you forget to call usingServer(url)?');\n    }\n  }\n\n} // PUBLIC API\n\n\nexports.ActionSequence = actions.ActionSequence;\nexports.Browser = capabilities.Browser;\nexports.Builder = Builder;\nexports.Button = input.Button;\nexports.By = by.By;\nexports.Capabilities = capabilities.Capabilities;\nexports.Capability = capabilities.Capability;\nexports.Condition = webdriver.Condition;\nexports.EventEmitter = events.EventEmitter;\nexports.FileDetector = input.FileDetector;\nexports.Key = input.Key;\nexports.Session = session.Session;\nexports.ThenableWebDriver = ThenableWebDriver;\nexports.TouchSequence = actions.TouchSequence;\nexports.WebDriver = webdriver.WebDriver;\nexports.WebElement = webdriver.WebElement;\nexports.WebElementCondition = webdriver.WebElementCondition;\nexports.WebElementPromise = webdriver.WebElementPromise;\nexports.error = error;\nexports.logging = logging;\nexports.promise = promise;\nexports.until = until;","map":null,"metadata":{},"sourceType":"script"}