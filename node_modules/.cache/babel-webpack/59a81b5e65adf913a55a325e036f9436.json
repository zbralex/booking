{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http = require(\"http\");\n\nconst angular_wait_barrier_1 = require(\"./angular_wait_barrier\");\n\nconst highlight_delay_barrier_1 = require(\"./highlight_delay_barrier\");\n\nconst simple_webdriver_client_1 = require(\"./simple_webdriver_client\");\n\nconst webdriver_proxy_1 = require(\"./webdriver_proxy\");\n\nexports.BP_PREFIX = 'bpproxy';\n/**\n * The stability proxy is an http server responsible for intercepting\n * JSON webdriver commands. It keeps track of whether the page under test\n * needs to wait for page stability, and initiates a wait if so.\n */\n\nclass BlockingProxy {\n  constructor(seleniumAddress, highlightDelay = null) {\n    this.server = http.createServer(this.requestListener.bind(this));\n    this.proxy = new webdriver_proxy_1.WebDriverProxy(seleniumAddress);\n    let client = new simple_webdriver_client_1.SimpleWebDriverClient(seleniumAddress);\n    this.waitBarrier = new angular_wait_barrier_1.AngularWaitBarrier(client);\n    this.highlightBarrier = new highlight_delay_barrier_1.HighlightDelayBarrier(client, highlightDelay);\n    this.proxy.addBarrier(this.waitBarrier);\n    this.proxy.addBarrier(this.highlightBarrier);\n  }\n  /**\n   * This command is for the proxy server, not to be forwarded to Selenium.\n   */\n\n\n  static isProxyCommand(commandPath) {\n    return commandPath.split('/')[1] === exports.BP_PREFIX;\n  }\n  /**\n   * Turn on WebDriver logging.\n   *\n   * @param logDir The directory to create logs in.\n   */\n\n\n  enableLogging(logDir) {\n    this.waitBarrier.enableLogging(logDir);\n  }\n  /**\n   * Override the logger instance. Only used for testing.\n   */\n\n\n  setLogger(logger) {\n    this.waitBarrier.setLogger(logger);\n  }\n  /**\n   * Change the parameters used by the wait function.\n   */\n\n\n  setWaitParams(rootEl) {\n    this.waitBarrier.setRootSelector(rootEl);\n  }\n\n  handleProxyCommand(message, data, response) {\n    let command = message.url.split('/')[2];\n\n    switch (command) {\n      case 'waitEnabled':\n        if (message.method === 'GET') {\n          response.writeHead(200);\n          response.write(JSON.stringify({\n            value: this.waitBarrier.enabled\n          }));\n          response.end();\n        } else if (message.method === 'POST') {\n          response.writeHead(200);\n          this.waitBarrier.enabled = JSON.parse(data).value;\n          response.end();\n        } else {\n          response.writeHead(405);\n          response.write('Invalid method');\n          response.end();\n        }\n\n        break;\n\n      case 'waitParams':\n        if (message.method === 'GET') {\n          response.writeHead(200);\n          response.write(JSON.stringify({\n            rootSelector: this.waitBarrier.rootSelector\n          }));\n          response.end();\n        } else if (message.method === 'POST') {\n          response.writeHead(200);\n          this.waitBarrier.rootSelector = JSON.parse(data).rootSelector;\n          response.end();\n        } else {\n          response.writeHead(405);\n          response.write('Invalid method');\n          response.end();\n        }\n\n        break;\n\n      default:\n        response.writeHead(404);\n        response.write('Unknown stabilizer proxy command');\n        response.end();\n    }\n  }\n\n  requestListener(originalRequest, response) {\n    if (BlockingProxy.isProxyCommand(originalRequest.url)) {\n      let commandData = '';\n      originalRequest.on('data', d => {\n        commandData += d;\n      });\n      originalRequest.on('end', () => {\n        this.handleProxyCommand(originalRequest, commandData, response);\n      });\n      return;\n    } // OK to ignore the promise returned by this.\n\n\n    this.proxy.handleRequest(originalRequest, response);\n  }\n\n  listen(port) {\n    this.server.listen(port);\n    let actualPort = this.server.address().port;\n    return actualPort;\n  }\n\n  quit() {\n    return new Promise(resolve => {\n      this.server.close(resolve);\n    });\n  }\n\n}\n\nexports.BlockingProxy = BlockingProxy; //# sourceMappingURL=blockingproxy.js.map","map":null,"metadata":{},"sourceType":"script"}