{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    rimraf = require('rimraf'),\n    tmp = require('tmp');\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\n\n\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n} // PUBLIC API\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\n\n\nexports.rmDir = function (dirPath) {\n  return new Promise(function (fulfill, reject) {\n    var numAttempts = 0;\n    attemptRm();\n\n    function attemptRm() {\n      numAttempts += 1;\n      rimraf(dirPath, function (err) {\n        if (err) {\n          if (err.code && err.code === 'ENOTEMPTY' && numAttempts < 2) {\n            attemptRm();\n            return;\n          }\n\n          reject(err);\n        } else {\n          fulfill();\n        }\n      });\n    }\n  });\n};\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\n\n\nexports.copy = function (src, dst) {\n  return new Promise(function (fulfill, reject) {\n    var rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    rs.on('end', () => fulfill(dst));\n    var ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n    rs.pipe(ws);\n  });\n};\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\n\n\nexports.copyDir = function (src, dst, opt_exclude) {\n  var predicate = opt_exclude;\n\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function (p) {\n      return !opt_exclude.test(p);\n    };\n  } // TODO(jleyba): Make this function completely async.\n\n\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n\n  var files = fs.readdirSync(src);\n  files = files.map(function (file) {\n    return path.join(src, file);\n  });\n\n  if (predicate) {\n    files = files.filter(predicate);\n  }\n\n  var results = [];\n  files.forEach(function (file) {\n    var stats = fs.statSync(file);\n    var target = path.join(dst, path.basename(file));\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n\n      results.push(exports.copyDir(file, target, predicate));\n    } else {\n      results.push(exports.copy(file, target));\n    }\n  });\n  return Promise.all(results).then(() => dst);\n};\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\n\n\nexports.exists = function (aPath) {\n  return new Promise(function (fulfill, reject) {\n    let type = typeof aPath;\n\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fs.exists(aPath, fulfill);\n    }\n  });\n};\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\n\n\nexports.stat = function stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n};\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\n\n\nexports.unlink = function (aPath) {\n  return new Promise(function (fulfill, reject) {\n    fs.exists(aPath, function (exists) {\n      if (exists) {\n        fs.unlink(aPath, function (err) {\n          err && reject(err) || fulfill();\n        });\n      } else {\n        fulfill();\n      }\n    });\n  });\n};\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\n\n\nexports.tmpDir = function () {\n  return checkedCall(tmp.dir);\n};\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\n\n\nexports.tmpFile = function (opt_options) {\n  return checkedCall(callback => {\n    // |tmp.file| checks arguments length to detect options rather than doing a\n    // truthy check, so we must only pass options if there are some to pass.\n    if (opt_options) {\n      tmp.file(opt_options, callback);\n    } else {\n      tmp.file(callback);\n    }\n  });\n};\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\n\n\nexports.findInPath = function (file, opt_checkCwd) {\n  let dirs = [];\n\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n  return foundInDir ? path.join(foundInDir, file) : null;\n};\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\n\n\nexports.read = function (aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n};\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\n\n\nexports.write = function (aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n};\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\n\n\nexports.mkdir = function (aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n};\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\n\n\nexports.mkdirp = function mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir)).then(() => mkdirp(dir)).then(() => callback(null, dir), err => callback(err));\n\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n};\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\n\n\nexports.walkDir = function (rootPath) {\n  let seen = [];\n  return function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback)).then(files => Promise.all(files.map(file => {\n      file = path.join(dir, file);\n      return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n        seen.push({\n          path: path.relative(rootPath, file),\n          dir: stats.isDirectory()\n        });\n        return stats.isDirectory() && walk(file);\n      });\n    })));\n  }(rootPath).then(() => seen);\n};","map":null,"metadata":{},"sourceType":"script"}