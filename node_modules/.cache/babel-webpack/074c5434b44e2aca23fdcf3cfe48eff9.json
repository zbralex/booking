{"ast":null,"code":"/**\n * All scripts to be run on the client via executeAsyncScript or\n * executeScript should be put here.\n *\n * NOTE: These scripts are transmitted over the wire as JavaScript text\n * constructed using their toString representation, and *cannot*\n * reference external variables.\n *\n * Some implementations seem to have issues with // comments, so use star-style\n * inside scripts.  (TODO: add issue number / example implementations\n * that caused the switch to avoid the // comments.)\n */\n// jshint browser: true\n// jshint shadow: true\n\n/* global angular */\nvar functions = {}; ///////////////////////////////////////////////////////\n////                                               ////\n////                    HELPERS                    ////\n////                                               ////\n///////////////////////////////////////////////////////\n\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\n\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n\n  if (!helpers.length) {\n    return fun;\n  }\n\n  var FunClass = Function; // Get the linter to allow this eval\n\n  return new FunClass(helpers.join(';') + String.fromCharCode(59) + '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n/* Tests if an ngRepeat matches a repeater\n *\n * @param {string} ngRepeat The ngRepeat to test\n * @param {string} repeater The repeater to test against\n * @param {boolean} exact If the ngRepeat expression needs to match the whole\n *   repeater (not counting any `track by ...` modifier) or if it just needs to\n *   match a substring\n * @return {boolean} If the ngRepeat matched the repeater\n */\n\n\nfunction repeaterMatch(ngRepeat, repeater, exact) {\n  if (exact) {\n    return ngRepeat.split(' track by ')[0].split(' as ')[0].split('|')[0].split('=')[0].trim() == repeater;\n  } else {\n    return ngRepeat.indexOf(repeater) != -1;\n  }\n}\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\n\n\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n\n        if ($$testability) {\n          return {\n            $$testability: $$testability\n          };\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n\n        if ($injector) {\n          return {\n            $injector: $injector\n          };\n        }\n      }\n    } catch (err) {}\n  }\n\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n\n    return {\n      $injector: $injector,\n      $$testability: $$testability\n    };\n  } else {\n    return tryEl(document.body) || trySelector('[ng-app]') || trySelector('[ng\\\\:app]') || trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n} ///////////////////////////////////////////////////////\n////                                               ////\n////                    SCRIPTS                    ////\n////                                               ////\n///////////////////////////////////////////////////////\n\n/**\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\n\n\nfunctions.waitForAngular = function (rootSelector, callback) {\n  try {\n    // Wait for both angular1 testability and angular2 testability.\n    var testCallback = callback; // Wait for angular1 testability first and run waitForAngular2 as a callback\n\n    var waitForAngular1 = function (callback) {\n      if (window.angular) {\n        var hooks = getNg1Hooks(rootSelector);\n\n        if (!hooks) {\n          callback(); // not an angular1 app\n        } else {\n          if (hooks.$$testability) {\n            hooks.$$testability.whenStable(callback);\n          } else if (hooks.$injector) {\n            hooks.$injector.get('$browser').notifyWhenNoOutstandingRequests(callback);\n          } else if (!rootSelector) {\n            throw new Error('Could not automatically find injector on page: \"' + window.location.toString() + '\".  Consider using config.rootEl');\n          } else {\n            throw new Error('root element (' + rootSelector + ') has no injector.' + ' this may mean it is not inside ng-app.');\n          }\n        }\n      } else {\n        callback();\n      } // not an angular1 app\n\n    }; // Wait for Angular2 testability and then run test callback\n\n\n    var waitForAngular2 = function () {\n      if (window.getAngularTestability) {\n        if (rootSelector) {\n          var testability = null;\n          var el = document.querySelector(rootSelector);\n\n          try {\n            testability = window.getAngularTestability(el);\n          } catch (e) {}\n\n          if (testability) {\n            testability.whenStable(testCallback);\n            return;\n          }\n        } // Didn't specify root element or testability could not be found\n        // by rootSelector. This may happen in a hybrid app, which could have\n        // more than one root.\n\n\n        var testabilities = window.getAllAngularTestabilities();\n        var count = testabilities.length; // No angular2 testability, this happens when\n        // going to a hybrid page and going back to a pure angular1 page\n\n        if (count === 0) {\n          testCallback();\n          return;\n        }\n\n        var decrement = function () {\n          count--;\n\n          if (count === 0) {\n            testCallback();\n          }\n        };\n\n        testabilities.forEach(function (testability) {\n          testability.whenStable(decrement);\n        });\n      } else {\n        testCallback();\n      } // not an angular2 app\n\n    };\n\n    if (!window.angular && !window.getAngularTestability) {\n      // no testability hook\n      throw new Error('both angularJS testability and angular testability are undefined.' + '  This could be either ' + 'because this is a non-angular page or because your test involves ' + 'client-side navigation, which can interfere with Protractor\\'s ' + 'bootstrapping.  See http://git.io/v4gXM for details');\n    } else {\n      waitForAngular1(waitForAngular2);\n    } // Wait for angular1 and angular2\n    // Testability hooks sequentially\n\n  } catch (err) {\n    callback(err.message);\n  }\n};\n/**\n * Find a list of elements in the page by their angular binding.\n *\n * @param {string} binding The binding, e.g. {{cat.name}}.\n * @param {boolean} exactMatch Whether the binding needs to be matched exactly\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The elements containing the binding.\n */\n\n\nfunctions.findBindings = function (binding, exactMatch, using, rootSelector) {\n  using = using || document;\n\n  if (angular.getTestability) {\n    return getNg1Hooks(rootSelector).$$testability.findBindings(using, binding, exactMatch);\n  }\n\n  var bindings = using.getElementsByClassName('ng-binding');\n  var matches = [];\n\n  for (var i = 0; i < bindings.length; ++i) {\n    var dataBinding = angular.element(bindings[i]).data('$binding');\n\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n\n      if (exactMatch) {\n        var matcher = new RegExp('({|\\\\s|^|\\\\|)' +\n        /* See http://stackoverflow.com/q/3561711 */\n        binding.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&') + '(}|\\\\s|$|\\\\|)');\n\n        if (matcher.test(bindingName)) {\n          matches.push(bindings[i]);\n        }\n      } else {\n        if (bindingName.indexOf(binding) != -1) {\n          matches.push(bindings[i]);\n        }\n      }\n    }\n  }\n\n  return matches;\n  /* Return the whole array for webdriver.findElements. */\n};\n/**\n * Find an array of elements matching a row within an ng-repeat.\n * Always returns an array of only one element for plain old ng-repeat.\n * Returns an array of all the elements in one segment for ng-repeat-start.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {number} index The row index.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The row of the repeater, or an array of elements\n *     in the first row in the case of ng-repeat-start.\n */\n\n\nfunction findRepeaterRows(repeater, exact, index, using) {\n  using = using || document;\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  var rows = [];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n\n\n  var multiRows = [];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n\n        while (elem.nodeType != 8 || !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n\n          elem = elem.nextSibling;\n        }\n\n        multiRows.push(row);\n      }\n    }\n  }\n\n  var row = rows[index] || [],\n      multiRow = multiRows[index] || [];\n  return [].concat(row, multiRow);\n}\n\nfunctions.findRepeaterRows = wrapWithHelpers(findRepeaterRows, repeaterMatch);\n/**\n* Find all rows of an ng-repeat.\n*\n* @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n* @param {boolean} exact Whether the repeater needs to be matched exactly\n* @param {Element} using The scope of the search.\n*\n* @return {Array.<Element>} All rows of the repeater.\n*/\n\nfunction findAllRepeaterRows(repeater, exact, using) {\n  using = using || document;\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n\n        while (elem.nodeType != 8 || !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            rows.push(elem);\n          }\n\n          elem = elem.nextSibling;\n        }\n      }\n    }\n  }\n\n  return rows;\n}\n\nfunctions.findAllRepeaterRows = wrapWithHelpers(findAllRepeaterRows, repeaterMatch);\n/**\n * Find an element within an ng-repeat by its row and column.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {number} index The row index.\n * @param {string} binding The column binding, e.g. '{{cat.name}}'.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The element in an array.\n */\n\nfunction findRepeaterElement(repeater, exact, index, binding, using, rootSelector) {\n  var matches = [];\n  using = using || document;\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n\n\n  var multiRows = [];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n\n        while (elem.nodeType != 8 || elem.nodeValue && !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n\n          elem = elem.nextSibling;\n        }\n\n        multiRows.push(row);\n      }\n    }\n  }\n\n  var row = rows[index];\n  var multiRow = multiRows[index];\n  var bindings = [];\n\n  if (row) {\n    if (angular.getTestability) {\n      matches.push.apply(matches, getNg1Hooks(rootSelector).$$testability.findBindings(row, binding));\n    } else {\n      if (row.className.indexOf('ng-binding') != -1) {\n        bindings.push(row);\n      }\n\n      var childBindings = row.getElementsByClassName('ng-binding');\n\n      for (var i = 0; i < childBindings.length; ++i) {\n        bindings.push(childBindings[i]);\n      }\n    }\n  }\n\n  if (multiRow) {\n    for (var i = 0; i < multiRow.length; ++i) {\n      var rowElem = multiRow[i];\n\n      if (angular.getTestability) {\n        matches.push.apply(matches, getNg1Hooks(rootSelector).$$testability.findBindings(rowElem, binding));\n      } else {\n        if (rowElem.className.indexOf('ng-binding') != -1) {\n          bindings.push(rowElem);\n        }\n\n        var childBindings = rowElem.getElementsByClassName('ng-binding');\n\n        for (var j = 0; j < childBindings.length; ++j) {\n          bindings.push(childBindings[j]);\n        }\n      }\n    }\n  }\n\n  for (var i = 0; i < bindings.length; ++i) {\n    var dataBinding = angular.element(bindings[i]).data('$binding');\n\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n\n      if (bindingName.indexOf(binding) != -1) {\n        matches.push(bindings[i]);\n      }\n    }\n  }\n\n  return matches;\n}\n\nfunctions.findRepeaterElement = wrapWithHelpers(findRepeaterElement, repeaterMatch, getNg1Hooks);\n/**\n * Find the elements in a column of an ng-repeat.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {string} binding The column binding, e.g. '{{cat.name}}'.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The elements in the column.\n */\n\nfunction findRepeaterColumn(repeater, exact, binding, using, rootSelector) {\n  var matches = [];\n  using = using || document;\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n\n\n  var multiRows = [];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n\n        while (elem.nodeType != 8 || elem.nodeValue && !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n\n          elem = elem.nextSibling;\n        }\n\n        multiRows.push(row);\n      }\n    }\n  }\n\n  var bindings = [];\n\n  for (var i = 0; i < rows.length; ++i) {\n    if (angular.getTestability) {\n      matches.push.apply(matches, getNg1Hooks(rootSelector).$$testability.findBindings(rows[i], binding));\n    } else {\n      if (rows[i].className.indexOf('ng-binding') != -1) {\n        bindings.push(rows[i]);\n      }\n\n      var childBindings = rows[i].getElementsByClassName('ng-binding');\n\n      for (var k = 0; k < childBindings.length; ++k) {\n        bindings.push(childBindings[k]);\n      }\n    }\n  }\n\n  for (var i = 0; i < multiRows.length; ++i) {\n    for (var j = 0; j < multiRows[i].length; ++j) {\n      if (angular.getTestability) {\n        matches.push.apply(matches, getNg1Hooks(rootSelector).$$testability.findBindings(multiRows[i][j], binding));\n      } else {\n        var elem = multiRows[i][j];\n\n        if (elem.className.indexOf('ng-binding') != -1) {\n          bindings.push(elem);\n        }\n\n        var childBindings = elem.getElementsByClassName('ng-binding');\n\n        for (var k = 0; k < childBindings.length; ++k) {\n          bindings.push(childBindings[k]);\n        }\n      }\n    }\n  }\n\n  for (var j = 0; j < bindings.length; ++j) {\n    var dataBinding = angular.element(bindings[j]).data('$binding');\n\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n\n      if (bindingName.indexOf(binding) != -1) {\n        matches.push(bindings[j]);\n      }\n    }\n  }\n\n  return matches;\n}\n\nfunctions.findRepeaterColumn = wrapWithHelpers(findRepeaterColumn, repeaterMatch, getNg1Hooks);\n/**\n * Find elements by model name.\n *\n * @param {string} model The model name.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The matching elements.\n */\n\nfunctions.findByModel = function (model, using, rootSelector) {\n  using = using || document;\n\n  if (angular.getTestability) {\n    return getNg1Hooks(rootSelector).$$testability.findModels(using, model, true);\n  }\n\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var selector = '[' + prefixes[p] + 'model=\"' + model + '\"]';\n    var elements = using.querySelectorAll(selector);\n\n    if (elements.length) {\n      return elements;\n    }\n  }\n};\n/**\n * Find elements by options.\n *\n * @param {string} optionsDescriptor The descriptor for the option\n *     (i.e. fruit for fruit in fruits).\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\n\n\nfunctions.findByOptions = function (optionsDescriptor, using) {\n  using = using || document;\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n\n  for (var p = 0; p < prefixes.length; ++p) {\n    var selector = '[' + prefixes[p] + 'options=\"' + optionsDescriptor + '\"] option';\n    var elements = using.querySelectorAll(selector);\n\n    if (elements.length) {\n      return elements;\n    }\n  }\n};\n/**\n * Find buttons by textual content.\n *\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\n\n\nfunctions.findByButtonText = function (searchText, using) {\n  using = using || document;\n  var elements = using.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]');\n  var matches = [];\n\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText;\n\n    if (element.tagName.toLowerCase() == 'button') {\n      elementText = element.textContent || element.innerText || '';\n    } else {\n      elementText = element.value;\n    }\n\n    if (elementText.trim() === searchText) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n/**\n * Find buttons by textual content.\n *\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\n\n\nfunctions.findByPartialButtonText = function (searchText, using) {\n  using = using || document;\n  var elements = using.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]');\n  var matches = [];\n\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText;\n\n    if (element.tagName.toLowerCase() == 'button') {\n      elementText = element.textContent || element.innerText || '';\n    } else {\n      elementText = element.value;\n    }\n\n    if (elementText.indexOf(searchText) > -1) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n/**\n * Find elements by css selector and textual content.\n *\n * @param {string} cssSelector The css selector to match.\n * @param {string} searchText The exact text to match or a serialized regex.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} An array of matching elements.\n */\n\n\nfunctions.findByCssContainingText = function (cssSelector, searchText, using) {\n  using = using || document;\n\n  if (searchText.indexOf('__REGEXP__') === 0) {\n    var match = searchText.split('__REGEXP__')[1].match(/\\/(.*)\\/(.*)?/);\n    searchText = new RegExp(match[1], match[2] || '');\n  }\n\n  var elements = using.querySelectorAll(cssSelector);\n  var matches = [];\n\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText = element.textContent || element.innerText || '';\n    var elementMatches = searchText instanceof RegExp ? searchText.test(elementText) : elementText.indexOf(searchText) > -1;\n\n    if (elementMatches) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n/**\n * Tests whether the angular global variable is present on a page. Retries\n * in case the page is just loading slowly.\n *\n * Asynchronous.\n *\n * @param {number} attempts Number of times to retry.\n * @param {boolean} ng12Hybrid Flag set if app is a hybrid of angular 1 and 2\n * @param {function({version: ?number, message: ?string})} asyncCallback callback\n *\n */\n\n\nfunctions.testForAngular = function (attempts, ng12Hybrid, asyncCallback) {\n  var callback = function (args) {\n    setTimeout(function () {\n      asyncCallback(args);\n    }, 0);\n  };\n\n  var definitelyNg1 = !!ng12Hybrid;\n  var definitelyNg2OrNewer = false;\n\n  var check = function (n) {\n    try {\n      /* Figure out which version of angular we're waiting on */\n      if (!definitelyNg1 && !definitelyNg2OrNewer) {\n        if (window.angular && !(window.angular.version && window.angular.version.major > 1)) {\n          definitelyNg1 = true;\n        } else if (window.getAllAngularTestabilities) {\n          definitelyNg2OrNewer = true;\n        }\n      }\n      /* See if our version of angular is ready */\n\n\n      if (definitelyNg1) {\n        if (window.angular && window.angular.resumeBootstrap) {\n          return callback({\n            ver: 1\n          });\n        }\n      } else if (definitelyNg2OrNewer) {\n        if (true\n        /* ng2 has no resumeBootstrap() */\n        ) {\n          return callback({\n            ver: 2\n          });\n        }\n      }\n      /* Try again (or fail) */\n\n\n      if (n < 1) {\n        if (definitelyNg1 && window.angular) {\n          callback({\n            message: 'angular never provided resumeBootstrap'\n          });\n        } else if (ng12Hybrid && !window.angular) {\n          callback({\n            message: 'angular 1 never loaded' + window.getAllAngularTestabilities ? ' (are you sure this app ' + 'uses ngUpgrade?  Try un-setting ng12Hybrid)' : ''\n          });\n        } else {\n          callback({\n            message: 'retries looking for angular exceeded'\n          });\n        }\n      } else {\n        window.setTimeout(function () {\n          check(n - 1);\n        }, 1000);\n      }\n    } catch (e) {\n      callback({\n        message: e\n      });\n    }\n  };\n\n  check(attempts);\n};\n/**\n * Evalute an Angular expression in the context of a given element.\n *\n * @param {Element} element The element in whose scope to evaluate.\n * @param {string} expression The expression to evaluate.\n *\n * @return {?Object} The result of the evaluation.\n */\n\n\nfunctions.evaluate = function (element, expression) {\n  return angular.element(element).scope().$eval(expression);\n};\n\nfunctions.allowAnimations = function (element, value) {\n  var ngElement = angular.element(element);\n\n  if (ngElement.allowAnimations) {\n    // AngularDart: $testability API.\n    return ngElement.allowAnimations(value);\n  } else {\n    // AngularJS\n    var enabledFn = ngElement.injector().get('$animate').enabled;\n    return value == null ? enabledFn() : enabledFn(value);\n  }\n};\n/**\n * Return the current url using $location.absUrl().\n *\n * @param {string} selector The selector housing an ng-app\n */\n\n\nfunctions.getLocationAbsUrl = function (selector) {\n  var hooks = getNg1Hooks(selector);\n\n  if (angular.getTestability) {\n    return hooks.$$testability.getLocation();\n  }\n\n  return hooks.$injector.get('$location').absUrl();\n};\n/**\n * Browse to another page using in-page navigation.\n *\n * @param {string} selector The selector housing an ng-app\n * @param {string} url In page URL using the same syntax as $location.url(),\n *     /path?search=a&b=c#hash\n */\n\n\nfunctions.setLocation = function (selector, url) {\n  var hooks = getNg1Hooks(selector);\n\n  if (angular.getTestability) {\n    return hooks.$$testability.setLocation(url);\n  }\n\n  var $injector = hooks.$injector;\n  var $location = $injector.get('$location');\n  var $rootScope = $injector.get('$rootScope');\n\n  if (url !== $location.url()) {\n    $location.url(url);\n    $rootScope.$digest();\n  }\n};\n/**\n * Retrieve the pending $http requests.\n *\n * @param {string} selector The selector housing an ng-app\n * @return {!Array<!Object>} An array of pending http requests.\n */\n\n\nfunctions.getPendingHttpRequests = function (selector) {\n  var hooks = getNg1Hooks(selector, true);\n  var $http = hooks.$injector.get('$http');\n  return $http.pendingRequests;\n};\n\n['waitForAngular', 'findBindings', 'findByModel', 'getLocationAbsUrl', 'setLocation', 'getPendingHttpRequests'].forEach(function (funName) {\n  functions[funName] = wrapWithHelpers(functions[funName], getNg1Hooks);\n});\n/* Publish all the functions as strings to pass to WebDriver's\n * exec[Async]Script.  In addition, also include a script that will\n * install all the functions on window (for debugging.)\n *\n * We also wrap any exceptions thrown by a clientSideScripts function\n * that is not an instance of the Error type into an Error type.  If we\n * don't do so, then the resulting stack trace is completely unhelpful\n * and the exception message is just \"unknown error.\"  These types of\n * exceptions are the common case for dart2js code.  This wrapping gives\n * us the Dart stack trace and exception message.\n */\n\nvar util = require('util');\n\nvar scriptsList = [];\nvar scriptFmt = 'try { return (%s).apply(this, arguments); }\\n' + 'catch(e) { throw (e instanceof Error) ? e : new Error(e); }';\n\nfor (var fnName in functions) {\n  if (functions.hasOwnProperty(fnName)) {\n    exports[fnName] = util.format(scriptFmt, functions[fnName]);\n    scriptsList.push(util.format('%s: %s', fnName, functions[fnName]));\n  }\n}\n\nexports.installInBrowser = util.format('window.clientSideScripts = {%s};', scriptsList.join(', '));\n/**\n * Automatically installed by Protractor when a page is loaded, this\n * default mock module decorates $timeout to keep track of any\n * outstanding timeouts.\n *\n * @param {boolean} trackOutstandingTimeouts\n */\n\nexports.protractorBaseModuleFn = function (trackOutstandingTimeouts) {\n  var ngMod = angular.module('protractorBaseModule_', []).config(['$compileProvider', function ($compileProvider) {\n    if ($compileProvider.debugInfoEnabled) {\n      $compileProvider.debugInfoEnabled(true);\n    }\n  }]);\n\n  if (trackOutstandingTimeouts) {\n    ngMod.config(['$provide', function ($provide) {\n      $provide.decorator('$timeout', ['$delegate', function ($delegate) {\n        var $timeout = $delegate;\n        var taskId = 0;\n\n        if (!window['NG_PENDING_TIMEOUTS']) {\n          window['NG_PENDING_TIMEOUTS'] = {};\n        }\n\n        var extendedTimeout = function () {\n          var args = Array.prototype.slice.call(arguments);\n\n          if (typeof args[0] !== 'function') {\n            return $timeout.apply(null, args);\n          }\n\n          taskId++;\n          var fn = args[0];\n          window['NG_PENDING_TIMEOUTS'][taskId] = fn.toString();\n\n          var wrappedFn = function (taskId_) {\n            return function () {\n              delete window['NG_PENDING_TIMEOUTS'][taskId_];\n              return fn.apply(null, arguments);\n            };\n          }(taskId);\n\n          args[0] = wrappedFn;\n          var promise = $timeout.apply(null, args);\n          promise.ptorTaskId_ = taskId;\n          return promise;\n        };\n\n        extendedTimeout.cancel = function () {\n          var taskId_ = arguments[0] && arguments[0].ptorTaskId_;\n\n          if (taskId_) {\n            delete window['NG_PENDING_TIMEOUTS'][taskId_];\n          }\n\n          return $timeout.cancel.apply($timeout, arguments);\n        };\n\n        return extendedTimeout;\n      }]);\n    }]);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}