{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst options_1 = require(\"./options\");\n/**\n * A program has a command, a description, options, and a run method\n */\n\n\nlet Program = /*#__PURE__*/(() => {\n  class Program {\n    constructor() {\n      this.options = {};\n    }\n    /**\n     * Register a command and the description.\n     * @param cmd The command.\n     * @param cmdDescription The description of the command.\n     * @returns The program for method chaining.\n     */\n\n\n    command(cmd, cmdDescription) {\n      this.cmd = cmd;\n      this.cmdDescription = cmdDescription;\n      return this;\n    }\n    /**\n     * Register a new option.\n     * @param opt The option.\n     * @param description The description of the option.\n     * @param type The type of value expected: boolean, number, or string\n     * @param defaultValue The option's default value.\n     * @returns The program for method chaining.\n     */\n\n\n    option(opt, description, type, opt_defaultValue) {\n      this.options[opt] = new options_1.Option(opt, description, type, opt_defaultValue);\n      return this;\n    }\n    /**\n     * Adds an option to the program.\n     * @param option The option.\n     * @returns The program for method chaining.\n     */\n\n\n    addOption(option) {\n      this.options[option.opt] = option;\n      return this;\n    }\n    /**\n     * Registers a method that will be used to run the program.\n     * @param runMethod The method that will be used to run the program.\n     * @returns The program for method chaining.\n     */\n\n\n    action(runMethod) {\n      this.runMethod = runMethod;\n      return this;\n    }\n    /**\n     * Adds the value to the options and passes the updated options to the run\n     * method.\n     * @param args The arguments that will be parsed to run the method.\n     */\n\n\n    run(json) {\n      for (let opt in this.options) {\n        this.options[opt].value = this.getValue_(opt, json);\n      }\n\n      return Promise.resolve(this.runMethod(this.options));\n    }\n\n    getValue_(key, json) {\n      let keyList = key.split('.');\n      let tempJson = json;\n\n      while (keyList.length > 0) {\n        let keyItem = keyList[0];\n\n        if (tempJson[keyItem] != null) {\n          tempJson = tempJson[keyItem];\n          keyList = keyList.slice(1);\n        } else {\n          return undefined;\n        }\n      }\n\n      return tempJson;\n    }\n    /**\n     * Prints the command with the description. The description will have spaces\n     * between the cmd so that the starting position is \"posDescription\". If the\n     * gap between the cmd and the description is less than MIN_SPACING or\n     * posDescription is undefined, the spacing will be MIN_SPACING.\n     *\n     * @param opt_postDescription Starting position of the description.\n     */\n\n\n    printCmd(opt_posDescription) {\n      let log = '  ' + this.cmd;\n      let spacing = Program.MIN_SPACING;\n\n      if (opt_posDescription) {\n        let diff = opt_posDescription - log.length;\n\n        if (diff < Program.MIN_SPACING) {\n          spacing = Program.MIN_SPACING;\n        } else {\n          spacing = diff;\n        }\n      }\n\n      log += Array(spacing).join(' ') + this.cmdDescription;\n      console.log(log);\n    }\n    /**\n     * Prints the options with the option descriptions and default values.\n     * The posDescription and posDefault is the starting position for the option\n     * description. If extOptions are provided, check to see if we have already\n     * printed those options. Also, once we print the option, add them to the extOptions.\n     *\n     * @param posDescription Position to start logging the description.\n     * @param posDefault Position to start logging the default value.\n     * @param opt_extOptions A collection of options that will be updated.\n     */\n\n\n    printOptions(posDescription, posDefault, opt_extOptions) {\n      for (let opt in this.options) {\n        // we have already logged it\n        if (opt_extOptions && opt_extOptions[opt]) {\n          continue;\n        }\n\n        let option = this.options[opt];\n        let log = '  --' + option.opt;\n        let spacing = Program.MIN_SPACING; // description\n\n        let diff = posDescription - log.length;\n\n        if (diff < Program.MIN_SPACING) {\n          spacing = Program.MIN_SPACING;\n        } else {\n          spacing = diff;\n        }\n\n        log += Array(spacing).join(' ') + option.description; // default value\n\n        if (option.defaultValue) {\n          spacing = Program.MIN_SPACING;\n          let diff = posDefault - log.length - 1;\n\n          if (diff <= Program.MIN_SPACING) {\n            spacing = Program.MIN_SPACING;\n          } else {\n            spacing = diff;\n          }\n\n          log += Array(spacing).join(' ');\n          log += '[default: ' + option.defaultValue + ']';\n        }\n\n        console.log(log);\n\n        if (opt_extOptions) {\n          opt_extOptions[option.opt] = option;\n        }\n      }\n    }\n    /**\n     * Assuming that the this program can run by itself, to print out the program's\n     * help. Also assuming that the commands are called cmd-run and cmd-help.\n     */\n\n\n    printHelp() {\n      console.log('\\n' + 'Usage:        ' + this.cmd + ' [options]\\n' + '              ' + this.cmd + ' help\\n' + 'Description:  ' + this.cmdDescription + '\\n');\n      console.log('Options:');\n      this.printOptions(this.posDescription(), this.posDefault());\n    }\n\n    posDescription() {\n      return this.lengthOf_('opt') + 2 * Program.MIN_SPACING;\n    }\n\n    posDefault() {\n      return this.posDescription() + this.lengthOf_('description') + Program.MIN_SPACING;\n    }\n\n    lengthOf_(param) {\n      let maxLength = -1;\n\n      for (let opt in this.options) {\n        let option = this.options[opt];\n\n        if (param === 'description') {\n          maxLength = Math.max(maxLength, option.description.length);\n        } else if (param === 'opt') {\n          maxLength = Math.max(maxLength, option.opt.length);\n        }\n      }\n\n      return maxLength;\n    }\n    /**\n     * Create a collection of options used by this program.\n     * @returns The options used in the programs.\n     */\n\n\n    getOptions_(allOptions) {\n      for (let opt in this.options) {\n        allOptions[opt] = this.options[opt];\n      }\n\n      return allOptions;\n    }\n    /**\n     * Get the options used by the program and create the minimist options\n     * to ensure that minimist parses the values properly.\n     * @returns The options for minimist.\n     */\n\n\n    getMinimistOptions() {\n      let allOptions = {};\n      allOptions = this.getOptions_(allOptions);\n      let minimistOptions = {};\n      let minimistBoolean = [];\n      let minimistString = [];\n      let minimistNumber = [];\n      let minimistDefault = {};\n\n      for (let opt in allOptions) {\n        let option = allOptions[opt];\n\n        if (option.type === 'boolean') {\n          minimistBoolean.push(option.opt);\n        } else if (option.type === 'string') {\n          minimistString.push(option.opt);\n        } else if (option.type === 'number') {\n          minimistNumber.push(option.opt);\n        }\n\n        if (typeof option.defaultValue !== 'undefined') {\n          minimistDefault[option.opt] = option.defaultValue;\n        }\n      }\n\n      minimistOptions['boolean'] = minimistBoolean;\n      minimistOptions['string'] = minimistString;\n      minimistOptions['number'] = minimistNumber;\n      minimistOptions['default'] = minimistDefault;\n      return minimistOptions;\n    }\n\n  }\n\n  Program.MIN_SPACING = 4;\n  return Program;\n})();\nexports.Program = Program; //# sourceMappingURL=programs.js.map","map":null,"metadata":{},"sourceType":"script"}