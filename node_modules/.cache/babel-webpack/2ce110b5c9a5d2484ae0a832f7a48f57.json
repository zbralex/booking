{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines an environment agnostic {@linkplain cmd.Executor\n * command executor} that communicates with a remote end using JSON over HTTP.\n *\n * Clients should implement the {@link Client} interface, which is used by\n * the {@link Executor} to send commands to the remote end.\n */\n'use strict';\n\nconst cmd = require('./command');\n\nconst error = require('./error');\n\nconst logging = require('./logging');\n\nconst promise = require('./promise');\n\nconst Session = require('./session').Session;\n\nconst WebElement = require('./webdriver').WebElement;\n\nconst {\n  getAttribute,\n  isDisplayed\n} =\n/** @suppress {undefinedVars|uselessCode} */\nfunction () {\n  try {\n    return {\n      getAttribute: require('./atoms/get-attribute.js'),\n      isDisplayed: require('./atoms/is-displayed.js')\n    };\n  } catch (ex) {\n    throw Error('Failed to import atoms modules. If running in devmode, you need to run' + ' `./go node:atoms` from the project root: ' + ex);\n  }\n}();\n/**\n * Converts a headers map to a HTTP header block string.\n * @param {!Map<string, string>} headers The map to convert.\n * @return {string} The headers as a string.\n */\n\n\nfunction headersToString(headers) {\n  let ret = [];\n  headers.forEach(function (value, name) {\n    ret.push(`${name.toLowerCase()}: ${value}`);\n  });\n  return ret.join('\\n');\n}\n/**\n * Represents a HTTP request message. This class is a \"partial\" request and only\n * defines the path on the server to send a request to. It is each client's\n * responsibility to build the full URL for the final request.\n * @final\n */\n\n\nclass Request {\n  /**\n   * @param {string} method The HTTP method to use for the request.\n   * @param {string} path The path on the server to send the request to.\n   * @param {Object=} opt_data This request's non-serialized JSON payload data.\n   */\n  constructor(method, path, opt_data) {\n    this.method =\n    /** string */\n    method;\n    this.path =\n    /** string */\n    path;\n    this.data =\n    /** Object */\n    opt_data;\n    this.headers =\n    /** !Map<string, string> */\n    new Map([['Accept', 'application/json; charset=utf-8']]);\n  }\n  /** @override */\n\n\n  toString() {\n    let ret = `${this.method} ${this.path} HTTP/1.1\\n`;\n    ret += headersToString(this.headers) + '\\n\\n';\n\n    if (this.data) {\n      ret += JSON.stringify(this.data);\n    }\n\n    return ret;\n  }\n\n}\n/**\n * Represents a HTTP response message.\n * @final\n */\n\n\nclass Response {\n  /**\n   * @param {number} status The response code.\n   * @param {!Object<string>} headers The response headers. All header names\n   *     will be converted to lowercase strings for consistent lookups.\n   * @param {string} body The response body.\n   */\n  constructor(status, headers, body) {\n    this.status =\n    /** number */\n    status;\n    this.body =\n    /** string */\n    body;\n    this.headers =\n    /** !Map<string, string>*/\n    new Map();\n\n    for (let header in headers) {\n      this.headers.set(header.toLowerCase(), headers[header]);\n    }\n  }\n  /** @override */\n\n\n  toString() {\n    let ret = `HTTP/1.1 ${this.status}\\n${headersToString(this.headers)}\\n\\n`;\n\n    if (this.body) {\n      ret += this.body;\n    }\n\n    return ret;\n  }\n\n}\n\nconst DEV_ROOT = '../../../../buck-out/gen/javascript/';\n/** @enum {!Function} */\n\nconst Atom = {\n  GET_ATTRIBUTE: getAttribute,\n  IS_DISPLAYED: isDisplayed\n};\nconst LOG = logging.getLogger('webdriver.http');\n\nfunction post(path) {\n  return resource('POST', path);\n}\n\nfunction del(path) {\n  return resource('DELETE', path);\n}\n\nfunction get(path) {\n  return resource('GET', path);\n}\n\nfunction resource(method, path) {\n  return {\n    method: method,\n    path: path\n  };\n}\n/** @typedef {{method: string, path: string}} */\n\n\nvar CommandSpec;\n/** @typedef {function(!cmd.Command): !Promise<!cmd.Command>} */\n\nvar CommandTransformer;\n\nclass InternalTypeError extends TypeError {}\n/**\n * @param {!cmd.Command} command The initial command.\n * @param {Atom} atom The name of the atom to execute.\n * @return {!Promise<!cmd.Command>} The transformed command to execute.\n */\n\n\nfunction toExecuteAtomCommand(command, atom, ...params) {\n  return new Promise((resolve, reject) => {\n    if (typeof atom !== 'function') {\n      reject(new InternalTypeError('atom is not a function: ' + typeof atom));\n      return;\n    }\n\n    let newCmd = new cmd.Command(cmd.Name.EXECUTE_SCRIPT).setParameter('sessionId', command.getParameter('sessionId')).setParameter('script', `return (${atom}).apply(null, arguments)`).setParameter('args', params.map(param => command.getParameter(param)));\n    resolve(newCmd);\n  });\n}\n/** @const {!Map<string, CommandSpec>} */\n\n\nconst COMMAND_MAP = new Map([[cmd.Name.GET_SERVER_STATUS, get('/status')], [cmd.Name.NEW_SESSION, post('/session')], [cmd.Name.GET_SESSIONS, get('/sessions')], [cmd.Name.DESCRIBE_SESSION, get('/session/:sessionId')], [cmd.Name.QUIT, del('/session/:sessionId')], [cmd.Name.CLOSE, del('/session/:sessionId/window')], [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window_handle')], [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window_handles')], [cmd.Name.GET_CURRENT_URL, get('/session/:sessionId/url')], [cmd.Name.GET, post('/session/:sessionId/url')], [cmd.Name.GO_BACK, post('/session/:sessionId/back')], [cmd.Name.GO_FORWARD, post('/session/:sessionId/forward')], [cmd.Name.REFRESH, post('/session/:sessionId/refresh')], [cmd.Name.ADD_COOKIE, post('/session/:sessionId/cookie')], [cmd.Name.GET_ALL_COOKIES, get('/session/:sessionId/cookie')], [cmd.Name.DELETE_ALL_COOKIES, del('/session/:sessionId/cookie')], [cmd.Name.DELETE_COOKIE, del('/session/:sessionId/cookie/:name')], [cmd.Name.FIND_ELEMENT, post('/session/:sessionId/element')], [cmd.Name.FIND_ELEMENTS, post('/session/:sessionId/elements')], [cmd.Name.GET_ACTIVE_ELEMENT, post('/session/:sessionId/element/active')], [cmd.Name.FIND_CHILD_ELEMENT, post('/session/:sessionId/element/:id/element')], [cmd.Name.FIND_CHILD_ELEMENTS, post('/session/:sessionId/element/:id/elements')], [cmd.Name.CLEAR_ELEMENT, post('/session/:sessionId/element/:id/clear')], [cmd.Name.CLICK_ELEMENT, post('/session/:sessionId/element/:id/click')], [cmd.Name.SEND_KEYS_TO_ELEMENT, post('/session/:sessionId/element/:id/value')], [cmd.Name.SUBMIT_ELEMENT, post('/session/:sessionId/element/:id/submit')], [cmd.Name.GET_ELEMENT_TEXT, get('/session/:sessionId/element/:id/text')], [cmd.Name.GET_ELEMENT_TAG_NAME, get('/session/:sessionId/element/:id/name')], [cmd.Name.IS_ELEMENT_SELECTED, get('/session/:sessionId/element/:id/selected')], [cmd.Name.IS_ELEMENT_ENABLED, get('/session/:sessionId/element/:id/enabled')], [cmd.Name.IS_ELEMENT_DISPLAYED, get('/session/:sessionId/element/:id/displayed')], [cmd.Name.GET_ELEMENT_LOCATION, get('/session/:sessionId/element/:id/location')], [cmd.Name.GET_ELEMENT_SIZE, get('/session/:sessionId/element/:id/size')], [cmd.Name.GET_ELEMENT_ATTRIBUTE, get('/session/:sessionId/element/:id/attribute/:name')], [cmd.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY, get('/session/:sessionId/element/:id/css/:propertyName')], [cmd.Name.ELEMENT_EQUALS, get('/session/:sessionId/element/:id/equals/:other')], [cmd.Name.TAKE_ELEMENT_SCREENSHOT, get('/session/:sessionId/element/:id/screenshot')], [cmd.Name.SWITCH_TO_WINDOW, post('/session/:sessionId/window')], [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/current/maximize')], [cmd.Name.GET_WINDOW_POSITION, get('/session/:sessionId/window/current/position')], [cmd.Name.SET_WINDOW_POSITION, post('/session/:sessionId/window/current/position')], [cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/current/size')], [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/current/size')], [cmd.Name.SWITCH_TO_FRAME, post('/session/:sessionId/frame')], [cmd.Name.GET_PAGE_SOURCE, get('/session/:sessionId/source')], [cmd.Name.GET_TITLE, get('/session/:sessionId/title')], [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute')], [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute_async')], [cmd.Name.SCREENSHOT, get('/session/:sessionId/screenshot')], [cmd.Name.GET_TIMEOUT, get('/session/:sessionId/timeouts')], [cmd.Name.SET_TIMEOUT, post('/session/:sessionId/timeouts')], [cmd.Name.MOVE_TO, post('/session/:sessionId/moveto')], [cmd.Name.CLICK, post('/session/:sessionId/click')], [cmd.Name.DOUBLE_CLICK, post('/session/:sessionId/doubleclick')], [cmd.Name.MOUSE_DOWN, post('/session/:sessionId/buttondown')], [cmd.Name.MOUSE_UP, post('/session/:sessionId/buttonup')], [cmd.Name.MOVE_TO, post('/session/:sessionId/moveto')], [cmd.Name.SEND_KEYS_TO_ACTIVE_ELEMENT, post('/session/:sessionId/keys')], [cmd.Name.TOUCH_SINGLE_TAP, post('/session/:sessionId/touch/click')], [cmd.Name.TOUCH_DOUBLE_TAP, post('/session/:sessionId/touch/doubleclick')], [cmd.Name.TOUCH_DOWN, post('/session/:sessionId/touch/down')], [cmd.Name.TOUCH_UP, post('/session/:sessionId/touch/up')], [cmd.Name.TOUCH_MOVE, post('/session/:sessionId/touch/move')], [cmd.Name.TOUCH_SCROLL, post('/session/:sessionId/touch/scroll')], [cmd.Name.TOUCH_LONG_PRESS, post('/session/:sessionId/touch/longclick')], [cmd.Name.TOUCH_FLICK, post('/session/:sessionId/touch/flick')], [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/accept_alert')], [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/dismiss_alert')], [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert_text')], [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert_text')], [cmd.Name.SET_ALERT_CREDENTIALS, post('/session/:sessionId/alert/credentials')], [cmd.Name.GET_LOG, post('/session/:sessionId/log')], [cmd.Name.GET_AVAILABLE_LOG_TYPES, get('/session/:sessionId/log/types')], [cmd.Name.GET_SESSION_LOGS, post('/logs')], [cmd.Name.UPLOAD_FILE, post('/session/:sessionId/file')]]);\n/** @const {!Map<string, (CommandSpec|CommandTransformer)>} */\n\nconst W3C_COMMAND_MAP = new Map([[cmd.Name.GET_ACTIVE_ELEMENT, get('/session/:sessionId/element/active')], [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert/text')], [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert/text')], [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/alert/accept')], [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/alert/dismiss')], [cmd.Name.GET_ELEMENT_ATTRIBUTE, cmd => {\n  return toExecuteAtomCommand(cmd, Atom.GET_ATTRIBUTE, 'id', 'name');\n}], [cmd.Name.GET_ELEMENT_LOCATION, get('/session/:sessionId/element/:id/rect')], [cmd.Name.GET_ELEMENT_SIZE, get('/session/:sessionId/element/:id/rect')], [cmd.Name.IS_ELEMENT_DISPLAYED, cmd => {\n  return toExecuteAtomCommand(cmd, Atom.IS_DISPLAYED, 'id');\n}], [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute/sync')], [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute/async')], [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/maximize')], [cmd.Name.GET_WINDOW_POSITION, get('/session/:sessionId/window/position')], [cmd.Name.SET_WINDOW_POSITION, post('/session/:sessionId/window/position')], [cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/size')], [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/size')], [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window')], [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window/handles')]]);\n/**\n * Handles sending HTTP messages to a remote end.\n *\n * @interface\n */\n\nclass Client {\n  /**\n   * Sends a request to the server. The client will automatically follow any\n   * redirects returned by the server, fulfilling the returned promise with the\n   * final response.\n   *\n   * @param {!Request} httpRequest The request to send.\n   * @return {!Promise<Response>} A promise that will be fulfilled with the\n   *     server's response.\n   */\n  send(httpRequest) {}\n\n}\n\nconst CLIENTS =\n/** !WeakMap<!Executor, !(Client|IThenable<!Client>)> */\nnew WeakMap();\n/**\n * Sends a request using the given executor.\n * @param {!Executor} executor\n * @param {!Request} request\n * @return {!Promise<Response>}\n */\n\nfunction doSend(executor, request) {\n  const client = CLIENTS.get(executor);\n\n  if (promise.isPromise(client)) {\n    return client.then(client => {\n      CLIENTS.set(executor, client);\n      return client.send(request);\n    });\n  } else {\n    return client.send(request);\n  }\n}\n/**\n * @param {Map<string, CommandSpec>} customCommands\n *     A map of custom command definitions.\n * @param {boolean} w3c Whether to use W3C command mappings.\n * @param {!cmd.Command} command The command to resolve.\n * @return {!Promise<!Request>} A promise that will resolve with the\n *     command to execute.\n */\n\n\nfunction buildRequest(customCommands, w3c, command) {\n  LOG.finest(() => `Translating command: ${command.getName()}`);\n  let spec = customCommands && customCommands.get(command.getName());\n\n  if (spec) {\n    return toHttpRequest(spec);\n  }\n\n  if (w3c) {\n    spec = W3C_COMMAND_MAP.get(command.getName());\n\n    if (typeof spec === 'function') {\n      LOG.finest(() => `Transforming command for W3C: ${command.getName()}`);\n      return spec(command).then(newCommand => buildRequest(customCommands, w3c, newCommand));\n    } else if (spec) {\n      return toHttpRequest(spec);\n    }\n  }\n\n  spec = COMMAND_MAP.get(command.getName());\n\n  if (spec) {\n    return toHttpRequest(spec);\n  }\n\n  return Promise.reject(new error.UnknownCommandError('Unrecognized command: ' + command.getName()));\n  /**\n   * @param {CommandSpec} resource\n   * @return {!Promise<!Request>}\n   */\n\n  function toHttpRequest(resource) {\n    LOG.finest(() => `Building HTTP request: ${JSON.stringify(resource)}`);\n    let parameters = command.getParameters();\n    let path = buildPath(resource.path, parameters);\n    return Promise.resolve(new Request(resource.method, path, parameters));\n  }\n}\n/**\n * A command executor that communicates with the server using JSON over HTTP.\n *\n * By default, each instance of this class will use the legacy wire protocol\n * from [Selenium project][json]. The executor will automatically switch to the\n * [W3C wire protocol][w3c] if the remote end returns a compliant response to\n * a new session command.\n *\n * [json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol\n * [w3c]: https://w3c.github.io/webdriver/webdriver-spec.html\n *\n * @implements {cmd.Executor}\n */\n\n\nclass Executor {\n  /**\n   * @param {!(Client|IThenable<!Client>)} client The client to use for sending\n   *     requests to the server, or a promise-like object that will resolve to\n   *     to the client.\n   */\n  constructor(client) {\n    CLIENTS.set(this, client);\n    /**\n     * Whether this executor should use the W3C wire protocol. The executor\n     * will automatically switch if the remote end sends a compliant response\n     * to a new session command, however, this property may be directly set to\n     * `true` to force the executor into W3C mode.\n     * @type {boolean}\n     */\n\n    this.w3c = false;\n    /** @private {Map<string, CommandSpec>} */\n\n    this.customCommands_ = null;\n    /** @private {!logging.Logger} */\n\n    this.log_ = logging.getLogger('webdriver.http.Executor');\n  }\n  /**\n   * Defines a new command for use with this executor. When a command is sent,\n   * the {@code path} will be preprocessed using the command's parameters; any\n   * path segments prefixed with \":\" will be replaced by the parameter of the\n   * same name. For example, given \"/person/:name\" and the parameters\n   * \"{name: 'Bob'}\", the final command path will be \"/person/Bob\".\n   *\n   * @param {string} name The command name.\n   * @param {string} method The HTTP method to use when sending this command.\n   * @param {string} path The path to send the command to, relative to\n   *     the WebDriver server's command root and of the form\n   *     \"/path/:variable/segment\".\n   */\n\n\n  defineCommand(name, method, path) {\n    if (!this.customCommands_) {\n      this.customCommands_ = new Map();\n    }\n\n    this.customCommands_.set(name, {\n      method,\n      path\n    });\n  }\n  /** @override */\n\n\n  execute(command) {\n    let request = buildRequest(this.customCommands_, this.w3c, command);\n    return request.then(request => {\n      this.log_.finer(() => `>>> ${request.method} ${request.path}`);\n      return doSend(this, request).then(response => {\n        this.log_.finer(() => `>>>\\n${request}\\n<<<\\n${response}`);\n        let httpResponse = response;\n        let {\n          isW3C,\n          value\n        } = parseHttpResponse(command, httpResponse);\n\n        if (command.getName() === cmd.Name.NEW_SESSION || command.getName() === cmd.Name.DESCRIBE_SESSION) {\n          if (!value || !value.sessionId) {\n            throw new error.WebDriverError(`Unable to parse new session response: ${response.body}`);\n          } // The remote end is a W3C compliant server if there is no `status`\n          // field in the response. This is not applicable for the DESCRIBE_SESSION\n          // command, which is not defined in the W3C spec.\n\n\n          if (command.getName() === cmd.Name.NEW_SESSION) {\n            this.w3c = this.w3c || isW3C;\n          } // No implementations use the `capabilities` key yet...\n\n\n          let capabilities = value.capabilities || value.value;\n          return new Session(value.sessionId, capabilities);\n        }\n\n        return typeof value === 'undefined' ? null : value;\n      });\n    });\n  }\n\n}\n/**\n * @param {string} str .\n * @return {?} .\n */\n\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (ignored) {// Do nothing.\n  }\n}\n/**\n * Callback used to parse {@link Response} objects from a\n * {@link HttpClient}.\n *\n * @param {!cmd.Command} command The command the response is for.\n * @param {!Response} httpResponse The HTTP response to parse.\n * @return {{isW3C: boolean, value: ?}} An object describing the parsed\n *     response. This object will have two fields: `isW3C` indicates whether\n *     the response looks like it came from a remote end that conforms with the\n *     W3C WebDriver spec, and `value`, the actual response value.\n * @throws {WebDriverError} If the HTTP response is an error.\n */\n\n\nfunction parseHttpResponse(command, httpResponse) {\n  if (httpResponse.status < 200) {\n    // This should never happen, but throw the raw response so users report it.\n    throw new error.WebDriverError(`Unexpected HTTP response:\\n${httpResponse}`);\n  }\n\n  let parsed = tryParse(httpResponse.body);\n\n  if (parsed && typeof parsed === 'object') {\n    let value = parsed.value;\n    let isW3C = value !== null && typeof value === 'object' && typeof parsed.status === 'undefined';\n\n    if (!isW3C) {\n      error.checkLegacyResponse(parsed); // Adjust legacy new session responses to look like W3C to simplify\n      // later processing.\n\n      if (command.getName() === cmd.Name.NEW_SESSION || command.getName() == cmd.Name.DESCRIBE_SESSION) {\n        value = parsed;\n      }\n    } else if (httpResponse.status > 399) {\n      error.throwDecodedError(value);\n    }\n\n    return {\n      isW3C,\n      value\n    };\n  }\n\n  if (parsed !== undefined) {\n    return {\n      isW3C: false,\n      value: parsed\n    };\n  }\n\n  let value = httpResponse.body.replace(/\\r\\n/g, '\\n'); // 404 represents an unknown command; anything else > 399 is a generic unknown\n  // error.\n\n  if (httpResponse.status == 404) {\n    throw new error.UnsupportedOperationError(value);\n  } else if (httpResponse.status >= 400) {\n    throw new error.WebDriverError(value);\n  }\n\n  return {\n    isW3C: false,\n    value: value || null\n  };\n}\n/**\n * Builds a fully qualified path using the given set of command parameters. Each\n * path segment prefixed with ':' will be replaced by the value of the\n * corresponding parameter. All parameters spliced into the path will be\n * removed from the parameter map.\n * @param {string} path The original resource path.\n * @param {!Object<*>} parameters The parameters object to splice into the path.\n * @return {string} The modified path.\n */\n\n\nfunction buildPath(path, parameters) {\n  let pathParameters = path.match(/\\/:(\\w+)\\b/g);\n\n  if (pathParameters) {\n    for (let i = 0; i < pathParameters.length; ++i) {\n      let key = pathParameters[i].substring(2); // Trim the /:\n\n      if (key in parameters) {\n        let value = parameters[key];\n\n        if (WebElement.isId(value)) {\n          // When inserting a WebElement into the URL, only use its ID value,\n          // not the full JSON.\n          value = WebElement.extractId(value);\n        }\n\n        path = path.replace(pathParameters[i], '/' + value);\n        delete parameters[key];\n      } else {\n        throw new error.InvalidArgumentError('Missing required parameter: ' + key);\n      }\n    }\n  }\n\n  return path;\n} // PUBLIC API\n\n\nexports.Executor = Executor;\nexports.Client = Client;\nexports.Request = Request;\nexports.Response = Response;\nexports.buildPath = buildPath; // Exported for testing.","map":null,"metadata":{},"sourceType":"script"}