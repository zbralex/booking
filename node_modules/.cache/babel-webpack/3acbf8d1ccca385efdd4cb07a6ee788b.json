{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst locators_1 = require(\"./locators\");\n\nconst logger_1 = require(\"./logger\");\n\nconst util_1 = require(\"./util\");\n\nlet clientSideScripts = require('./clientsidescripts');\n\nlet logger = new logger_1.Logger('element');\n\nclass WebdriverWebElement {}\n\nexports.WebdriverWebElement = WebdriverWebElement;\nlet WEB_ELEMENT_FUNCTIONS = ['click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize', 'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId', 'takeScreenshot'];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\n\nclass ElementArrayFinder extends WebdriverWebElement {\n  constructor(browser_, getWebElements = null, locator_, actionResults_ = null) {\n    super();\n    this.browser_ = browser_;\n    this.getWebElements = getWebElements;\n    this.locator_ = locator_;\n    this.actionResults_ = actionResults_; // TODO(juliemr): might it be easier to combine this with our docs and just\n    // wrap each one explicity with its own documentation?\n\n    WEB_ELEMENT_FUNCTIONS.forEach(fnName => {\n      this[fnName] = (...args) => {\n        let actionFn = webElem => {\n          return webElem[fnName].apply(webElem, args);\n        };\n\n        return this.applyAction_(actionFn);\n      };\n    });\n  }\n  /**\n   * Create a shallow copy of ElementArrayFinder.\n   *\n   * @returns {!ElementArrayFinder} A shallow copy of this.\n   */\n\n\n  clone() {\n    // A shallow copy is all we need since the underlying fields can never be\n    // modified. (Locator can be modified by the user, but that should\n    // rarely/never happen and it doesn't affect functionalities).\n    return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n  }\n  /**\n   * Calls to ElementArrayFinder may be chained to find an array of elements\n   * using the current elements in this ElementArrayFinder as the starting\n   * point. This function returns a new ElementArrayFinder which would contain\n   * the children elements found (and could also be empty).\n   *\n   * @alias element.all(locator).all(locator)\n   * @view\n   * <div id='id1' class=\"parent\">\n   *   <ul>\n   *     <li class=\"foo\">1a</li>\n   *     <li class=\"baz\">1b</li>\n   *   </ul>\n   * </div>\n   * <div id='id2' class=\"parent\">\n   *   <ul>\n   *     <li class=\"foo\">2a</li>\n   *     <li class=\"bar\">2b</li>\n   *   </ul>\n   * </div>\n   *\n   * @example\n   * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n   * expect(foo.getText()).toEqual(['1a', '2a']);\n   * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n   * expect(baz.getText()).toEqual(['1b']);\n   * let nonexistent = element.all(by.css('.parent'))\n   *   .all(by.css('.NONEXISTENT'));\n   * expect(nonexistent.getText()).toEqual(['']);\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let foo = $$('.parent').$$('.foo');\n   * expect(foo.getText()).toEqual(['1a', '2a']);\n   * let baz = $$('.parent').$$('.baz');\n   * expect(baz.getText()).toEqual(['1b']);\n   * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n   * expect(nonexistent.getText()).toEqual(['']);\n   *\n   * @param {webdriver.Locator} subLocator\n   * @returns {ElementArrayFinder}\n   */\n\n\n  all(locator) {\n    let ptor = this.browser_;\n\n    let getWebElements = () => {\n      if (this.getWebElements === null) {\n        // This is the first time we are looking for an element\n        return ptor.waitForAngular('Locator: ' + locator).then(() => {\n          if (locators_1.isProtractorLocator(locator)) {\n            return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n          } else {\n            return ptor.driver.findElements(locator);\n          }\n        });\n      } else {\n        return this.getWebElements().then(parentWebElements => {\n          // For each parent web element, find their children and construct\n          // a list of Promise<List<child_web_element>>\n          let childrenPromiseList = parentWebElements.map(parentWebElement => {\n            return locators_1.isProtractorLocator(locator) ? locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) : parentWebElement.findElements(locator);\n          }); // Resolve the list of Promise<List<child_web_elements>> and merge\n          // into a single list\n\n          return selenium_webdriver_1.promise.all(childrenPromiseList).then(resolved => {\n            return resolved.reduce((childrenList, resolvedE) => {\n              return childrenList.concat(resolvedE);\n            }, []);\n          });\n        });\n      }\n    };\n\n    return new ElementArrayFinder(this.browser_, getWebElements, locator);\n  }\n  /**\n   * Apply a filter function to each element within the ElementArrayFinder.\n   * Returns a new ElementArrayFinder with all elements that pass the filter\n   * function. The filter function receives the ElementFinder as the first\n   * argument and the index as a second arg. This does not actually retrieve\n   * the underlying list of elements, so it can be used in page objects.\n   *\n   * @alias element.all(locator).filter(filterFn)\n   * @view\n   * <ul class=\"items\">\n   *   <li class=\"one\">First</li>\n   *   <li class=\"two\">Second</li>\n   *   <li class=\"three\">Third</li>\n   * </ul>\n   *\n   * @example\n   * element.all(by.css('.items li')).filter(function(elem, index) {\n   *   return elem.getText().then(function(text) {\n   *     return text === 'Third';\n   *   });\n   * }).first().click();\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * $$('.items li').filter(function(elem, index) {\n   *   return elem.getText().then(function(text) {\n   *     return text === 'Third';\n   *   });\n   * }).first().click();\n   *\n   * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n   * filterFn\n   *     Filter function that will test if an element should be returned.\n   *     filterFn can either return a boolean or a promise that resolves to a\n   * boolean\n   * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n   * array\n   *     of element that satisfy the filter function.\n   */\n\n\n  filter(filterFn) {\n    let getWebElements = () => {\n      return this.getWebElements().then(parentWebElements => {\n        let list = parentWebElements.map((parentWebElement, index) => {\n          let elementFinder = ElementFinder.fromWebElement_(this.browser_, parentWebElement, this.locator_);\n          return filterFn(elementFinder, index);\n        });\n        return selenium_webdriver_1.promise.all(list).then(resolvedList => {\n          return parentWebElements.filter((parentWebElement, index) => {\n            return resolvedList[index];\n          });\n        });\n      });\n    };\n\n    return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n  }\n  /**\n   * Get an element within the ElementArrayFinder by index. The index starts at 0.\n   * Negative indices are wrapped (i.e. -i means ith element from last)\n   * This does not actually retrieve the underlying element.\n   *\n   * @alias element.all(locator).get(index)\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let list = element.all(by.css('.items li'));\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let list = $$('.items li');\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * @param {number|webdriver.promise.Promise} index Element index.\n   * @returns {ElementFinder} finder representing element at the given index.\n   */\n\n\n  get(index) {\n    let getWebElements = () => {\n      return selenium_webdriver_1.promise.all([index, this.getWebElements()]).then(([i, parentWebElements]) => {\n        if (i < 0) {\n          i += parentWebElements.length;\n        }\n\n        if (i < 0 || i >= parentWebElements.length) {\n          throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index + ', but there are only ' + parentWebElements.length + ' elements that match ' + 'locator ' + this.locator_.toString());\n        }\n\n        return [parentWebElements[i]];\n      });\n    };\n\n    return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n  }\n  /**\n   * Get the first matching element for the ElementArrayFinder. This does not\n   * actually retrieve the underlying element.\n   *\n   * @alias element.all(locator).first()\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let first = element.all(by.css('.items li')).first();\n   * expect(first.getText()).toBe('First');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let first = $$('.items li').first();\n   * expect(first.getText()).toBe('First');\n   *\n   * @returns {ElementFinder} finder representing the first matching element\n   */\n\n\n  first() {\n    return this.get(0);\n  }\n\n  /**\n   * Get the last matching element for the ElementArrayFinder. This does not\n   * actually retrieve the underlying element.\n   *\n   * @alias element.all(locator).last()\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let last = element.all(by.css('.items li')).last();\n   * expect(last.getText()).toBe('Third');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let last = $$('.items li').last();\n   * expect(last.getText()).toBe('Third');\n   *\n   * @returns {ElementFinder} finder representing the last matching element\n   */\n  last() {\n    return this.get(-1);\n  }\n  /**\n   * Shorthand function for finding arrays of elements by css.\n   * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n   *\n   * @alias $$(cssSelector)\n   * @view\n   * <div class=\"count\">\n   *   <span class=\"one\">First</span>\n   *   <span class=\"two\">Second</span>\n   * </div>\n   *\n   * @example\n   * // The following two blocks of code are equivalent.\n   * let list = element.all(by.css('.count span'));\n   * expect(list.count()).toBe(2);\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let list = $$('.count span');\n   * expect(list.count()).toBe(2);\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * @param {string} selector a css selector\n   * @returns {ElementArrayFinder} which identifies the\n   *     array of the located {@link webdriver.WebElement}s.\n   */\n\n\n  $$(selector) {\n    return this.all(selenium_webdriver_1.By.css(selector));\n  }\n  /**\n   * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n   * that the ElementArrayFinder resolves to one and only one underlying\n   * element.\n   *\n   * @returns {ElementFinder} An ElementFinder representation\n   * @private\n   */\n\n\n  toElementFinder_() {\n    return new ElementFinder(this.browser_, this);\n  }\n  /**\n   * Count the number of elements represented by the ElementArrayFinder.\n   *\n   * @alias element.all(locator).count()\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let list = element.all(by.css('.items li'));\n   * expect(list.count()).toBe(3);\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let list = $$('.items li');\n   * expect(list.count()).toBe(3);\n   *\n   * @returns {!webdriver.promise.Promise} A promise which resolves to the\n   *     number of elements matching the locator.\n   */\n\n\n  count() {\n    return this.getWebElements().then(arr => {\n      return arr.length;\n    }, err => {\n      if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n        return 0;\n      } else {\n        throw err;\n      }\n    });\n  }\n  /**\n   * Returns true if there are any elements present that match the finder.\n   *\n   * @alias element.all(locator).isPresent()\n   *\n   * @example\n   * expect($('.item').isPresent()).toBeTruthy();\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  isPresent() {\n    return this.count().then(count => {\n      return count > 0;\n    });\n  }\n  /**\n   * Returns the most relevant locator.\n   *\n   * @example\n   * // returns by.css('#ID1')\n   * $('#ID1').locator();\n   *\n   * // returns by.css('#ID2')\n   * $('#ID1').$('#ID2').locator();\n   *\n   * // returns by.css('#ID1')\n   * $$('#ID1').filter(filterFn).get(0).click().locator();\n   *\n   * @returns {webdriver.Locator}\n   */\n\n\n  locator() {\n    return this.locator_;\n  }\n  /**\n   * Apply an action function to every element in the ElementArrayFinder,\n   * and return a new ElementArrayFinder that contains the results of the\n   * actions.\n   *\n   * @param {function(ElementFinder)} actionFn\n   *\n   * @returns {ElementArrayFinder}\n   * @private\n   */\n  // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n\n\n  applyAction_(actionFn) {\n    let callerError = new Error();\n    let actionResults = this.getWebElements().then(arr => selenium_webdriver_1.promise.all(arr.map(actionFn))).then(value => {\n      return {\n        passed: true,\n        value: value\n      };\n    }, error => {\n      return {\n        passed: false,\n        value: error\n      };\n    });\n\n    let getWebElements = () => actionResults.then(() => this.getWebElements());\n\n    actionResults = actionResults.then(result => {\n      if (result.passed) {\n        return result.value;\n      } else {\n        let noSuchErr;\n\n        if (result.value instanceof Error) {\n          noSuchErr = result.value;\n          noSuchErr.stack = noSuchErr.stack + callerError.stack;\n        } else {\n          noSuchErr = new Error(result.value);\n          noSuchErr.stack = callerError.stack;\n        }\n\n        throw noSuchErr;\n      }\n    });\n    return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n  }\n  /**\n   * Represents the ElementArrayFinder as an array of ElementFinders.\n   *\n   * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n   *     of ElementFinders specified by the locator.\n   */\n\n\n  asElementFinders_() {\n    return this.getWebElements().then(arr => {\n      return arr.map(webElem => {\n        return ElementFinder.fromWebElement_(this.browser_, webElem, this.locator_);\n      });\n    });\n  }\n  /**\n   * Retrieve the elements represented by the ElementArrayFinder. The input\n   * function is passed to the resulting promise, which resolves to an\n   * array of ElementFinders.\n   *\n   * @alias element.all(locator).then(thenFunction)\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * element.all(by.css('.items li')).then(function(arr) {\n   *   expect(arr.length).toEqual(3);\n   * });\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * $$('.items li').then(function(arr) {\n   *   expect(arr.length).toEqual(3);\n   * });\n   *\n   * @param {function(Array.<ElementFinder>)} fn\n   * @param {function(Error)} errorFn\n   *\n   * @returns {!webdriver.promise.Promise} A promise which will resolve to\n   *     an array of ElementFinders represented by the ElementArrayFinder.\n   */\n\n\n  then(fn, errorFn) {\n    if (this.actionResults_) {\n      return this.actionResults_.then(fn, errorFn);\n    } else {\n      return this.asElementFinders_().then(fn, errorFn);\n    }\n  }\n  /**\n   * Calls the input function on each ElementFinder represented by the\n   * ElementArrayFinder.\n   *\n   * @alias element.all(locator).each(eachFunction)\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * element.all(by.css('.items li')).each(function(element, index) {\n   *   // Will print 0 First, 1 Second, 2 Third.\n   *   element.getText().then(function (text) {\n   *     console.log(index, text);\n   *   });\n   * });\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * $$('.items li').each(function(element, index) {\n   *   // Will print 0 First, 1 Second, 2 Third.\n   *   element.getText().then(function (text) {\n   *     console.log(index, text);\n   *   });\n   * });\n   *\n   * @param {function(ElementFinder)} fn Input function\n   *\n   * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n   *     function has been called on all the ElementFinders. The promise will\n   *     resolve to null.\n   */\n\n\n  each(fn) {\n    return this.map(fn).then(() => {\n      return null;\n    });\n  }\n  /**\n   * Apply a map function to each element within the ElementArrayFinder. The\n   * callback receives the ElementFinder as the first argument and the index as\n   * a second arg.\n   *\n   * @alias element.all(locator).map(mapFunction)\n   * @view\n   * <ul class=\"items\">\n   *   <li class=\"one\">First</li>\n   *   <li class=\"two\">Second</li>\n   *   <li class=\"three\">Third</li>\n   * </ul>\n   *\n   * @example\n   * let items = element.all(by.css('.items li')).map(function(elm, index) {\n   *   return {\n   *     index: index,\n   *     text: elm.getText(),\n   *     class: elm.getAttribute('class')\n   *   };\n   * });\n   * expect(items).toEqual([\n   *   {index: 0, text: 'First', class: 'one'},\n   *   {index: 1, text: 'Second', class: 'two'},\n   *   {index: 2, text: 'Third', class: 'three'}\n   * ]);\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let items = $$('.items li').map(function(elm, index) {\n   *   return {\n   *     index: index,\n   *     text: elm.getText(),\n   *     class: elm.getAttribute('class')\n   *   };\n   * });\n   * expect(items).toEqual([\n   *   {index: 0, text: 'First', class: 'one'},\n   *   {index: 1, text: 'Second', class: 'two'},\n   *   {index: 2, text: 'Third', class: 'three'}\n   * ]);\n   *\n   * @param {function(ElementFinder, number)} mapFn Map function that\n   *     will be applied to each element.\n   * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n   *     of values returned by the map function.\n   */\n\n\n  map(mapFn) {\n    return this.asElementFinders_().then(arr => {\n      let list = arr.map((elementFinder, index) => {\n        let mapResult = mapFn(elementFinder, index); // All nested arrays and objects will also be fully resolved.\n\n        return selenium_webdriver_1.promise.fullyResolved(mapResult);\n      });\n      return selenium_webdriver_1.promise.all(list);\n    });\n  }\n\n  /**\n   * Apply a reduce function against an accumulator and every element found\n   * using the locator (from left-to-right). The reduce function has to reduce\n   * every element into a single value (the accumulator). Returns promise of\n   * the accumulator. The reduce function receives the accumulator, current\n   * ElementFinder, the index, and the entire array of ElementFinders,\n   * respectively.\n   *\n   * @alias element.all(locator).reduce(reduceFn)\n   * @view\n   * <ul class=\"items\">\n   *   <li class=\"one\">First</li>\n   *   <li class=\"two\">Second</li>\n   *   <li class=\"three\">Third</li>\n   * </ul>\n   *\n   * @example\n   * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n   *   return elem.getText().then(function(text) {\n   *     return acc + text + ' ';\n   *   });\n   * }, '');\n   *\n   * expect(value).toEqual('First Second Third ');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let value = $$('.items li').reduce(function(acc, elem) {\n   *   return elem.getText().then(function(text) {\n   *     return acc + text + ' ';\n   *   });\n   * }, '');\n   *\n   * expect(value).toEqual('First Second Third ');\n   *\n   * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n   *     reduceFn Reduce function that reduces every element into a single\n   * value.\n   * @param {*} initialValue Initial value of the accumulator.\n   * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n   *     value of the accumulator.\n   */\n  reduce(reduceFn, initialValue) {\n    let valuePromise = selenium_webdriver_1.promise.when(initialValue);\n    return this.asElementFinders_().then(arr => {\n      return arr.reduce((valuePromise, elementFinder, index) => {\n        return valuePromise.then(value => {\n          return reduceFn(value, elementFinder, index, arr);\n        });\n      }, valuePromise);\n    });\n  }\n  /**\n   * Evaluates the input as if it were on the scope of the current underlying\n   * elements.\n   *\n   * @view\n   * <span class=\"foo\">{{letiableInScope}}</span>\n   *\n   * @example\n   * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let value = $$('.foo').evaluate('letiableInScope');\n   *\n   * @param {string} expression\n   *\n   * @returns {ElementArrayFinder} which resolves to the\n   *     evaluated expression for each underlying element.\n   *     The result will be resolved as in\n   *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n   *     be resolved as is, functions will be converted to string, and elements\n   *     will be returned as a WebElement.\n   */\n\n\n  evaluate(expression) {\n    let evaluationFn = webElem => {\n      return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n    };\n\n    return this.applyAction_(evaluationFn);\n  }\n  /**\n   * Determine if animation is allowed on the current underlying elements.\n   * @param {string} value\n   *\n   * @example\n   * // Turns off ng-animate animations for all elements in the <body>\n   * element(by.css('body')).allowAnimations(false);\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * $('body').allowAnimations(false);\n   *\n   * @returns {ElementArrayFinder} which resolves to whether animation is\n   * allowed.\n   */\n\n\n  allowAnimations(value) {\n    let allowAnimationsTestFn = webElem => {\n      return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n    };\n\n    return this.applyAction_(allowAnimationsTestFn);\n  }\n\n}\n\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\n\nclass ElementFinder extends WebdriverWebElement {\n  constructor(browser_, elementArrayFinder) {\n    super();\n    this.browser_ = browser_;\n    this.then = null;\n\n    if (!elementArrayFinder) {\n      throw new Error('BUG: elementArrayFinder cannot be empty');\n    }\n\n    this.parentElementArrayFinder = elementArrayFinder; // Only have a `then` method if the parent element array finder\n    // has action results.\n\n    if (this.parentElementArrayFinder.actionResults_) {\n      // Access the underlying actionResult of ElementFinder.\n      this.then = (fn, errorFn) => {\n        return this.elementArrayFinder_.then(actionResults => {\n          if (!fn) {\n            return actionResults[0];\n          }\n\n          return fn(actionResults[0]);\n        }, errorFn);\n      };\n    } // This filter verifies that there is only 1 element returned by the\n    // elementArrayFinder. It will warn if there are more than 1 element and\n    // throw an error if there are no elements.\n\n\n    let getWebElements = () => {\n      return elementArrayFinder.getWebElements().then(webElements => {\n        if (webElements.length === 0) {\n          throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n        } else {\n          if (webElements.length > 1) {\n            logger.warn('more than one element found for locator ' + elementArrayFinder.locator().toString() + ' - the first result will be used');\n          }\n\n          return [webElements[0]];\n        }\n      });\n    }; // Store a copy of the underlying elementArrayFinder, but with the more\n    // restrictive getWebElements (which checks that there is only 1 element).\n\n\n    this.elementArrayFinder_ = new ElementArrayFinder(this.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n    WEB_ELEMENT_FUNCTIONS.forEach(fnName => {\n      this[fnName] = (...args) => {\n        return this.elementArrayFinder_[fnName].apply(this.elementArrayFinder_, args).toElementFinder_();\n      };\n    });\n  }\n\n  static fromWebElement_(browser, webElem, locator) {\n    let getWebElements = () => {\n      return selenium_webdriver_1.promise.when([webElem]);\n    };\n\n    return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n  }\n  /**\n   * Create a shallow copy of ElementFinder.\n   *\n   * @returns {!ElementFinder} A shallow copy of this.\n   */\n\n\n  clone() {\n    // A shallow copy is all we need since the underlying fields can never be\n    // modified\n    return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n  }\n  /**\n   * @see ElementArrayFinder.prototype.locator\n   *\n   * @returns {webdriver.Locator}\n   */\n\n\n  locator() {\n    return this.elementArrayFinder_.locator();\n  }\n  /**\n   * Returns the WebElement represented by this ElementFinder.\n   * Throws the WebDriver error if the element doesn't exist.\n   *\n   * @alias element(locator).getWebElement()\n   * @view\n   * <div class=\"parent\">\n   *   some text\n   * </div>\n   *\n   * @example\n   * // The following four expressions are equivalent.\n   * $('.parent').getWebElement();\n   * element(by.css('.parent')).getWebElement();\n   * browser.driver.findElement(by.css('.parent'));\n   * browser.findElement(by.css('.parent'));\n   *\n   * @returns {webdriver.WebElementPromise}\n   */\n\n\n  getWebElement() {\n    let id = this.elementArrayFinder_.getWebElements().then(parentWebElements => {\n      return parentWebElements[0];\n    });\n    return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n  }\n  /**\n   * Calls to {@code all} may be chained to find an array of elements within a\n   * parent.\n   *\n   * @alias element(locator).all(locator)\n   * @view\n   * <div class=\"parent\">\n   *   <ul>\n   *     <li class=\"one\">First</li>\n   *     <li class=\"two\">Second</li>\n   *     <li class=\"three\">Third</li>\n   *   </ul>\n   * </div>\n   *\n   * @example\n   * let items = element(by.css('.parent')).all(by.tagName('li'));\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * let items = $('.parent').all(by.tagName('li'));\n   *\n   * @param {webdriver.Locator} subLocator\n   * @returns {ElementArrayFinder}\n   */\n\n\n  all(subLocator) {\n    return this.elementArrayFinder_.all(subLocator);\n  }\n  /**\n   * Calls to {@code element} may be chained to find elements within a parent.\n   *\n   * @alias element(locator).element(locator)\n   * @view\n   * <div class=\"parent\">\n   *   <div class=\"child\">\n   *     Child text\n   *     <div>{{person.phone}}</div>\n   *   </div>\n   * </div>\n   *\n   * @example\n   * // Chain 2 element calls.\n   * let child = element(by.css('.parent')).\n   *     element(by.css('.child'));\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = element(by.css('.parent')).\n   *     element(by.css('.child')).\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * // Chain 2 element calls.\n   * let child = $('.parent').$('.child');\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = $('.parent').$('.child').\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * @param {webdriver.Locator} subLocator\n   * @returns {ElementFinder}\n   */\n\n\n  element(subLocator) {\n    return this.all(subLocator).toElementFinder_();\n  }\n  /**\n   * Calls to {@code $$} may be chained to find an array of elements within a\n   * parent.\n   *\n   * @alias element(locator).all(selector)\n   * @view\n   * <div class=\"parent\">\n   *   <ul>\n   *     <li class=\"one\">First</li>\n   *     <li class=\"two\">Second</li>\n   *     <li class=\"three\">Third</li>\n   *   </ul>\n   * </div>\n   *\n   * @example\n   * let items = element(by.css('.parent')).$$('li');\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * let items = $('.parent').$$('li');\n   *\n   * @param {string} selector a css selector\n   * @returns {ElementArrayFinder}\n   */\n\n\n  $$(selector) {\n    return this.all(selenium_webdriver_1.By.css(selector));\n  }\n  /**\n   * Calls to {@code $} may be chained to find elements within a parent.\n   *\n   * @alias element(locator).$(selector)\n   * @view\n   * <div class=\"parent\">\n   *   <div class=\"child\">\n   *     Child text\n   *     <div>{{person.phone}}</div>\n   *   </div>\n   * </div>\n   *\n   * @example\n   * // Chain 2 element calls.\n   * let child = element(by.css('.parent')).\n   *     $('.child');\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = element(by.css('.parent')).\n   *     $('.child').\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * // Chain 2 element calls.\n   * let child = $('.parent').$('.child');\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = $('.parent').$('.child').\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * @param {string} selector A css selector\n   * @returns {ElementFinder}\n   */\n\n\n  $(selector) {\n    return this.element(selenium_webdriver_1.By.css(selector));\n  }\n  /**\n   * Determine whether the element is present on the page.\n   *\n   * @view\n   * <span>{{person.name}}</span>\n   *\n   * @example\n   * // Element exists.\n   * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n   *\n   * // Element not present.\n   * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n   *\n   * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n   *     the element is present on the page.\n   */\n\n\n  isPresent() {\n    return this.parentElementArrayFinder.getWebElements().then(arr => {\n      if (arr.length === 0) {\n        return false;\n      }\n\n      return arr[0].isEnabled().then(() => {\n        return true; // is present, whether it is enabled or not\n      }, util_1.falseIfMissing);\n    }, util_1.falseIfMissing);\n  }\n  /**\n   * Same as ElementFinder.isPresent(), except this checks whether the element\n   * identified by the subLocator is present, rather than the current element\n   * finder, i.e.: `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n   * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * `$('#abc').$('#def').isPresent()` is identical to\n   * `$('#abc').isElementPresent($('#def'))`.\n   *\n   * @see ElementFinder.isPresent\n   *\n   * @param {webdriver.Locator} subLocator Locator for element to look for.\n   * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n   *     the subelement is present on the page.\n   */\n\n\n  isElementPresent(subLocator) {\n    if (!subLocator) {\n      throw new Error('SubLocator is not supplied as a parameter to ' + '`isElementPresent(subLocator)`. You are probably looking for the ' + 'function `isPresent()`.');\n    }\n\n    return this.element(subLocator).isPresent();\n  }\n  /**\n   * Evaluates the input as if it were on the scope of the current element.\n   * @see ElementArrayFinder.prototype.evaluate\n   *\n   * @view\n   * <span id=\"foo\">{{letiableInScope}}</span>\n   *\n   * @example\n   * let value = element(by.id('foo')).evaluate('letiableInScope');\n   *\n   * @param {string} expression\n   *\n   * @returns {ElementFinder} which resolves to the evaluated expression.\n   */\n\n\n  evaluate(expression) {\n    return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n  }\n  /**\n   * @see ElementArrayFinder.prototype.allowAnimations.\n   * @param {string} value\n   *\n   * @returns {ElementFinder} which resolves to whether animation is allowed.\n   */\n\n\n  allowAnimations(value) {\n    return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n  }\n  /**\n   * Compares an element to this one for equality.\n   *\n   * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n   *\n   * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n\n\n  equals(element) {\n    return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() : element);\n  }\n\n}\n\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\n\nexports.build$ = (element, by) => {\n  return selector => {\n    return element(by.css(selector));\n  };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\n\n\nexports.build$$ = (element, by) => {\n  return selector => {\n    return element.all(by.css(selector));\n  };\n}; //# sourceMappingURL=element.js.map","map":null,"metadata":{},"sourceType":"script"}