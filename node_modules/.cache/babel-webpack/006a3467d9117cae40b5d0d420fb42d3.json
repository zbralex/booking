{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Various HTTP utilities.\n */\n'use strict';\n\nconst Executor = require('./index').Executor,\n      HttpClient = require('./index').HttpClient,\n      HttpRequest = require('./index').Request,\n      Command = require('../lib/command').Command,\n      CommandName = require('../lib/command').Name,\n      error = require('../lib/error'),\n      promise = require('../lib/promise');\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\n\n\nfunction getStatus(url) {\n  var client = new HttpClient(url);\n  var executor = new Executor(client);\n  var command = new Command(CommandName.GET_SERVER_STATUS);\n  return executor.execute(command);\n} // PUBLIC API\n\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\n\n\nexports.getStatus = getStatus;\n/**\n * Waits for a WebDriver server to be healthy and accepting requests.\n * @param {string} url Base URL of the server to query.\n * @param {number} timeout How long to wait for the server.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the server is ready, the wait will be terminated\n *     early with a {@link promise.CancellationError}.\n * @return {!Promise} A promise that will resolve when the server is ready, or\n *     if the wait is cancelled.\n */\n\nexports.waitForServer = function (url, timeout, opt_cancelToken) {\n  return new Promise((onResolve, onReject) => {\n    let start = Date.now();\n    let done = false;\n\n    let resolve = status => {\n      done = true;\n      onResolve(status);\n    };\n\n    let reject = err => {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(_ => reject(new promise.CancellationError()));\n    }\n\n    checkServerStatus();\n\n    function checkServerStatus() {\n      return getStatus(url).then(status => resolve(status), onError);\n    }\n\n    function onError(e) {\n      // Some servers don't support the status command. If they are able to\n      // response with an error, then can consider the server ready.\n      if (e instanceof error.UnsupportedOperationError) {\n        resolve({});\n        return;\n      }\n\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the WebDriver server at ' + url));\n      } else {\n        setTimeout(function () {\n          if (!done) {\n            checkServerStatus();\n          }\n        }, 50);\n      }\n    }\n  });\n};\n/**\n * Polls a URL with GET requests until it returns a 2xx response or the\n * timeout expires.\n * @param {string} url The URL to poll.\n * @param {number} timeout How long to wait, in milliseconds.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the a 2xx response is received, the wait will be\n *     terminated early with a {@link promise.CancellationError}.\n * @return {!Promise} A promise that will resolve when a 2xx is received from\n *     the given URL, or if the wait is cancelled.\n */\n\n\nexports.waitForUrl = function (url, timeout, opt_cancelToken) {\n  return new Promise((onResolve, onReject) => {\n    let client = new HttpClient(url);\n    let request = new HttpRequest('GET', '');\n    let start = Date.now();\n    let done = false;\n\n    let resolve = () => {\n      done = true;\n      onResolve();\n    };\n\n    let reject = err => {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(_ => reject(new promise.CancellationError()));\n    }\n\n    testUrl();\n\n    function testUrl() {\n      client.send(request).then(onResponse, onError);\n    }\n\n    function onError() {\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the URL to return 2xx: ' + url));\n      } else {\n        setTimeout(function () {\n          if (!done) {\n            testUrl();\n          }\n        }, 50);\n      }\n    }\n\n    function onResponse(response) {\n      if (done) {\n        return;\n      }\n\n      if (response.status > 199 && response.status < 300) {\n        resolve();\n        return;\n      }\n\n      onError();\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}