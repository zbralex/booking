{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst path_1 = require(\"path\");\n\nconst q_1 = require(\"q\");\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nlet STACK_SUBSTRINGS_TO_FILTER = ['node_modules/jasmine/', 'node_modules/selenium-webdriver', 'at Module.', 'at Object.Module.', 'at Function.Module', '(timers.js:', 'jasminewd2/index.js', 'protractor/lib/'];\n/**\n * Utility function that filters a stack trace to be more readable. It removes\n * Jasmine test frames and webdriver promise resolution.\n * @param {string} text Original stack trace.\n * @return {string}\n */\n\nfunction filterStackTrace(text) {\n  if (!text) {\n    return text;\n  }\n\n  let lines = text.split(/\\n/).filter(line => {\n    for (let filter of STACK_SUBSTRINGS_TO_FILTER) {\n      if (line.indexOf(filter) !== -1) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n  return lines.join('\\n');\n}\n\nexports.filterStackTrace = filterStackTrace;\n/**\n * Internal helper for abstraction of polymorphic filenameOrFn properties.\n * @param {object} filenameOrFn The filename or function that we will execute.\n * @param {Array.<object>}} args The args to pass into filenameOrFn.\n * @return {q.Promise} A promise that will resolve when filenameOrFn completes.\n */\n\nfunction runFilenameOrFn_(configDir, filenameOrFn, args) {\n  return q_1.Promise(resolvePromise => {\n    if (filenameOrFn && !(typeof filenameOrFn === 'string' || typeof filenameOrFn === 'function')) {\n      throw new Error('filenameOrFn must be a string or function');\n    }\n\n    if (typeof filenameOrFn === 'string') {\n      filenameOrFn = require(path_1.resolve(configDir, filenameOrFn));\n    }\n\n    if (typeof filenameOrFn === 'function') {\n      let results = q_1.when(filenameOrFn.apply(null, args), null, err => {\n        if (typeof err === 'string') {\n          err = new Error(err);\n        } else {\n          err = err;\n\n          if (!err.stack) {\n            err.stack = new Error().stack;\n          }\n        }\n\n        err.stack = exports.filterStackTrace(err.stack);\n        throw err;\n      });\n      resolvePromise(results);\n    } else {\n      resolvePromise(undefined);\n    }\n  });\n}\n\nexports.runFilenameOrFn_ = runFilenameOrFn_;\n/**\n * Joins two logs of test results, each following the format of <framework>.run\n * @param {object} log1\n * @param {object} log2\n * @return {object} The joined log\n */\n\nfunction joinTestLogs(log1, log2) {\n  return {\n    failedCount: log1.failedCount + log2.failedCount,\n    specResults: (log1.specResults || []).concat(log2.specResults || [])\n  };\n}\n\nexports.joinTestLogs = joinTestLogs;\n/**\n * Returns false if an error indicates a missing or stale element, re-throws\n * the error otherwise\n *\n * @param {*} The error to check\n * @throws {*} The error it was passed if it doesn't indicate a missing or stale\n *   element\n * @return {boolean} false, if it doesn't re-throw the error\n */\n\nfunction falseIfMissing(error) {\n  if (error instanceof selenium_webdriver_1.error.NoSuchElementError || error instanceof selenium_webdriver_1.error.StaleElementReferenceError) {\n    return false;\n  } else {\n    throw error;\n  }\n}\n\nexports.falseIfMissing = falseIfMissing;\n/**\n * Return a boolean given boolean value.\n *\n * @param {boolean} value\n * @returns {boolean} given value\n */\n\nfunction passBoolean(value) {\n  return value;\n}\n\nexports.passBoolean = passBoolean; //# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"script"}