{"ast":null,"code":"import * as i1 from '@angular/common';\nimport { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, EventEmitter, Component, ChangeDetectionStrategy, NgZone, PLATFORM_ID, ViewChild, Input, Output, Directive, ContentChildren, NgModule } from '@angular/core';\nimport { __rest } from 'tslib';\nimport { from, fromEvent, throwError, merge, BehaviorSubject, Observable, Subscription } from 'rxjs';\nimport { map, switchMap, take, filter } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"container\"];\nconst _c1 = [\"*\"];\nconst YA_CONFIG = new InjectionToken('YA_CONFIG');\n/**\r\n * The `YaApiLoader` service handles loading of Yandex.Maps API.\r\n *\r\n * @example\r\n * ```ts\r\n * import { YaApiLoaderService } from 'angular8-yandex-maps';\r\n *\r\n * export class AppComponent {\r\n *   constructor(private yaApiLoaderService: YaApiLoaderService) {\r\n *     this.yaApiLoaderService.load()\r\n *       .subscribe(v => console.log(v))\r\n *   }\r\n * }\r\n *```\r\n *\r\n * @dynamic\r\n */\n\nlet YaApiLoaderService = /*#__PURE__*/(() => {\n  class YaApiLoaderService {\n    constructor(config, _document) {\n      this._document = _document;\n      this._defaultConfig = {\n        lang: 'ru_RU'\n      };\n      this._config = Object.assign(Object.assign({}, this._defaultConfig), config);\n    }\n    /**\r\n     * Loads Yandex.Maps API\r\n     */\n\n\n    load() {\n      if (window.ymaps) {\n        return from(ymaps.ready()).pipe(map(() => ymaps));\n      }\n\n      if (!this._script) {\n        const script = this._document.createElement('script');\n\n        script.type = 'text/javascript';\n        script.src = this._getScriptSource(this._config);\n        script.id = 'yandexMapsApiScript';\n        script.async = true;\n        script.defer = true;\n        this._script = this._document.body.appendChild(script);\n      }\n\n      const load = fromEvent(this._script, 'load').pipe(switchMap(() => from(ymaps.ready()).pipe(map(() => ymaps))));\n      const error = fromEvent(this._script, 'error').pipe(switchMap(e => throwError(e)));\n      return merge(load, error).pipe(take(1));\n    }\n    /**\r\n     * Returns script source by config\r\n     * @param config config with parameters that will be added in source\r\n     * @example\r\n     * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'\r\n     * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })\r\n     */\n\n\n    _getScriptSource(config) {\n      const {\n        enterprise,\n        version = '2.1'\n      } = config,\n            rest = __rest(config, [\"enterprise\", \"version\"]);\n\n      const params = this._convertConfigIntoQueryParams(rest);\n\n      return `https://${enterprise ? 'enterprise.' : ''}api-maps.yandex.ru/${version}/?${params}`;\n    }\n    /**\r\n     * Converts a config into a query string parameters\r\n     * @param config object for converting\r\n     * @example\r\n     * // returns \"lang=ru_RU&apikey=XXX\"\r\n     * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })\r\n     */\n\n\n    _convertConfigIntoQueryParams(config) {\n      return Object.entries(config).map(([key, value]) => `${key}=${value}`).join('&');\n    }\n\n  }\n\n  YaApiLoaderService.ɵfac = function YaApiLoaderService_Factory(t) {\n    return new (t || YaApiLoaderService)(ɵngcc0.ɵɵinject(YA_CONFIG, 8), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  YaApiLoaderService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function YaApiLoaderService_Factory() {\n      return new YaApiLoaderService(i0.ɵɵinject(YA_CONFIG, 8), i0.ɵɵinject(i1.DOCUMENT));\n    },\n    token: YaApiLoaderService,\n    providedIn: \"root\"\n  });\n  return YaApiLoaderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Copied from angular/components/google-maps and edited for Yandex Maps API.\r\n * {@link https://github.com/angular/components/blob/master/src/google-maps/map-event-manager.ts}\r\n */\n\n/**\r\n * Manages event on a Yandex Maps object, ensuring that events are added only when necessary.\r\n * @internal\r\n */\n\n\nclass EventManager {\n  constructor(_ngZone) {\n    this._ngZone = _ngZone;\n    /**\r\n     * Listeners that were added before the target was set.\r\n     */\n\n    this._pending = [];\n    this._listeners = [];\n    this._targetStream = new BehaviorSubject(undefined);\n  }\n  /**\r\n   * Gets an observable that adds an event listener to the map when a consumer subscribes to it.\r\n   * @param name\r\n   */\n\n\n  getLazyEmitter(name) {\n    return this._targetStream.pipe(switchMap(target => {\n      const observable = new Observable(observer => {\n        // If the target hasn't been initialized yet, cache the observer so it can be added later.\n        if (!target) {\n          this._pending.push({\n            observable,\n            observer\n          });\n\n          return undefined;\n        }\n\n        const callback = event => {\n          const e = {\n            event,\n            target,\n            ymaps\n          };\n\n          this._ngZone.run(() => observer.next(e));\n        };\n\n        const listener = target.events.add(name, callback);\n\n        this._listeners.push({\n          name,\n          callback,\n          manager: listener\n        }); // Unsubscribe function\n\n\n        return () => listener.remove(name, callback);\n      });\n      return observable;\n    }));\n  }\n  /**\r\n   * Sets the current target that the manager should bind events to.\r\n   * @param target\r\n   */\n\n\n  setTarget(target) {\n    const currentTarget = this._targetStream.value;\n\n    if (target === currentTarget) {\n      return;\n    } // Clear the listeners from the pre-existing target.\n\n\n    if (currentTarget) {\n      this._clearListeners();\n\n      this._pending = [];\n    }\n\n    this._targetStream.next(target); // Add the listeners that were bound before the map was initialized.\n\n\n    this._pending.forEach(subscriber => subscriber.observable.subscribe(subscriber.observer));\n\n    this._pending = [];\n  }\n  /**\r\n   * Destroys the manager and clears the event listeners.\r\n   */\n\n\n  destroy() {\n    this._clearListeners();\n\n    this._pending = [];\n\n    this._targetStream.complete();\n  }\n  /**\r\n   * Clears all currently-registered event listeners.\r\n   */\n\n\n  _clearListeners() {\n    this._listeners.forEach(listener => {\n      const {\n        name,\n        callback,\n        manager\n      } = listener;\n      manager.remove(name, callback);\n    });\n\n    this._listeners = [];\n  }\n\n}\n/**\r\n * Generates a random string based on Date in hexadecimal numeral system\r\n * @example f175517fa4f3\r\n * @internal\r\n */\n\n\nconst generateRandomId = () => {\n  return `f${Number(new Date()).toString(16)}`;\n};\n/**\r\n * The `ya-map` component wraps `ymaps.Map` class from the Yandex Maps API.\r\n * You can configure the map via the component's inputs.\r\n * Events can be bound using the outputs of the component.\r\n *\r\n * <example-url>https://stackblitz.com/edit/map-onload-event?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map\r\n *   [center]=\"[55.751952, 37.600739]\"\r\n *   [state]=\"{type: 'yandex#satellite'}\"\r\n * ></ya-map>\r\n * ```\r\n */\n\n\nlet YaMapComponent = /*#__PURE__*/(() => {\n  class YaMapComponent {\n    constructor(_ngZone, _yaApiLoaderService, platformId) {\n      this._ngZone = _ngZone;\n      this._yaApiLoaderService = _yaApiLoaderService;\n      this._sub = new Subscription();\n      this._eventManager = new EventManager(this._ngZone);\n      this.map$ = new BehaviorSubject(undefined);\n      /**\r\n       * Map instance is created.\r\n       */\n\n      this.ready = new EventEmitter();\n      /**\r\n       * The start of a new smooth map movement.\r\n       */\n\n      this.actionbegin = this._eventManager.getLazyEmitter('actionbegin');\n      /**\r\n       * Event that occurs when an action step was prematurely stopped.\r\n       */\n\n      this.actionbreak = this._eventManager.getLazyEmitter('actionbreak');\n      /**\r\n       * The end of smooth map movement.\r\n       */\n\n      this.actionend = this._eventManager.getLazyEmitter('actionend');\n      /**\r\n       * The start of a new step of smooth movement.\r\n       */\n\n      this.actiontick = this._eventManager.getLazyEmitter('actiontick');\n      /**\r\n       * The end of performing a step of smooth movement.\r\n       */\n\n      this.actiontickcomplete = this._eventManager.getLazyEmitter('actiontickcomplete');\n      /**\r\n       * Closing the balloon.\r\n       */\n\n      this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');\n      /**\r\n       * Opening a balloon on a map.\r\n       */\n\n      this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');\n      /**\r\n       * Event for a change to the map viewport.\r\n       */\n\n      this.boundschange = this._eventManager.getLazyEmitter('boundschange');\n      /**\r\n       * Single left-click on the object.\r\n       */\n\n      this.yaclick = this._eventManager.getLazyEmitter('click');\n      /**\r\n       * Calls the element's context menu.\r\n       */\n\n      this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');\n      /**\r\n       * Double left-click on the object.\r\n       */\n\n      this.yadblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\r\n       * The map was destroyed.\r\n       */\n\n      this.destroy = this._eventManager.getLazyEmitter('destroy');\n      /**\r\n       * Closing the hint.\r\n       */\n\n      this.hintclose = this._eventManager.getLazyEmitter('hintclose');\n      /**\r\n       * Opening a hint on a map.\r\n       */\n\n      this.hintopen = this._eventManager.getLazyEmitter('hintopen');\n      /**\r\n       * Map margins changed.\r\n       */\n\n      this.marginchange = this._eventManager.getLazyEmitter('marginchange');\n      /**\r\n       * Pressing the mouse button over the object.\r\n       */\n\n      this.yamousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\r\n       * Pointing the cursor at the object.\r\n       */\n\n      this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');\n      /**\r\n       * Moving the cursor off of the object.\r\n       */\n\n      this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');\n      /**\r\n       * Moving the cursor over the object.\r\n       */\n\n      this.yamousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\r\n       * Letting go of the mouse button over an object.\r\n       */\n\n      this.yamouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\r\n       * End of multitouch.\r\n       */\n\n      this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');\n      /**\r\n       * Repeating event during multitouch.\r\n       */\n\n      this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');\n      /**\r\n       * Start of multitouch.\r\n       */\n\n      this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');\n      /**\r\n       * Map options changed.\r\n       */\n\n      this.optionschange = this._eventManager.getLazyEmitter('optionschange');\n      /**\r\n       * Map size changed.\r\n       */\n\n      this.sizechange = this._eventManager.getLazyEmitter('sizechange');\n      /**\r\n       * The map type changed.\r\n       */\n\n      this.typechange = this._eventManager.getLazyEmitter('typechange');\n      /**\r\n       * Mouse wheel scrolling.\r\n       */\n\n      this.yawheel = this._eventManager.getLazyEmitter('wheel');\n      this.isBrowser = isPlatformBrowser(platformId);\n    }\n    /**\r\n     * Handles input changes and passes them in API.\r\n     * @param changes\r\n     */\n\n\n    ngOnChanges(changes) {\n      const map = this.map$.value;\n\n      if (map) {\n        const {\n          center,\n          zoom,\n          state,\n          options\n        } = changes;\n\n        if (state) {\n          this._setState(this._combineState(), map);\n        }\n\n        if (center) {\n          map.setCenter(center.currentValue);\n        }\n\n        if (zoom) {\n          map.setZoom(zoom.currentValue);\n        }\n\n        if (options) {\n          map.options.set(options.currentValue);\n        }\n      }\n    }\n\n    ngAfterViewInit() {\n      /**\r\n       * It should be a noop during server-side rendering.\r\n       */\n      if (this.isBrowser) {\n        const sub = this._yaApiLoaderService.load().subscribe(() => {\n          const id = generateRandomId();\n\n          const map = this._createMap(id);\n\n          this.map$.next(map);\n\n          this._eventManager.setTarget(map);\n\n          this._ngZone.run(() => this.ready.emit({\n            ymaps,\n            target: map\n          }));\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      this._eventManager.destroy();\n\n      this._sub.unsubscribe();\n    }\n    /**\r\n     * Destructs state and passes it in API.\r\n     * @param state\r\n     * @param map\r\n     */\n\n\n    _setState(state, map) {\n      const {\n        behaviors,\n        bounds,\n        center,\n        controls,\n        margin,\n        type,\n        zoom\n      } = state;\n\n      if (behaviors) {\n        map.behaviors.enable(behaviors);\n      }\n\n      if (bounds) {\n        map.setBounds(bounds);\n      }\n\n      if (center) {\n        map.setCenter(center);\n      }\n\n      if (controls) {\n        controls.forEach(control => map.controls.add(control));\n      }\n\n      if (margin) {\n        map.margin.setDefaultMargin(margin);\n      }\n\n      if (type) {\n        map.setType(type);\n      }\n\n      if (zoom) {\n        map.setZoom(zoom);\n      }\n    }\n    /**\r\n     * Creates a map.\r\n     * @param id ID which will be set to the map container.\r\n     */\n\n\n    _createMap(id) {\n      const containerElem = this.container.nativeElement;\n      containerElem.setAttribute('id', id);\n      containerElem.style.cssText = 'width: 100%; height: 100%;';\n      return new ymaps.Map(id, this._combineState(), this.options || {});\n    }\n    /**\r\n     * Combines the center and zoom into single object.\r\n     */\n\n\n    _combineState() {\n      var _a, _b;\n\n      const state = this.state || {};\n      return Object.assign(Object.assign({}, state), {\n        center: this.center || state.center || [0, 0],\n        zoom: (_b = (_a = this.zoom) !== null && _a !== void 0 ? _a : state.zoom) !== null && _b !== void 0 ? _b : 10\n      });\n    }\n\n  }\n\n  YaMapComponent.ɵfac = function YaMapComponent_Factory(t) {\n    return new (t || YaMapComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaApiLoaderService), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n\n  YaMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: YaMapComponent,\n    selectors: [[\"ya-map\"]],\n    viewQuery: function YaMapComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 1);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      }\n    },\n    inputs: {\n      center: \"center\",\n      zoom: \"zoom\",\n      state: \"state\",\n      options: \"options\"\n    },\n    outputs: {\n      ready: \"ready\",\n      actionbegin: \"actionbegin\",\n      actionbreak: \"actionbreak\",\n      actionend: \"actionend\",\n      actiontick: \"actiontick\",\n      actiontickcomplete: \"actiontickcomplete\",\n      balloonclose: \"balloonclose\",\n      balloonopen: \"balloonopen\",\n      boundschange: \"boundschange\",\n      yaclick: \"yaclick\",\n      yacontextmenu: \"yacontextmenu\",\n      yadblclick: \"yadblclick\",\n      destroy: \"destroy\",\n      hintclose: \"hintclose\",\n      hintopen: \"hintopen\",\n      marginchange: \"marginchange\",\n      yamousedown: \"yamousedown\",\n      yamouseenter: \"yamouseenter\",\n      yamouseleave: \"yamouseleave\",\n      yamousemove: \"yamousemove\",\n      yamouseup: \"yamouseup\",\n      multitouchend: \"multitouchend\",\n      multitouchmove: \"multitouchmove\",\n      multitouchstart: \"multitouchstart\",\n      optionschange: \"optionschange\",\n      sizechange: \"sizechange\",\n      typechange: \"typechange\",\n      yawheel: \"yawheel\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"container\", \"\"]],\n    template: function YaMapComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", null, 0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return YaMapComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `ya-geoobject` component wraps `ymaps.GeoObject` class from the Yandex Maps API.\r\n * You can configure it via the component's inputs.\r\n * Events can be bound using the outputs of the component.\r\n *\r\n * <example-url>https://stackblitz.com/edit/geoobject-polygon?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map [center]=\"[55.761952, 37.620739]\">\r\n *   <ya-geoobject\r\n *     [feature]=\"{ geometry: { type: 'Rectangle', coordinates: [[55.665, 37.66], [55.64,37.53]] } }\"\r\n *   ></ya-geoobject>\r\n * </ya-map>\r\n * ```\r\n */\n\n\nlet YaGeoObjectDirective = /*#__PURE__*/(() => {\n  class YaGeoObjectDirective {\n    constructor(_ngZone, _yaMapComponent) {\n      this._ngZone = _ngZone;\n      this._yaMapComponent = _yaMapComponent;\n      this._sub = new Subscription();\n      this._eventManager = new EventManager(this._ngZone);\n      /**\r\n       * GeoObject instance is added in a Map.\r\n       */\n\n      this.ready = new EventEmitter();\n      /**\r\n       * Closing the balloon.\r\n       */\n\n      this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');\n      /**\r\n       * Opening a balloon on a map.\r\n       */\n\n      this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');\n      /**\r\n       * Event preceding the \"drag\" event.\r\n       */\n\n      this.beforedrag = this._eventManager.getLazyEmitter('beforedrag');\n      /**\r\n       * Event preceding the \"dragstart\" event.\r\n       */\n\n      this.beforedragstart = this._eventManager.getLazyEmitter('beforedragstart');\n      /**\r\n       * Single left-click on the object.\r\n       */\n\n      this.yaclick = this._eventManager.getLazyEmitter('click');\n      /**\r\n       * Calls the element's context menu.\r\n       */\n\n      this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');\n      /**\r\n       * Double left-click on the object.\r\n       */\n\n      this.yadblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\r\n       * Dragging a geo object.\r\n       */\n\n      this.yadrag = this._eventManager.getLazyEmitter('drag');\n      /**\r\n       * End of geo object dragging.\r\n       */\n\n      this.yadragend = this._eventManager.getLazyEmitter('dragend');\n      /**\r\n       * Start of geo object dragging.\r\n       */\n\n      this.yadragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\r\n       * Change in the state of the editor for the geo object's geometry.\r\n       */\n\n      this.editorstatechange = this._eventManager.getLazyEmitter('editorstatechange');\n      /**\r\n       * Change to the geo object geometry\r\n       */\n\n      this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');\n      /**\r\n       * Closing the hint.\r\n       */\n\n      this.hintclose = this._eventManager.getLazyEmitter('hintclose');\n      /**\r\n       * Opening a hint on a map.\r\n       */\n\n      this.hintopen = this._eventManager.getLazyEmitter('hintopen');\n      /**\r\n       * Map reference changed.\r\n       */\n\n      this.mapchange = this._eventManager.getLazyEmitter('mapchange');\n      /**\r\n       * Pressing the mouse button over the object.\r\n       */\n\n      this.yamousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\r\n       * Pointing the cursor at the object.\r\n       */\n\n      this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');\n      /**\r\n       * Moving the cursor off of the object.\r\n       */\n\n      this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');\n      /**\r\n       * Moving the cursor over the object.\r\n       */\n\n      this.yamousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\r\n       * Letting go of the mouse button over an object.\r\n       */\n\n      this.yamouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\r\n       * End of multitouch.\r\n       */\n\n      this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');\n      /**\r\n       * Repeating event during multitouch.\r\n       */\n\n      this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');\n      /**\r\n       * Start of multitouch.\r\n       */\n\n      this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');\n      /**\r\n       * Change to the object options.\r\n       */\n\n      this.optionschange = this._eventManager.getLazyEmitter('optionschange');\n      /**\r\n       * Change to the geo object overlay.\r\n       */\n\n      this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');\n      /**\r\n       * The parent object reference changed.\r\n       */\n\n      this.parentchange = this._eventManager.getLazyEmitter('parentchange');\n      /**\r\n       * Change to the geo object data.\r\n       */\n\n      this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');\n      /**\r\n       * Mouse wheel scrolling.\r\n       */\n\n      this.yawheel = this._eventManager.getLazyEmitter('wheel');\n    }\n    /**\r\n     * Handles input changes and passes them in API.\r\n     * @param changes\r\n     */\n\n\n    ngOnChanges(changes) {\n      const {\n        geoObject\n      } = this;\n\n      if (geoObject) {\n        const {\n          feature,\n          options\n        } = changes;\n\n        if (feature) {\n          this._setFeature(feature.currentValue, geoObject);\n        }\n\n        if (options) {\n          geoObject.options.set(options.currentValue);\n        }\n      }\n    }\n\n    ngOnInit() {\n      if (this._yaMapComponent.isBrowser) {\n        const sub = this._yaMapComponent.map$.subscribe(map => {\n          if (map) {\n            const geoObject = this._createGeoObject();\n\n            this.geoObject = geoObject;\n            map.geoObjects.add(geoObject);\n\n            this._eventManager.setTarget(geoObject);\n\n            this._ngZone.run(() => this.ready.emit({\n              ymaps,\n              target: geoObject\n            }));\n          }\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      var _a, _b;\n\n      if (this.geoObject) {\n        (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this.geoObject);\n\n        this._eventManager.destroy();\n      }\n\n      this._sub.unsubscribe();\n    }\n    /**\r\n     * Destructs feature and passes it in API.\r\n     * @param feature\r\n     * @param geoObject\r\n     */\n\n\n    _setFeature(feature, geoObject) {\n      const {\n        geometry,\n        properties\n      } = feature;\n\n      if (geometry) {\n        console.warn('The geometry can not be changed after entity init. To set it, you should recreate a GeoObject with new feature.geometry');\n      }\n\n      if (properties) {\n        geoObject.properties.set(properties);\n      }\n    }\n    /**\r\n     * Creates GeoObject.\r\n     */\n\n\n    _createGeoObject() {\n      return new ymaps.GeoObject(this.feature, this.options);\n    }\n\n  }\n\n  YaGeoObjectDirective.ɵfac = function YaGeoObjectDirective_Factory(t) {\n    return new (t || YaGeoObjectDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaMapComponent));\n  };\n\n  YaGeoObjectDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: YaGeoObjectDirective,\n    selectors: [[\"ya-geoobject\"]],\n    inputs: {\n      feature: \"feature\",\n      options: \"options\"\n    },\n    outputs: {\n      ready: \"ready\",\n      balloonclose: \"balloonclose\",\n      balloonopen: \"balloonopen\",\n      beforedrag: \"beforedrag\",\n      beforedragstart: \"beforedragstart\",\n      yaclick: \"yaclick\",\n      yacontextmenu: \"yacontextmenu\",\n      yadblclick: \"yadblclick\",\n      yadrag: \"yadrag\",\n      yadragend: \"yadragend\",\n      yadragstart: \"yadragstart\",\n      editorstatechange: \"editorstatechange\",\n      geometrychange: \"geometrychange\",\n      hintclose: \"hintclose\",\n      hintopen: \"hintopen\",\n      mapchange: \"mapchange\",\n      yamousedown: \"yamousedown\",\n      yamouseenter: \"yamouseenter\",\n      yamouseleave: \"yamouseleave\",\n      yamousemove: \"yamousemove\",\n      yamouseup: \"yamouseup\",\n      multitouchend: \"multitouchend\",\n      multitouchmove: \"multitouchmove\",\n      multitouchstart: \"multitouchstart\",\n      optionschange: \"optionschange\",\n      overlaychange: \"overlaychange\",\n      parentchange: \"parentchange\",\n      propertieschange: \"propertieschange\",\n      yawheel: \"yawheel\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return YaGeoObjectDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `ya-placemark` directive wraps `ymaps.Placemark` class from the Yandex Maps API.\r\n * You can configure it via the directive's inputs.\r\n * Events can be bound using the outputs of the directive.\r\n *\r\n * <example-url>https://stackblitz.com/edit/custom-placemark?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map [center]=\"[55.751952, 37.600739]\">\r\n *   <ya-placemark [geometry]=\"[55.751952, 37.600739]\"></ya-placemark>\r\n * </ya-map>\r\n * ```\r\n */\n\n\nlet YaPlacemarkDirective = /*#__PURE__*/(() => {\n  class YaPlacemarkDirective {\n    constructor(_ngZone, _yaMapComponent) {\n      this._ngZone = _ngZone;\n      this._yaMapComponent = _yaMapComponent;\n      this._sub = new Subscription();\n      this._eventManager = new EventManager(this._ngZone);\n      /**\r\n       * Placemark instance is added in a Map.\r\n       */\n\n      this.ready = new EventEmitter();\n      /**\r\n       * Closing the balloon.\r\n       */\n\n      this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');\n      /**\r\n       * Opening a balloon on a map.\r\n       */\n\n      this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');\n      /**\r\n       * Event preceding the \"drag\" event.\r\n       */\n\n      this.beforedrag = this._eventManager.getLazyEmitter('beforedrag');\n      /**\r\n       * Event preceding the \"dragstart\" event.\r\n       */\n\n      this.beforedragstart = this._eventManager.getLazyEmitter('beforedragstart');\n      /**\r\n       * Single left-click on the object.\r\n       */\n\n      this.yaclick = this._eventManager.getLazyEmitter('click');\n      /**\r\n       * Calls the element's context menu.\r\n       */\n\n      this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');\n      /**\r\n       * Double left-click on the object.\r\n       */\n\n      this.yadblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\r\n       * Dragging a geo object.\r\n       */\n\n      this.yadrag = this._eventManager.getLazyEmitter('drag');\n      /**\r\n       * End of geo object dragging.\r\n       */\n\n      this.yadragend = this._eventManager.getLazyEmitter('dragend');\n      /**\r\n       * Start of geo object dragging.\r\n       */\n\n      this.yadragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\r\n       * Change in the state of the editor for the geo object's geometry.\r\n       */\n\n      this.editorstatechange = this._eventManager.getLazyEmitter('editorstatechange');\n      /**\r\n       * Change to the geo object geometry\r\n       */\n\n      this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');\n      /**\r\n       * Closing the hint.\r\n       */\n\n      this.hintclose = this._eventManager.getLazyEmitter('hintclose');\n      /**\r\n       * Opening a hint on a map.\r\n       */\n\n      this.hintopen = this._eventManager.getLazyEmitter('hintopen');\n      /**\r\n       * Map reference changed.\r\n       */\n\n      this.mapchange = this._eventManager.getLazyEmitter('mapchange');\n      /**\r\n       * Pressing the mouse button over the object.\r\n       */\n\n      this.yamousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\r\n       * Pointing the cursor at the object.\r\n       */\n\n      this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');\n      /**\r\n       * Moving the cursor off of the object.\r\n       */\n\n      this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');\n      /**\r\n       * Moving the cursor over the object.\r\n       */\n\n      this.yamousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\r\n       * Letting go of the mouse button over an object.\r\n       */\n\n      this.yamouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\r\n       * End of multitouch.\r\n       */\n\n      this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');\n      /**\r\n       * Repeating event during multitouch.\r\n       */\n\n      this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');\n      /**\r\n       * Start of multitouch.\r\n       */\n\n      this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');\n      /**\r\n       * Change to the object options.\r\n       */\n\n      this.optionschange = this._eventManager.getLazyEmitter('optionschange');\n      /**\r\n       * Change to the geo object overlay.\r\n       */\n\n      this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');\n      /**\r\n       * The parent object reference changed.\r\n       */\n\n      this.parentchange = this._eventManager.getLazyEmitter('parentchange');\n      /**\r\n       * Change to the geo object data.\r\n       */\n\n      this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');\n      /**\r\n       * Mouse wheel scrolling.\r\n       */\n\n      this.yawheel = this._eventManager.getLazyEmitter('wheel');\n    }\n    /**\r\n     * Handles input changes and passes them in API.\r\n     * @param changes\r\n     */\n\n\n    ngOnChanges(changes) {\n      var _a;\n\n      const {\n        placemark\n      } = this;\n\n      if (placemark) {\n        const {\n          geometry,\n          properties,\n          options\n        } = changes;\n\n        if (geometry) {\n          (_a = placemark.geometry) === null || _a === void 0 ? void 0 : _a.setCoordinates(geometry.currentValue);\n        }\n\n        if (properties) {\n          placemark.properties.set(properties.currentValue);\n        }\n\n        if (options) {\n          placemark.options.set(options.currentValue);\n        }\n      }\n    }\n\n    ngOnInit() {\n      if (this._yaMapComponent.isBrowser) {\n        const sub = this._yaMapComponent.map$.subscribe(map => {\n          if (map) {\n            const placemark = this._createPlacemark();\n\n            this.placemark = placemark;\n            map.geoObjects.add(placemark);\n\n            this._eventManager.setTarget(placemark);\n\n            this._ngZone.run(() => this.ready.emit({\n              ymaps,\n              target: placemark\n            }));\n          }\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      var _a, _b;\n\n      if (this.placemark) {\n        (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this.placemark);\n\n        this._eventManager.destroy();\n      }\n\n      this._sub.unsubscribe();\n    }\n    /**\r\n     * Creates a placemark.\r\n     */\n\n\n    _createPlacemark() {\n      return new ymaps.Placemark(this.geometry, this.properties, this.options);\n    }\n\n  }\n\n  YaPlacemarkDirective.ɵfac = function YaPlacemarkDirective_Factory(t) {\n    return new (t || YaPlacemarkDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaMapComponent));\n  };\n\n  YaPlacemarkDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: YaPlacemarkDirective,\n    selectors: [[\"ya-placemark\"]],\n    inputs: {\n      geometry: \"geometry\",\n      properties: \"properties\",\n      options: \"options\"\n    },\n    outputs: {\n      ready: \"ready\",\n      balloonclose: \"balloonclose\",\n      balloonopen: \"balloonopen\",\n      beforedrag: \"beforedrag\",\n      beforedragstart: \"beforedragstart\",\n      yaclick: \"yaclick\",\n      yacontextmenu: \"yacontextmenu\",\n      yadblclick: \"yadblclick\",\n      yadrag: \"yadrag\",\n      yadragend: \"yadragend\",\n      yadragstart: \"yadragstart\",\n      editorstatechange: \"editorstatechange\",\n      geometrychange: \"geometrychange\",\n      hintclose: \"hintclose\",\n      hintopen: \"hintopen\",\n      mapchange: \"mapchange\",\n      yamousedown: \"yamousedown\",\n      yamouseenter: \"yamouseenter\",\n      yamouseleave: \"yamouseleave\",\n      yamousemove: \"yamousemove\",\n      yamouseup: \"yamouseup\",\n      multitouchend: \"multitouchend\",\n      multitouchmove: \"multitouchmove\",\n      multitouchstart: \"multitouchstart\",\n      optionschange: \"optionschange\",\n      overlaychange: \"overlaychange\",\n      parentchange: \"parentchange\",\n      propertieschange: \"propertieschange\",\n      yawheel: \"yawheel\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return YaPlacemarkDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `ya-clusterer` component wraps `ymaps.Clusterer` class from the Yandex Maps API.\r\n * You can configure it via the component's inputs.\r\n * Events can be bound using the outputs of the component.\r\n *\r\n * <example-url>https://stackblitz.com/edit/placemark-clusterer?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map [center]=\"[55.761952, 37.620739]\">\r\n *   <ya-clusterer [options]=\"{ minClusterSize: 5 }\">\r\n *     <ya-placemark [geometry]=\"[55.74, 37.5]\"></ya-placemark>\r\n *     <ya-placemark [geometry]=\"[55.64, 37.46]\"></ya-placemark>\r\n *     <ya-placemark [geometry]=\"[55.75, 37.38]\"></ya-placemark>\r\n *\r\n *     <ya-geoobject\r\n *       [feature]=\"{ geometry: { type: 'Point', coordinates: [55.81, 37.4] } }\"\r\n *      ></ya-geoobject>\r\n *\r\n *     <ya-geoobject\r\n *       [feature]=\"{ geometry: { type: 'Point', coordinates: [55.7, 37.39] } }\"\r\n *      ></ya-geoobject>\r\n *   </ya-clusterer>\r\n * </ya-map>\r\n * ```\r\n */\n\n\nlet YaClustererComponent = /*#__PURE__*/(() => {\n  class YaClustererComponent {\n    constructor(_ngZone, _yaMapComponent) {\n      this._ngZone = _ngZone;\n      this._yaMapComponent = _yaMapComponent;\n      this._sub = new Subscription();\n      this._eventManager = new EventManager(this._ngZone);\n      /**\r\n       * Clusterer instance is added in a Map.\r\n       */\n\n      this.ready = new EventEmitter();\n      /**\r\n       * Closing the hint.\r\n       */\n\n      this.hintclose = this._eventManager.getLazyEmitter('hintclose');\n      /**\r\n       * Opening a hint on a map.\r\n       */\n\n      this.hintopen = this._eventManager.getLazyEmitter('hintopen');\n      /**\r\n       * Map reference changed.\r\n       */\n\n      this.mapchange = this._eventManager.getLazyEmitter('mapchange');\n      /**\r\n       * Change to the object options.\r\n       */\n\n      this.optionschange = this._eventManager.getLazyEmitter('optionschange');\n      /**\r\n       * The parent object reference changed.\r\n       */\n\n      this.parentchange = this._eventManager.getLazyEmitter('parentchange');\n    }\n    /**\r\n     * Handles input changes and passes them in API.\r\n     * @param changes\r\n     */\n\n\n    ngOnChanges(changes) {\n      const clusterer = this._clusterer;\n\n      if (clusterer) {\n        const {\n          options\n        } = changes;\n\n        if (options) {\n          clusterer.options.set(options.currentValue);\n        }\n      }\n    }\n\n    ngAfterContentInit() {\n      if (this._yaMapComponent.isBrowser) {\n        const sub = this._yaMapComponent.map$.subscribe(map => {\n          if (map) {\n            const clusterer = this._createClusterer();\n\n            this._clusterer = clusterer;\n            map.geoObjects.add(clusterer);\n\n            this._eventManager.setTarget(clusterer);\n\n            this._watchForContentChanges(clusterer);\n\n            this._ngZone.run(() => this.ready.emit({\n              ymaps,\n              target: clusterer\n            }));\n          }\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      this._eventManager.destroy();\n\n      this._sub.unsubscribe();\n    }\n    /**\r\n     * Creates Clusterer.\r\n     */\n\n\n    _createClusterer() {\n      return new ymaps.Clusterer(this.options);\n    }\n\n    _watchForContentChanges(clusterer) {\n      /**\r\n       * Adds new Placemarks to the clusterer on changes.\r\n       */\n      const currentPlacemarks = new Set();\n\n      this._getInternalPlacemarks(this._placemarks.toArray()).forEach(placemark => {\n        currentPlacemarks.add(placemark);\n        clusterer.add(placemark);\n      });\n\n      const placemarksSub = this._placemarks.changes.subscribe(placemarkDirectives => {\n        const newPlacemarks = new Set(this._getInternalPlacemarks(placemarkDirectives));\n\n        const difference = this._getDifference(newPlacemarks, currentPlacemarks);\n\n        clusterer.add(difference.toAdd);\n        clusterer.remove(difference.toRemove);\n      });\n\n      this._sub.add(placemarksSub);\n      /**\r\n       * Adds new GeoObjects to the clusterer on changes.\r\n       */\n\n\n      const currentGeoObjects = new Set();\n\n      this._getInternalGeoObjects(this._geoObjects.toArray()).forEach(geoObject => {\n        currentGeoObjects.add(geoObject);\n        clusterer.add(geoObject);\n      });\n\n      const geoObjectsSub = this._geoObjects.changes.subscribe(geoObjectDirectives => {\n        const newGeoObjects = new Set(this._getInternalGeoObjects(geoObjectDirectives));\n\n        const difference = this._getDifference(newGeoObjects, currentGeoObjects);\n\n        clusterer.add(difference.toAdd);\n        clusterer.remove(difference.toRemove);\n      });\n\n      this._sub.add(geoObjectsSub);\n    }\n    /**\r\n     * Determines what should be added/removed in current set to equal new set\r\n     *\r\n     * @param newSet\r\n     * @param currentSet\r\n     */\n\n\n    _getDifference(newSet, currentSet) {\n      const toAdd = [];\n      const toRemove = [];\n      newSet.forEach(component => {\n        if (!currentSet.has(component)) {\n          toAdd.push(component);\n          currentSet.add(component);\n        }\n      });\n      currentSet.forEach(component => {\n        if (!newSet.has(component)) {\n          toRemove.push(component);\n          currentSet.delete(component);\n        }\n      });\n      return {\n        toAdd,\n        toRemove\n      };\n    }\n\n    _getInternalPlacemarks(placemarks) {\n      return placemarks.filter(component => !!component.placemark).map(component => component.placemark);\n    }\n\n    _getInternalGeoObjects(geoObjects) {\n      return geoObjects.filter(component => !!component.geoObject).map(component => component.geoObject);\n    }\n\n  }\n\n  YaClustererComponent.ɵfac = function YaClustererComponent_Factory(t) {\n    return new (t || YaClustererComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaMapComponent));\n  };\n\n  YaClustererComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: YaClustererComponent,\n    selectors: [[\"ya-clusterer\"]],\n    contentQueries: function YaClustererComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, YaPlacemarkDirective, 0);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, YaGeoObjectDirective, 0);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._placemarks = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._geoObjects = _t);\n      }\n    },\n    inputs: {\n      options: \"options\"\n    },\n    outputs: {\n      ready: \"ready\",\n      hintclose: \"hintclose\",\n      hintopen: \"hintopen\",\n      mapchange: \"mapchange\",\n      optionschange: \"optionschange\",\n      parentchange: \"parentchange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function YaClustererComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return YaClustererComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `ya-control` component wraps `ymaps.control[YaControlType]` classes from the Yandex Maps API.\r\n * You can configure `ymaps.control[YaControlType]` via the component's inputs.\r\n * API Events can be bound only manually. You can use `ready` event to get an instance.\r\n *\r\n * <example-url>https://stackblitz.com/edit/searchcontrol?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map [center]=\"[55.761952, 37.620739]\">\r\n *   <ya-control\r\n *     type=\"RoutePanel\"\r\n *     [parameters]=\"{ options: { float: 'right' } }\"\r\n *   ></ya-control>\r\n * </ya-map>\r\n * ```\r\n */\n\n\nlet YaControlDirective = /*#__PURE__*/(() => {\n  class YaControlDirective {\n    constructor(_ngZone, _yaMapComponent) {\n      this._ngZone = _ngZone;\n      this._yaMapComponent = _yaMapComponent;\n      this._sub = new Subscription();\n      /**\r\n       * Control instance is added in a Map.\r\n       */\n\n      this.ready = new EventEmitter();\n    }\n\n    ngOnChanges() {\n      if (this._control) {\n        console.warn('Control does not support dynamic configuration. You can config it manually using ymaps or recreate the component with new configuration');\n      }\n    }\n\n    ngOnInit() {\n      if (this._yaMapComponent.isBrowser) {\n        const sub = this._yaMapComponent.map$.subscribe(map => {\n          if (map) {\n            const control = new ymaps.control[this.type](this.parameters);\n            this._control = control;\n            /**\r\n             * RoutePanel ignores state in parameters. API bug\r\n             */\n\n            if (control instanceof ymaps.control.RoutePanel && this.parameters && this.parameters.state) {\n              control.routePanel.state.set(Object.assign({}, this.parameters.state));\n            }\n\n            map.controls.add(control);\n\n            this._ngZone.run(() => this.ready.emit({\n              ymaps,\n              target: control\n            }));\n          }\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      var _a, _b;\n\n      if (this._control) {\n        (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.controls.remove(this._control);\n      }\n    }\n\n  }\n\n  YaControlDirective.ɵfac = function YaControlDirective_Factory(t) {\n    return new (t || YaControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaMapComponent));\n  };\n\n  YaControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: YaControlDirective,\n    selectors: [[\"ya-control\"]],\n    inputs: {\n      type: \"type\",\n      parameters: \"parameters\"\n    },\n    outputs: {\n      ready: \"ready\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return YaControlDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `ya-multiroute` component wraps `ymaps.multiRouter.MultiRoute` class from the Yandex Maps API.\r\n * You can configure it via the component's inputs.\r\n * Events can be bound using the outputs of the component.\r\n *\r\n * <example-url>https://stackblitz.com/edit/multiroute-pedestrian?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map [center]=\"[55.761952, 37.620739]\">\r\n *   <ya-multiroute\r\n *     [referencePoints]=\"[[55.751952, 37.600739], 'Красные ворота, Москва']\"\r\n *     [model]=\"{ params: { routingMode: 'pedestrian' } }\"\r\n *   ></ya-multiroute>\r\n * </ya-map>\r\n * ```\r\n */\n\n\nlet YaMultirouteDirective = /*#__PURE__*/(() => {\n  class YaMultirouteDirective {\n    constructor(_ngZone, _yaMapComponent) {\n      this._ngZone = _ngZone;\n      this._yaMapComponent = _yaMapComponent;\n      this._sub = new Subscription();\n      this._eventManager = new EventManager(this._ngZone);\n      /**\r\n       * Multiroute instance is added in a Map.\r\n       */\n\n      this.ready = new EventEmitter();\n      /**\r\n       * Change to the active route.\r\n       */\n\n      this.activeroutechange = this._eventManager.getLazyEmitter('activeroutechange');\n      /**\r\n       * Closing the balloon.\r\n       */\n\n      this.balloonclose = this._eventManager.getLazyEmitter('balloonclose');\n      /**\r\n       * Opening a balloon on a map.\r\n       */\n\n      this.balloonopen = this._eventManager.getLazyEmitter('balloonopen');\n      /**\r\n       * The event occurs at the time of setting the map center and its zoom level for optimal display of the multi-route.\r\n       */\n\n      this.boundsautoapply = this._eventManager.getLazyEmitter('boundsautoapply');\n      /**\r\n       * Changing coordinates of the geographical area covering the multi-route.\r\n       */\n\n      this.boundschange = this._eventManager.getLazyEmitter('boundschange');\n      /**\r\n       * Single left-click on the object.\r\n       */\n\n      this.yaclick = this._eventManager.getLazyEmitter('click');\n      /**\r\n       * Calls the element's context menu.\r\n       */\n\n      this.yacontextmenu = this._eventManager.getLazyEmitter('contextmenu');\n      /**\r\n       * Double left-click on the object.\r\n       */\n\n      this.yadblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\r\n       * Change to the geo object geometry.\r\n       */\n\n      this.geometrychange = this._eventManager.getLazyEmitter('geometrychange');\n      /**\r\n       * Map reference changed.\r\n       */\n\n      this.mapchange = this._eventManager.getLazyEmitter('mapchange');\n      /**\r\n       * Pressing the mouse button over the object.\r\n       */\n\n      this.yamousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\r\n       * Pointing the cursor at the object.\r\n       */\n\n      this.yamouseenter = this._eventManager.getLazyEmitter('mouseenter');\n      /**\r\n       * Moving the cursor off of the object.\r\n       */\n\n      this.yamouseleave = this._eventManager.getLazyEmitter('mouseleave');\n      /**\r\n       * Moving the cursor over the object.\r\n       */\n\n      this.yamousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\r\n       * Letting go of the mouse button over an object.\r\n       */\n\n      this.yamouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\r\n       * End of multitouch.\r\n       */\n\n      this.multitouchend = this._eventManager.getLazyEmitter('multitouchend');\n      /**\r\n       * Repeating event during multitouch.\r\n       */\n\n      this.multitouchmove = this._eventManager.getLazyEmitter('multitouchmove');\n      /**\r\n       * Start of multitouch.\r\n       */\n\n      this.multitouchstart = this._eventManager.getLazyEmitter('multitouchstart');\n      /**\r\n       * Change to the object options.\r\n       */\n\n      this.optionschange = this._eventManager.getLazyEmitter('optionschange');\n      /**\r\n       * Change to the geo object overlay.\r\n       */\n\n      this.overlaychange = this._eventManager.getLazyEmitter('overlaychange');\n      /**\r\n       * The parent object reference changed.\r\n       */\n\n      this.parentchange = this._eventManager.getLazyEmitter('parentchange');\n      /**\r\n       * Changing pixel coordinates of the area covering the multi-route.\r\n       */\n\n      this.pixelboundschange = this._eventManager.getLazyEmitter('pixelboundschange');\n      /**\r\n       * Change to the geo object data.\r\n       */\n\n      this.propertieschange = this._eventManager.getLazyEmitter('propertieschange');\n      /**\r\n       * Updating the multi-route.\r\n       */\n\n      this.update = this._eventManager.getLazyEmitter('update');\n      /**\r\n       * Mouse wheel scrolling.\r\n       */\n\n      this.yawheel = this._eventManager.getLazyEmitter('wheel');\n    }\n    /**\r\n     * Handles input changes and passes them in API.\r\n     * @param changes\r\n     */\n\n\n    ngOnChanges(changes) {\n      const multiroute = this._multiroute;\n\n      if (multiroute) {\n        const {\n          referencePoints,\n          model,\n          options\n        } = changes;\n\n        if (model) {\n          this._setModel(model.currentValue, multiroute);\n        }\n\n        if (referencePoints) {\n          multiroute.model.setReferencePoints(referencePoints.currentValue);\n        }\n\n        if (options) {\n          multiroute.options.set(options.currentValue);\n        }\n      }\n    }\n\n    ngOnInit() {\n      if (this._yaMapComponent.isBrowser) {\n        const sub = this._yaMapComponent.map$.subscribe(map => {\n          if (map) {\n            const multiroute = this._createMultiroute();\n\n            this._multiroute = multiroute;\n            map.geoObjects.add(multiroute);\n\n            this._eventManager.setTarget(multiroute);\n\n            this._ngZone.run(() => this.ready.emit({\n              ymaps,\n              target: multiroute\n            }));\n          }\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      var _a, _b;\n\n      if (this._multiroute) {\n        (_b = (_a = this._yaMapComponent) === null || _a === void 0 ? void 0 : _a.map$.value) === null || _b === void 0 ? void 0 : _b.geoObjects.remove(this._multiroute);\n\n        this._eventManager.destroy();\n      }\n\n      this._sub.unsubscribe();\n    }\n    /**\r\n     * Destructs state and passes them in API.\r\n     * @param model\r\n     * @param multiroute\r\n     */\n\n\n    _setModel(model, multiroute) {\n      const {\n        referencePoints,\n        params\n      } = model;\n\n      if (referencePoints) {\n        multiroute.model.setReferencePoints(referencePoints);\n      }\n\n      if (params) {\n        multiroute.model.setParams(params);\n      }\n    }\n    /**\r\n     * Creates Multiroute.\r\n     */\n\n\n    _createMultiroute() {\n      return new ymaps.multiRouter.MultiRoute(this._combineModel(), this.options);\n    }\n    /**\r\n     * Combines the model and reference points into single object\r\n     */\n\n\n    _combineModel() {\n      const model = this.model || {};\n      return Object.assign(Object.assign({}, model), {\n        referencePoints: this.referencePoints || model.referencePoints\n      });\n    }\n\n  }\n\n  YaMultirouteDirective.ɵfac = function YaMultirouteDirective_Factory(t) {\n    return new (t || YaMultirouteDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaMapComponent));\n  };\n\n  YaMultirouteDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: YaMultirouteDirective,\n    selectors: [[\"ya-multiroute\"]],\n    inputs: {\n      referencePoints: \"referencePoints\",\n      model: \"model\",\n      options: \"options\"\n    },\n    outputs: {\n      ready: \"ready\",\n      activeroutechange: \"activeroutechange\",\n      balloonclose: \"balloonclose\",\n      balloonopen: \"balloonopen\",\n      boundsautoapply: \"boundsautoapply\",\n      boundschange: \"boundschange\",\n      yaclick: \"yaclick\",\n      yacontextmenu: \"yacontextmenu\",\n      yadblclick: \"yadblclick\",\n      geometrychange: \"geometrychange\",\n      mapchange: \"mapchange\",\n      yamousedown: \"yamousedown\",\n      yamouseenter: \"yamouseenter\",\n      yamouseleave: \"yamouseleave\",\n      yamousemove: \"yamousemove\",\n      yamouseup: \"yamouseup\",\n      multitouchend: \"multitouchend\",\n      multitouchmove: \"multitouchmove\",\n      multitouchstart: \"multitouchstart\",\n      optionschange: \"optionschange\",\n      overlaychange: \"overlaychange\",\n      parentchange: \"parentchange\",\n      pixelboundschange: \"pixelboundschange\",\n      propertieschange: \"propertieschange\",\n      update: \"update\",\n      yawheel: \"yawheel\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return YaMultirouteDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `ya-panorama` component wraps `ymaps.panorama.Player` class from the Yandex Maps API.\r\n * You can configure it via the component's inputs.\r\n * Events can be bound using the outputs of the component.\r\n *\r\n * <example-url>https://stackblitz.com/edit/panorama?embed=1</example-url>\r\n *\r\n * @example\r\n * ```html\r\n * <ya-map>\r\n *   <ya-panorama [point]=\"[59.938557, 30.316198]\" layer=\"yandex#airPanorama\"></ya-panorama>\r\n * </ya-map>\r\n * ```\r\n */\n\n\nlet YaPanoramaDirective = /*#__PURE__*/(() => {\n  class YaPanoramaDirective {\n    constructor(_ngZone, _yaMapComponent) {\n      this._ngZone = _ngZone;\n      this._yaMapComponent = _yaMapComponent;\n      this._sub = new Subscription();\n      this._eventManager = new EventManager(this._ngZone);\n      /**\r\n       * Panorama instance is created.\r\n       */\n\n      this.ready = new EventEmitter();\n      /**\r\n       * The player was closed by the user or destroyed using the panorama.Player.destroy method.\r\n       */\n\n      this.destroy = this._eventManager.getLazyEmitter('destroy');\n      /**\r\n       * The view direction changed.\r\n       */\n\n      this.directionchange = this._eventManager.getLazyEmitter('directionchange');\n      /**\r\n       * An error occurred during operation of the player. The user will be shown the appropriate screen.\r\n       */\n\n      this.yaerror = this._eventManager.getLazyEmitter('error');\n      /**\r\n       * The panorama player switched to full-screen mode.\r\n       */\n\n      this.fullscreenenter = this._eventManager.getLazyEmitter('fullscreenenter');\n      /**\r\n       * The panorama player exited full-screen mode.\r\n       */\n\n      this.fullscreenexit = this._eventManager.getLazyEmitter('fullscreenexit');\n      /**\r\n       * The user clicked on an expanded marker.\r\n       */\n\n      this.markercollapse = this._eventManager.getLazyEmitter('markercollapse');\n      /**\r\n       * The user clicked on a collapsed marker.\r\n       */\n\n      this.markerexpand = this._eventManager.getLazyEmitter('markerexpand');\n      /**\r\n       * The user's cursor hovered over a marker.\r\n       */\n\n      this.markermouseenter = this._eventManager.getLazyEmitter('markermouseenter');\n      /**\r\n       * The user's cursor left a marker.\r\n       */\n\n      this.markermouseleave = this._eventManager.getLazyEmitter('markermouseleave');\n      /**\r\n       * The open panorama changed.\r\n       */\n\n      this.panoramachange = this._eventManager.getLazyEmitter('panoramachange');\n      /**\r\n       * The size of the viewport has been changed.\r\n       */\n\n      this.spanchange = this._eventManager.getLazyEmitter('spanchange');\n    }\n    /**\r\n     * Handles input changes and passes them in API.\r\n     * @param changes\r\n     */\n\n\n    ngOnChanges(changes) {\n      const player = this._player;\n\n      if (player) {\n        const {\n          point,\n          layer,\n          options\n        } = changes;\n        /**\r\n         * player.moveTo resets values to default if any of them isn't passed.\r\n         * That's why we use value from currentValue OR previous value from input.\r\n         * With that logic it's possible to pass only point, layer or options.\r\n         */\n\n        if (point || layer) {\n          const combinedPoint = (point === null || point === void 0 ? void 0 : point.currentValue) || this.point;\n          const combinedLayer = (layer === null || layer === void 0 ? void 0 : layer.currentValue) || this.layer;\n          player.moveTo(combinedPoint, {\n            layer: combinedLayer\n          });\n        }\n\n        if (options) {\n          this._setOptions(options.currentValue, player);\n        }\n      }\n    }\n\n    ngOnInit() {\n      if (this._yaMapComponent.isBrowser) {\n        const panorama$ = this._yaMapComponent.map$.pipe(filter(m => Boolean(m)), switchMap(m => {\n          /**\r\n           * Map and panorama use the same container, so need to destroy/remove map\r\n           */\n          m.destroy();\n          return this._createPanorama();\n        }));\n\n        const sub = panorama$.subscribe(panorama => {\n          const {\n            id\n          } = this._yaMapComponent.container.nativeElement;\n          const player = new ymaps.panorama.Player(id, panorama, this.options);\n          this._player = player;\n\n          this._eventManager.setTarget(player);\n\n          this._ngZone.run(() => this.ready.emit({\n            ymaps,\n            target: player\n          }));\n        });\n\n        this._sub.add(sub);\n      }\n    }\n\n    ngOnDestroy() {\n      this._eventManager.destroy();\n\n      this._sub.unsubscribe();\n    }\n    /**\r\n     * Destructs state and passes it in API.\r\n     * @param options\r\n     * @param player\r\n     */\n\n\n    _setOptions(options, player) {\n      const {\n        autoFitToViewport,\n        controls,\n        direction,\n        hotkeysEnabled,\n        span,\n        scrollZoomBehavior,\n        suppressMapOpenBlock\n      } = options;\n\n      if (autoFitToViewport || controls || hotkeysEnabled || scrollZoomBehavior || suppressMapOpenBlock) {\n        console.warn('Only direction and span can be set after entity init. To set other options, you should recreate a Panorama with new options');\n      }\n\n      if (direction) {\n        player.setDirection(direction);\n      }\n\n      if (span) {\n        player.setSpan(span);\n      }\n    }\n    /**\r\n     * Searches for a panorama and returns first\r\n     */\n\n\n    _createPanorama() {\n      return from(ymaps.panorama.locate(this.point, {\n        layer: this.layer\n      })).pipe(map(panoramas => panoramas[0]));\n    }\n\n  }\n\n  YaPanoramaDirective.ɵfac = function YaPanoramaDirective_Factory(t) {\n    return new (t || YaPanoramaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(YaMapComponent));\n  };\n\n  YaPanoramaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: YaPanoramaDirective,\n    selectors: [[\"ya-panorama\"]],\n    inputs: {\n      point: \"point\",\n      layer: \"layer\",\n      options: \"options\"\n    },\n    outputs: {\n      ready: \"ready\",\n      destroy: \"destroy\",\n      directionchange: \"directionchange\",\n      yaerror: \"yaerror\",\n      fullscreenenter: \"fullscreenenter\",\n      fullscreenexit: \"fullscreenexit\",\n      markercollapse: \"markercollapse\",\n      markerexpand: \"markerexpand\",\n      markermouseenter: \"markermouseenter\",\n      markermouseleave: \"markermouseleave\",\n      panoramachange: \"panoramachange\",\n      spanchange: \"spanchange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return YaPanoramaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularYandexMapsModule = /*#__PURE__*/(() => {\n  class AngularYandexMapsModule {\n    /**\r\n     * Please use this method when you register the module at the root level\r\n     * @param config\r\n     */\n    static forRoot(config) {\n      return {\n        ngModule: AngularYandexMapsModule,\n        providers: [{\n          provide: YA_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  AngularYandexMapsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: AngularYandexMapsModule\n  });\n  AngularYandexMapsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function AngularYandexMapsModule_Factory(t) {\n      return new (t || AngularYandexMapsModule)();\n    },\n    imports: [[CommonModule]]\n  });\n  return AngularYandexMapsModule;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AngularYandexMapsModule, {\n    declarations: function () {\n      return [YaClustererComponent, YaControlDirective, YaGeoObjectDirective, YaMapComponent, YaMultirouteDirective, YaPanoramaDirective, YaPlacemarkDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [YaClustererComponent, YaControlDirective, YaGeoObjectDirective, YaMapComponent, YaMultirouteDirective, YaPanoramaDirective, YaPlacemarkDirective];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex Maps API.\r\n *\r\n * @example\r\n * ```ts\r\n * import { YaGeocoderService } from 'angular8-yandex-maps';\r\n *\r\n * export class AppComponent {\r\n *   constructor(private yaGeocoderService: YaGeocoderService) {\r\n *     this.yaGeocoderService.geocode('Moscow')\r\n *       .subscribe(v => console.log(v))\r\n *   }\r\n * }\r\n * ```\r\n */\n\n\nlet YaGeocoderService = /*#__PURE__*/(() => {\n  class YaGeocoderService {\n    constructor(_ngZone, _yaApiLoaderService) {\n      this._ngZone = _ngZone;\n      this._yaApiLoaderService = _yaApiLoaderService;\n    }\n    /**\r\n     * Processes geocoding requests\r\n     * @param request\r\n     * @param options\r\n     */\n\n\n    geocode(request, options) {\n      return this._yaApiLoaderService.load().pipe(switchMap(() => from(ymaps.geocode(request, options))), switchMap(result => new Observable(observer => {\n        this._ngZone.run(() => {\n          observer.next(result);\n          observer.complete();\n        });\n      })));\n    }\n\n  }\n\n  YaGeocoderService.ɵfac = function YaGeocoderService_Factory(t) {\n    return new (t || YaGeocoderService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(YaApiLoaderService));\n  };\n\n  YaGeocoderService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function YaGeocoderService_Factory() {\n      return new YaGeocoderService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(YaApiLoaderService));\n    },\n    token: YaGeocoderService,\n    providedIn: \"root\"\n  });\n  return YaGeocoderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference path=\"./lib/typings/yandex-maps/index.ts\" />\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AngularYandexMapsModule, YA_CONFIG, YaApiLoaderService, YaClustererComponent, YaControlDirective, YaGeoObjectDirective, YaGeocoderService, YaMapComponent, YaMultirouteDirective, YaPanoramaDirective, YaPlacemarkDirective }; //# sourceMappingURL=angular8-yandex-maps.js.map","map":null,"metadata":{},"sourceType":"module"}