{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst blocking_proxy_1 = require(\"blocking-proxy\");\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst url = require(\"url\");\n\nconst webdriver_js_extender_1 = require(\"webdriver-js-extender\");\n\nconst element_1 = require(\"./element\");\n\nconst expectedConditions_1 = require(\"./expectedConditions\");\n\nconst locators_1 = require(\"./locators\");\n\nconst logger_1 = require(\"./logger\");\n\nconst clientSideScripts = require('./clientsidescripts'); // TODO: fix the typings for selenium-webdriver/lib/command\n\n\nconst Command = require('selenium-webdriver/lib/command').Command;\n\nconst CommandName = require('selenium-webdriver/lib/command').Name; // jshint browser: true\n\n\nconst DEFER_LABEL = 'NG_DEFER_BOOTSTRAP!';\nconst DEFAULT_RESET_URL = 'data:text/html,<html></html>';\nconst DEFAULT_GET_PAGE_TIMEOUT = 10000;\nlet logger = new logger_1.Logger('protractor'); // TODO(cnishina): either remove for loop entirely since this does not export anything\n// the user might need since everything is composed (with caveat that this could be a\n// potential breaking change) or export the types with `export * from 'selenium-webdriver'`;\n\n/*\n * Mix in other webdriver functionality to be accessible via protractor.\n */\n\nfor (let foo in require('selenium-webdriver')) {\n  exports[foo] = require('selenium-webdriver')[foo];\n} // Explicitly define types for webdriver.WebDriver and ExtendedWebDriver.\n// We do this because we use composition over inheritance to implement polymorphism, and therefore\n// we don't want to inherit WebDriver's constructor.\n\n\nclass AbstractWebDriver {}\n\nexports.AbstractWebDriver = AbstractWebDriver;\n\nclass AbstractExtendedWebDriver extends AbstractWebDriver {}\n\nexports.AbstractExtendedWebDriver = AbstractExtendedWebDriver;\n/**\n * Mix a function from one object onto another. The function will still be\n * called in the context of the original object.  Any arguments of type\n * `ElementFinder` will be unwrapped to their underlying `WebElement` instance\n *\n * @private\n * @param {Object} to\n * @param {Object} from\n * @param {string} fnName\n * @param {function=} setupFn\n */\n\nfunction ptorMixin(to, from, fnName, setupFn) {\n  to[fnName] = function () {\n    const args = arguments;\n\n    for (let i = 0; i < args.length; i++) {\n      if (args[i] instanceof element_1.ElementFinder) {\n        args[i] = args[i].getWebElement();\n      }\n    }\n\n    const run = () => {\n      return from[fnName].apply(from, args);\n    };\n\n    if (setupFn) {\n      const setupResult = setupFn();\n\n      if (setupResult && typeof setupResult.then === 'function') {\n        return setupResult.then(run);\n      }\n    }\n\n    return run();\n  };\n}\n\n;\n/**\n * Build the helper 'element' function for a given instance of Browser.\n *\n * @private\n * @param {Browser} browser A browser instance.\n * @returns {function(webdriver.Locator): ElementFinder}\n */\n\nfunction buildElementHelper(browser) {\n  let element = locator => {\n    return new element_1.ElementArrayFinder(browser).all(locator).toElementFinder_();\n  };\n\n  element.all = locator => {\n    return new element_1.ElementArrayFinder(browser).all(locator);\n  };\n\n  return element;\n}\n\n;\n/**\n * @alias browser\n * @constructor\n * @extends {webdriver_extensions.ExtendedWebDriver}\n * @param {webdriver.WebDriver} webdriver\n * @param {string=} opt_baseUrl A base URL to run get requests against.\n * @param {string|webdriver.promise.Promise<string>=} opt_rootElement  Selector element that has an\n *     ng-app in scope.\n * @param {boolean=} opt_untrackOutstandingTimeouts Whether Protractor should\n *     stop tracking outstanding $timeouts.\n */\n\nclass ProtractorBrowser extends AbstractExtendedWebDriver {\n  constructor(webdriverInstance, opt_baseUrl, opt_rootElement, opt_untrackOutstandingTimeouts, opt_blockingProxyUrl) {\n    super(); // These functions should delegate to the webdriver instance, but should\n    // wait for Angular to sync up before performing the action. This does not\n    // include functions which are overridden by protractor below.\n\n    let methodsToSync = ['getCurrentUrl', 'getPageSource', 'getTitle'];\n    let extendWDInstance;\n\n    try {\n      extendWDInstance = webdriver_js_extender_1.extend(webdriverInstance);\n    } catch (e) {\n      // Probably not a driver that can be extended (e.g. gotten using\n      // `directConnect: true` in the config)\n      extendWDInstance = webdriverInstance;\n    } // Mix all other driver functionality into Protractor.\n\n\n    Object.getOwnPropertyNames(selenium_webdriver_1.WebDriver.prototype).forEach(method => {\n      if (!this[method] && typeof extendWDInstance[method] === 'function') {\n        if (methodsToSync.indexOf(method) !== -1) {\n          ptorMixin(this, extendWDInstance, method, this.waitForAngular.bind(this));\n        } else {\n          ptorMixin(this, extendWDInstance, method);\n        }\n      }\n    });\n    this.driver = extendWDInstance;\n\n    if (opt_blockingProxyUrl) {\n      logger.info('Starting BP client for ' + opt_blockingProxyUrl);\n      this.bpClient = new blocking_proxy_1.BPClient(opt_blockingProxyUrl);\n    }\n\n    this.element = buildElementHelper(this);\n    this.$ = element_1.build$(this.element, selenium_webdriver_1.By);\n    this.$$ = element_1.build$$(this.element, selenium_webdriver_1.By);\n    this.baseUrl = opt_baseUrl || '';\n    this.getPageTimeout = DEFAULT_GET_PAGE_TIMEOUT;\n    this.params = {};\n    this.resetUrl = DEFAULT_RESET_URL;\n    let ng12Hybrid_ = false;\n    Object.defineProperty(this, 'ng12Hybrid', {\n      get: function () {\n        return ng12Hybrid_;\n      },\n      set: function (ng12Hybrid) {\n        if (ng12Hybrid) {\n          logger.warn('You have set ng12Hybrid.  As of Protractor 4.1.0, ' + 'Protractor can automatically infer if you are using an ' + 'ngUpgrade app (as long as ng1 is loaded before you call ' + 'platformBrowserDynamic()), and this flag is no longer needed ' + 'for most users');\n        }\n\n        ng12Hybrid_ = ng12Hybrid;\n      }\n    });\n    this.ready = this.angularAppRoot(opt_rootElement || '').then(() => {\n      return this.driver.getSession();\n    }).then(session => {\n      // Internet Explorer does not accept data URLs, which are the default\n      // reset URL for Protractor.\n      // Safari accepts data urls, but SafariDriver fails after one is used.\n      // PhantomJS produces a \"Detected a page unload event\" if we use data urls\n      let browserName = session.getCapabilities().get('browserName');\n\n      if (browserName === 'internet explorer' || browserName === 'safari' || browserName === 'phantomjs' || browserName === 'MicrosoftEdge') {\n        this.resetUrl = 'about:blank';\n      }\n\n      return this;\n    });\n    this.trackOutstandingTimeouts_ = !opt_untrackOutstandingTimeouts;\n    this.mockModules_ = [];\n    this.addBaseMockModules_(); // set up expected conditions\n\n    this.ExpectedConditions = new expectedConditions_1.ProtractorExpectedConditions(this);\n  }\n  /**\n   * The css selector for an element on which to find Angular. This is usually\n   * 'body' but if your ng-app is on a subsection of the page it may be\n   * a subelement.\n   *\n   * This property is deprecated - please use angularAppRoot() instead.\n   *\n   * @deprecated\n   * @type {string}\n   */\n\n\n  set rootEl(value) {\n    this.angularAppRoot(value);\n  }\n\n  get rootEl() {\n    return this.internalRootEl;\n  }\n  /**\n   * Set the css selector for an element on which to find Angular. This is usually\n   * 'body' but if your ng-app is on a subsection of the page it may be\n   * a subelement.\n   *\n   * The change will be made within WebDriver's control flow, so that commands after\n   * this method is called use the new app root. Pass nothing to get a promise that\n   * resolves to the value of the selector.\n   *\n   * @param {string|webdriver.promise.Promise<string>} value The new selector.\n   * @returns A promise that resolves with the value of the selector.\n   */\n\n\n  angularAppRoot(value = null) {\n    return this.driver.controlFlow().execute(() => {\n      if (value != null) {\n        return selenium_webdriver_1.promise.when(value).then(value => {\n          this.internalRootEl = value;\n\n          if (this.bpClient) {\n            const bpCommandPromise = this.bpClient.setWaitParams(value); // Convert to webdriver promise as best as possible\n\n            return selenium_webdriver_1.promise.when(bpCommandPromise).then(() => this.internalRootEl);\n          }\n\n          return this.internalRootEl;\n        });\n      }\n\n      return selenium_webdriver_1.promise.when(this.internalRootEl);\n    }, `Set angular root selector to ${value}`);\n  }\n  /**\n   * If true, Protractor will not attempt to synchronize with the page before\n   * performing actions. This can be harmful because Protractor will not wait\n   * until $timeouts and $http calls have been processed, which can cause\n   * tests to become flaky. This should be used only when necessary, such as\n   * when a page continuously polls an API using $timeout.\n   *\n   * Initialized to `false` by the runner.\n   *\n   * This property is deprecated - please use waitForAngularEnabled instead.\n   *\n   * @deprecated\n   * @type {boolean}\n   */\n\n\n  set ignoreSynchronization(value) {\n    this.waitForAngularEnabled(!value);\n  }\n\n  get ignoreSynchronization() {\n    return this.internalIgnoreSynchronization;\n  }\n  /**\n   * If set to false, Protractor will not wait for Angular $http and $timeout\n   * tasks to complete before interacting with the browser. This can cause\n   * flaky tests, but should be used if, for instance, your app continuously\n   * polls an API with $timeout.\n   *\n   * Call waitForAngularEnabled() without passing a value to read the current\n   * state without changing it.\n   */\n\n\n  waitForAngularEnabled(enabled = null) {\n    if (enabled != null) {\n      const ret = this.driver.controlFlow().execute(() => {\n        return selenium_webdriver_1.promise.when(enabled).then(enabled => {\n          if (this.bpClient) {\n            logger.debug('Setting waitForAngular' + !enabled);\n            const bpCommandPromise = this.bpClient.setWaitEnabled(enabled); // Convert to webdriver promise as best as possible\n\n            return selenium_webdriver_1.promise.when(bpCommandPromise).then(() => enabled);\n          }\n        });\n      }, `Set proxy synchronization enabled to ${enabled}`);\n      this.internalIgnoreSynchronization = !enabled;\n      return ret;\n    }\n\n    return selenium_webdriver_1.promise.when(!this.ignoreSynchronization);\n  }\n  /**\n   * Get the processed configuration object that is currently being run. This\n   * will contain the specs and capabilities properties of the current runner\n   * instance.\n   *\n   * Set by the runner.\n   *\n   * @returns {webdriver.promise.Promise} A promise which resolves to the\n   * capabilities object.\n   */\n\n\n  getProcessedConfig() {\n    return null;\n  }\n  /**\n   * Fork another instance of browser for use in interactive tests.\n   *\n   * @example\n   * // Running with control flow enabled\n   * var fork = browser.forkNewDriverInstance();\n   * fork.get('page1'); // 'page1' gotten by forked browser\n   *\n   * // Running with control flow disabled\n   * var forked = await browser.forkNewDriverInstance().ready;\n   * await forked.get('page1'); // 'page1' gotten by forked browser\n   *\n   * @param {boolean=} useSameUrl Whether to navigate to current url on creation\n   * @param {boolean=} copyMockModules Whether to apply same mock modules on creation\n   * @param {boolean=} copyConfigUpdates Whether to copy over changes to `baseUrl` and similar\n   *   properties initialized to values in the the config.  Defaults to `true`\n   *\n   * @returns {ProtractorBrowser} A browser instance.\n   */\n\n\n  forkNewDriverInstance(useSameUrl, copyMockModules, copyConfigUpdates = true) {\n    return null;\n  }\n  /**\n   * Restart the browser.  This is done by closing this browser instance and creating a new one.\n   * A promise resolving to the new instance is returned, and if this function was called on the\n   * global `browser` instance then Protractor will automatically overwrite the global `browser`\n   * variable.\n   *\n   * When restarting a forked browser, it is the caller's job to overwrite references to the old\n   * instance.\n   *\n   * This function behaves slightly differently depending on if the webdriver control flow is\n   * enabled.  If the control flow is enabled, the global `browser` object is synchronously\n   * replaced. If the control flow is disabled, the global `browser` is replaced asynchronously\n   * after the old driver quits.\n   *\n   * Set by the runner.\n   *\n   * @example\n   * // Running against global browser, with control flow enabled\n   * browser.get('page1');\n   * browser.restart();\n   * browser.get('page2'); // 'page2' gotten by restarted browser\n   *\n   * // Running against global browser, with control flow disabled\n   * await browser.get('page1');\n   * await browser.restart();\n   * await browser.get('page2'); // 'page2' gotten by restarted browser\n   *\n   * // Running against forked browsers, with the control flow enabled\n   * // In this case, you may prefer `restartSync` (documented below)\n   * var forked = browser.forkNewDriverInstance();\n   * fork.get('page1');\n   * fork.restart().then(function(fork) {\n   *   fork.get('page2'); // 'page2' gotten by restarted fork\n   * });\n   *\n   * // Running against forked browsers, with the control flow disabled\n   * var forked = await browser.forkNewDriverInstance().ready;\n   * await fork.get('page1');\n   * fork = await fork.restart();\n   * await fork.get('page2'); // 'page2' gotten by restarted fork\n   *\n   * // Unexpected behavior can occur if you save references to the global `browser`\n   * var savedBrowser = browser;\n   * browser.get('foo').then(function() {\n   *   console.log(browser === savedBrowser); // false\n   * });\n   * browser.restart();\n   *\n   * @returns {webdriver.promise.Promise<ProtractorBrowser>} A promise resolving to the restarted\n   *   browser\n   */\n\n\n  restart() {\n    return;\n  }\n  /**\n   * Like `restart`, but instead of returning a promise resolving to the new browser instance,\n   * returns the new browser instance directly.  Can only be used when the control flow is enabled.\n   *\n   * @example\n   * // Running against global browser\n   * browser.get('page1');\n   * browser.restartSync();\n   * browser.get('page2'); // 'page2' gotten by restarted browser\n   *\n   * // Running against forked browsers\n   * var forked = browser.forkNewDriverInstance();\n   * fork.get('page1');\n   * fork = fork.restartSync();\n   * fork.get('page2'); // 'page2' gotten by restarted fork\n   *\n   * @throws {TypeError} Will throw an error if the control flow is not enabled\n   * @returns {ProtractorBrowser} The restarted browser\n   */\n\n\n  restartSync() {\n    return;\n  }\n  /**\n   * Instead of using a single root element, search through all angular apps\n   * available on the page when finding elements or waiting for stability.\n   * Only compatible with Angular2.\n   */\n\n\n  useAllAngular2AppRoots() {\n    // The empty string is an invalid css selector, so we use it to easily\n    // signal to scripts to not find a root element.\n    this.angularAppRoot('');\n  }\n  /**\n   * The same as {@code webdriver.WebDriver.prototype.executeScript},\n   * but with a customized description for debugging.\n   *\n   * @private\n   * @param {!(string|Function)} script The script to execute.\n   * @param {string} description A description of the command for debugging.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n   * the scripts return value.\n   * @template T\n   */\n\n\n  executeScriptWithDescription(script, description, ...scriptArgs) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n\n    return this.driver.schedule(new Command(CommandName.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', scriptArgs), description);\n  }\n  /**\n   * The same as {@code webdriver.WebDriver.prototype.executeAsyncScript},\n   * but with a customized description for debugging.\n   *\n   * @private\n   * @param {!(string|Function)} script The script to execute.\n   * @param {string} description A description for debugging purposes.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n   * the\n   *    scripts return value.\n   * @template T\n   */\n\n\n  executeAsyncScript_(script, description, ...scriptArgs) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n\n    return this.driver.schedule(new Command(CommandName.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', scriptArgs), description);\n  }\n  /**\n   * Instruct webdriver to wait until Angular has finished rendering and has\n   * no outstanding $http or $timeout calls before continuing.\n   * Note that Protractor automatically applies this command before every\n   * WebDriver action.\n   *\n   * @param {string=} opt_description An optional description to be added\n   *     to webdriver logs.\n   * @returns {!webdriver.promise.Promise} A promise that will resolve to the\n   *    scripts return value.\n   */\n\n\n  waitForAngular(opt_description) {\n    let description = opt_description ? ' - ' + opt_description : '';\n\n    if (this.ignoreSynchronization) {\n      return this.driver.controlFlow().execute(() => {\n        return true;\n      }, 'Ignore Synchronization Protractor.waitForAngular()');\n    }\n\n    let runWaitForAngularScript = () => {\n      if (this.plugins_.skipAngularStability() || this.bpClient) {\n        return this.driver.controlFlow().execute(() => {\n          return selenium_webdriver_1.promise.when(null);\n        }, 'bpClient or plugin stability override');\n      } else {\n        // Need to wrap this so that we read rootEl in the control flow, not synchronously.\n        return this.angularAppRoot().then(rootEl => {\n          return this.executeAsyncScript_(clientSideScripts.waitForAngular, 'Protractor.waitForAngular()' + description, rootEl);\n        });\n      }\n    };\n\n    return runWaitForAngularScript().then(browserErr => {\n      if (browserErr) {\n        throw new Error('Error while waiting for Protractor to ' + 'sync with the page: ' + JSON.stringify(browserErr));\n      }\n    }).then(() => {\n      return this.driver.controlFlow().execute(() => {\n        return this.plugins_.waitForPromise(this);\n      }, 'Plugins.waitForPromise()').then(() => {\n        return this.driver.wait(() => {\n          return this.plugins_.waitForCondition(this).then(results => {\n            return results.reduce((x, y) => x && y, true);\n          });\n        }, this.allScriptsTimeout, 'Plugins.waitForCondition()');\n      });\n    }, err => {\n      let timeout;\n\n      if (/asynchronous script timeout/.test(err.message)) {\n        // Timeout on Chrome\n        timeout = /-?[\\d\\.]*\\ seconds/.exec(err.message);\n      } else if (/Timed out waiting for async script/.test(err.message)) {\n        // Timeout on Firefox\n        timeout = /-?[\\d\\.]*ms/.exec(err.message);\n      } else if (/Timed out waiting for an asynchronous script/.test(err.message)) {\n        // Timeout on Safari\n        timeout = /-?[\\d\\.]*\\ ms/.exec(err.message);\n      }\n\n      if (timeout) {\n        let errMsg = `Timed out waiting for asynchronous Angular tasks to finish after ` + `${timeout}. This may be because the current page is not an Angular ` + `application. Please see the FAQ for more details: ` + `https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular`;\n\n        if (description.indexOf(' - Locator: ') == 0) {\n          errMsg += '\\nWhile waiting for element with locator' + description;\n        }\n\n        let pendingTimeoutsPromise;\n\n        if (this.trackOutstandingTimeouts_) {\n          pendingTimeoutsPromise = this.executeScriptWithDescription('return window.NG_PENDING_TIMEOUTS', 'Protractor.waitForAngular() - getting pending timeouts' + description);\n        } else {\n          pendingTimeoutsPromise = selenium_webdriver_1.promise.when({});\n        }\n\n        let pendingHttpsPromise = this.executeScriptWithDescription(clientSideScripts.getPendingHttpRequests, 'Protractor.waitForAngular() - getting pending https' + description, this.internalRootEl);\n        return selenium_webdriver_1.promise.all([pendingTimeoutsPromise, pendingHttpsPromise]).then(arr => {\n          let pendingTimeouts = arr[0] || [];\n          let pendingHttps = arr[1] || [];\n          let key,\n              pendingTasks = [];\n\n          for (key in pendingTimeouts) {\n            if (pendingTimeouts.hasOwnProperty(key)) {\n              pendingTasks.push(' - $timeout: ' + pendingTimeouts[key]);\n            }\n          }\n\n          for (key in pendingHttps) {\n            pendingTasks.push(' - $http: ' + pendingHttps[key].url);\n          }\n\n          if (pendingTasks.length) {\n            errMsg += '. \\nThe following tasks were pending:\\n';\n            errMsg += pendingTasks.join('\\n');\n          }\n\n          err.message = errMsg;\n          throw err;\n        }, () => {\n          err.message = errMsg;\n          throw err;\n        });\n      } else {\n        throw err;\n      }\n    });\n  }\n  /**\n   * Waits for Angular to finish rendering before searching for elements.\n   * @see webdriver.WebDriver.findElement\n   * @returns {!webdriver.WebElementPromise} A promise that will be resolved to\n   *      the located {@link webdriver.WebElement}.\n   */\n\n\n  findElement(locator) {\n    return this.element(locator).getWebElement();\n  }\n  /**\n   * Waits for Angular to finish rendering before searching for elements.\n   * @see webdriver.WebDriver.findElements\n   * @returns {!webdriver.promise.Promise} A promise that will be resolved to an\n   *     array of the located {@link webdriver.WebElement}s.\n   */\n\n\n  findElements(locator) {\n    return this.element.all(locator).getWebElements();\n  }\n  /**\n   * Tests if an element is present on the page.\n   * @see webdriver.WebDriver.isElementPresent\n   * @returns {!webdriver.promise.Promise} A promise that will resolve to whether\n   *     the element is present on the page.\n   */\n\n\n  isElementPresent(locatorOrElement) {\n    let element;\n\n    if (locatorOrElement instanceof element_1.ElementFinder) {\n      element = locatorOrElement;\n    } else if (locatorOrElement instanceof selenium_webdriver_1.WebElement) {\n      element = element_1.ElementFinder.fromWebElement_(this, locatorOrElement);\n    } else {\n      element = this.element(locatorOrElement);\n    }\n\n    return element.isPresent();\n  }\n  /**\n   * Add a module to load before Angular whenever Protractor.get is called.\n   * Modules will be registered after existing modules already on the page,\n   * so any module registered here will override preexisting modules with the\n   * same name.\n   *\n   * @example\n   * browser.addMockModule('modName', function() {\n   *   angular.module('modName', []).value('foo', 'bar');\n   * });\n   *\n   * @param {!string} name The name of the module to load or override.\n   * @param {!string|Function} script The JavaScript to load the module.\n   *     Note that this will be executed in the browser context, so it cannot\n   *     access variables from outside its scope.\n   * @param {...*} varArgs Any additional arguments will be provided to\n   *     the script and may be referenced using the `arguments` object.\n   */\n\n\n  addMockModule(name, script, ...moduleArgs) {\n    this.mockModules_.push({\n      name: name,\n      script: script,\n      args: moduleArgs\n    });\n  }\n  /**\n   * Clear the list of registered mock modules.\n   */\n\n\n  clearMockModules() {\n    this.mockModules_ = [];\n    this.addBaseMockModules_();\n  }\n  /**\n   * Remove a registered mock module.\n   *\n   * @example\n   * browser.removeMockModule('modName');\n   *\n   * @param {!string} name The name of the module to remove.\n   */\n\n\n  removeMockModule(name) {\n    for (let i = 0; i < this.mockModules_.length; ++i) {\n      if (this.mockModules_[i].name == name) {\n        this.mockModules_.splice(i--, 1);\n      }\n    }\n  }\n  /**\n   * Get a list of the current mock modules.\n   *\n   * @returns {Array.<!string|Function>} The list of mock modules.\n   */\n\n\n  getRegisteredMockModules() {\n    return this.mockModules_.map(module => module.script);\n  }\n\n  /**\n   * Add the base mock modules used for all Protractor tests.\n   *\n   * @private\n   */\n  addBaseMockModules_() {\n    this.addMockModule('protractorBaseModule_', clientSideScripts.protractorBaseModuleFn, this.trackOutstandingTimeouts_);\n  }\n  /**\n   * @see webdriver.WebDriver.get\n   *\n   * Navigate to the given destination and loads mock modules before\n   * Angular. Assumes that the page being loaded uses Angular.\n   * If you need to access a page which does not have Angular on load, use\n   * the wrapped webdriver directly.\n   *\n   * @example\n   * browser.get('https://angularjs.org/');\n   * expect(browser.getCurrentUrl()).toBe('https://angularjs.org/');\n   *\n   * @param {string} destination Destination URL.\n   * @param {number=} opt_timeout Number of milliseconds to wait for Angular to\n   *     start.\n   */\n\n\n  get(destination, timeout = this.getPageTimeout) {\n    destination = this.baseUrl.indexOf('file://') === 0 ? this.baseUrl + destination : url.resolve(this.baseUrl, destination);\n\n    if (this.ignoreSynchronization) {\n      return this.driver.get(destination).then(() => this.driver.controlFlow().execute(() => this.plugins_.onPageLoad(this))).then(() => null);\n    }\n\n    let msg = str => {\n      return 'Protractor.get(' + destination + ') - ' + str;\n    };\n\n    return this.driver.controlFlow().execute(() => {\n      return selenium_webdriver_1.promise.when(null);\n    }).then(() => {\n      if (this.bpClient) {\n        return this.driver.controlFlow().execute(() => {\n          return this.bpClient.setWaitEnabled(false);\n        });\n      }\n    }).then(() => {\n      // Go to reset url\n      return this.driver.get(this.resetUrl);\n    }).then(() => {\n      // Set defer label and navigate\n      return this.executeScriptWithDescription('window.name = \"' + DEFER_LABEL + '\" + window.name;' + 'window.location.replace(\"' + destination + '\");', msg('reset url'));\n    }).then(() => {\n      // We need to make sure the new url has loaded before\n      // we try to execute any asynchronous scripts.\n      return this.driver.wait(() => {\n        return this.executeScriptWithDescription('return window.location.href;', msg('get url')).then(url => {\n          return url !== this.resetUrl;\n        }, err => {\n          if (err.code == 13 || err.name === 'JavascriptError') {\n            // Ignore the error, and continue trying. This is\n            // because IE driver sometimes (~1%) will throw an\n            // unknown error from this execution. See\n            // https://github.com/angular/protractor/issues/841\n            // This shouldn't mask errors because it will fail\n            // with the timeout anyway.\n            return false;\n          } else {\n            throw err;\n          }\n        });\n      }, timeout, 'waiting for page to load for ' + timeout + 'ms');\n    }).then(() => {\n      // Run Plugins\n      return this.driver.controlFlow().execute(() => {\n        return this.plugins_.onPageLoad(this);\n      });\n    }).then(() => {\n      // Make sure the page is an Angular page.\n      return this.executeAsyncScript_(clientSideScripts.testForAngular, msg('test for angular'), Math.floor(timeout / 1000), this.ng12Hybrid).then(angularTestResult => {\n        let angularVersion = angularTestResult.ver;\n\n        if (!angularVersion) {\n          let message = angularTestResult.message;\n          logger.error(`Could not find Angular on page ${destination} : ${message}`);\n          throw new Error(`Angular could not be found on the page ${destination}. ` + `If this is not an Angular application, you may need to turn off waiting for Angular.\n                          Please see \n                          https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular-on-page-load`);\n        }\n\n        return angularVersion;\n      }, err => {\n        throw new Error('Error while running testForAngular: ' + err.message);\n      });\n    }).then(angularVersion => {\n      // Load Angular Mocks\n      if (angularVersion === 1) {\n        // At this point, Angular will pause for us until angular.resumeBootstrap is called.\n        let moduleNames = [];\n        let modulePromise = selenium_webdriver_1.promise.when(null);\n\n        for (const {\n          name,\n          script,\n          args\n        } of this.mockModules_) {\n          moduleNames.push(name);\n          let executeScriptArgs = [script, msg('add mock module ' + name), ...args];\n          modulePromise = modulePromise.then(() => this.executeScriptWithDescription.apply(this, executeScriptArgs).then(null, err => {\n            throw new Error('Error while running module script ' + name + ': ' + err.message);\n          }));\n        }\n\n        return modulePromise.then(() => this.executeScriptWithDescription('window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__ = ' + 'angular.resumeBootstrap(arguments[0]);', msg('resume bootstrap'), moduleNames));\n      } else {\n        // TODO: support mock modules in Angular2. For now, error if someone\n        // has tried to use one.\n        if (this.mockModules_.length > 1) {\n          throw 'Trying to load mock modules on an Angular v2+ app is not yet supported.';\n        }\n      }\n    }).then(() => {\n      // Reset bpClient sync\n      if (this.bpClient) {\n        return this.driver.controlFlow().execute(() => {\n          return this.bpClient.setWaitEnabled(!this.internalIgnoreSynchronization);\n        });\n      }\n    }).then(() => {\n      // Run Plugins\n      return this.driver.controlFlow().execute(() => {\n        return this.plugins_.onPageStable(this);\n      });\n    }).then(() => null);\n  }\n  /**\n   * @see webdriver.WebDriver.refresh\n   *\n   * Makes a full reload of the current page and loads mock modules before\n   * Angular. Assumes that the page being loaded uses Angular.\n   * If you need to access a page which does not have Angular on load, use\n   * the wrapped webdriver directly.\n   *\n   * @param {number=} opt_timeout Number of milliseconds to wait for Angular to start.\n   */\n\n\n  refresh(opt_timeout) {\n    if (this.ignoreSynchronization) {\n      return this.driver.navigate().refresh();\n    }\n\n    return this.executeScriptWithDescription('return window.location.href', 'Protractor.refresh() - getUrl').then(href => {\n      return this.get(href, opt_timeout);\n    });\n  }\n  /**\n   * Mixin navigation methods back into the navigation object so that\n   * they are invoked as before, i.e. driver.navigate().refresh()\n   */\n\n\n  navigate() {\n    let nav = this.driver.navigate();\n    ptorMixin(nav, this, 'refresh');\n    return nav;\n  }\n  /**\n   * Browse to another page using in-page navigation.\n   *\n   * @example\n   * browser.get('http://angular.github.io/protractor/#/tutorial');\n   * browser.setLocation('api');\n   * expect(browser.getCurrentUrl())\n   *     .toBe('http://angular.github.io/protractor/#/api');\n   *\n   * @param {string} url In page URL using the same syntax as $location.url()\n   * @returns {!webdriver.promise.Promise} A promise that will resolve once\n   *    page has been changed.\n   */\n\n\n  setLocation(url) {\n    return this.waitForAngular().then(() => this.angularAppRoot()).then(rootEl => this.executeScriptWithDescription(clientSideScripts.setLocation, 'Protractor.setLocation()', rootEl, url).then(browserErr => {\n      if (browserErr) {\n        throw 'Error while navigating to \\'' + url + '\\' : ' + JSON.stringify(browserErr);\n      }\n    }));\n  }\n  /**\n   * Deprecated, use `browser.getCurrentUrl()` instead.\n   *\n   * Despite its name, this function will generally return `$location.url()`, though in some\n   * cases it will return `$location.absUrl()` instead.  This function is only here for legacy\n   * users, and will probably be removed in Protractor 6.0.\n   *\n   * @deprecated Please use `browser.getCurrentUrl()`\n   * @example\n   * browser.get('http://angular.github.io/protractor/#/api');\n   * expect(browser.getLocationAbsUrl())\n   *     .toBe('http://angular.github.io/protractor/#/api');\n   * @returns {webdriver.promise.Promise<string>} The current absolute url from\n   * AngularJS.\n   */\n\n\n  getLocationAbsUrl() {\n    logger.warn('`browser.getLocationAbsUrl()` is deprecated, please use `browser.getCurrentUrl` instead.');\n    return this.waitForAngular().then(() => this.angularAppRoot()).then(rootEl => this.executeScriptWithDescription(clientSideScripts.getLocationAbsUrl, 'Protractor.getLocationAbsUrl()', rootEl));\n  }\n  /**\n   * Determine if the control flow is enabled.\n   *\n   * @returns true if the control flow is enabled, false otherwise.\n   */\n\n\n  controlFlowIsEnabled() {\n    if (selenium_webdriver_1.promise.USE_PROMISE_MANAGER !== undefined) {\n      return selenium_webdriver_1.promise.USE_PROMISE_MANAGER;\n    } else {\n      // True for old versions of `selenium-webdriver`, probably false in >=5.0.0\n      return !!selenium_webdriver_1.promise.ControlFlow;\n    }\n  }\n\n}\n/**\n * @type {ProtractorBy}\n */\n\n\nProtractorBrowser.By = new locators_1.ProtractorBy();\nexports.ProtractorBrowser = ProtractorBrowser; //# sourceMappingURL=browser.js.map","map":null,"metadata":{},"sourceType":"script"}