{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst webdriver_logger_1 = require(\"./webdriver_logger\");\n\nconst angularWaits = require('./client_scripts/wait.js');\n/**\n * A barrier that uses Angular's Testability API to block commands until the application is stable.\n */\n\n\nclass AngularWaitBarrier {\n  constructor(client) {\n    this.client = client;\n    this.enabled = true;\n    this.rootSelector = '';\n  }\n  /**\n   * A CSS Selector for a DOM element within your Angular application.\n   * BlockingProxy will attempt to automatically find your application, but it is\n   * necessary to set rootElement in certain cases.\n   *\n   * In Angular 1, BlockingProxy will use the element your app bootstrapped to by\n   * default.  If that doesn't work, it will then search for hooks in `body` or\n   * `ng-app` elements (details here: https://git.io/v1b2r).\n   *\n   * In later versions of Angular, BlockingProxy will try to hook into all angular\n   * apps on the page. Use rootElement to limit the scope of which apps\n   * BlockingProxy waits for and searches within.\n   *\n   * @param rootSelector A selector for the root element of the Angular app.\n   */\n\n\n  setRootSelector(selector) {\n    this.rootSelector = selector;\n  }\n\n  waitForAngularData() {\n    return JSON.stringify({\n      script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',\n      args: [this.rootSelector]\n    });\n  }\n  /**\n   * Turn on WebDriver logging.\n   *\n   * @param logDir The directory to create logs in.\n   */\n\n\n  enableLogging(logDir) {\n    if (!this.logger) {\n      this.logger = new webdriver_logger_1.WebDriverLogger();\n    }\n\n    this.logger.setLogDir(logDir);\n  }\n  /**\n   * Override the logger instance. Only used for testing.\n   */\n\n\n  setLogger(logger) {\n    this.logger = logger;\n  }\n\n  sendRequestToStabilize(command) {\n    return this.client.executeAsync(command.sessionId, this.waitForAngularData()).then(value => {\n      // waitForAngular only returns a value if there was an error\n      // in the browser.\n      if (value) {\n        throw new Error('Error from waitForAngular: ' + value);\n      }\n    });\n  }\n\n  shouldStabilize(command) {\n    const url = command.url;\n\n    if (!this.enabled) {\n      return false;\n    } // TODO - should this implement some state, and be smart about whether\n    // stabilization is necessary or not? Would that be as simple as GET/POST?\n    // e.g. two gets in a row don't require a wait btwn.\n    //\n    // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for\n    // descriptions of the paths.\n    // We shouldn't stabilize if we haven't loaded the page yet.\n\n\n    const parts = url.split('/');\n\n    if (parts.length < 4) {\n      return false;\n    }\n\n    const commandsToWaitFor = ['executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys', 'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'];\n\n    if (commandsToWaitFor.indexOf(parts[3]) != -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  onCommand(command) {\n    if (this.logger) {\n      command.on('data', () => {\n        this.logger.logWebDriverCommand(command);\n      });\n    }\n\n    if (this.shouldStabilize(command)) {\n      const started = Date.now();\n      return this.sendRequestToStabilize(command).then(() => {\n        const ended = Date.now();\n\n        if (this.logger) {\n          this.logger.logEvent('Waiting for Angular', command.sessionId, ended - started);\n        }\n      });\n    }\n\n    return Promise.resolve(null);\n  }\n\n}\n\nexports.AngularWaitBarrier = AngularWaitBarrier; //# sourceMappingURL=angular_wait_barrier.js.map","map":null,"metadata":{},"sourceType":"script"}