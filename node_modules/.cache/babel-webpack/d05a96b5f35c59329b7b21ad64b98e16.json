{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst util_1 = require(\"./util\");\n/**\n * Represents a library of canned expected conditions that are useful for\n * protractor, especially when dealing with non-angular apps.\n *\n * Each condition returns a function that evaluates to a promise. You may mix\n * multiple conditions using `and`, `or`, and/or `not`. You may also\n * mix these conditions with any other conditions that you write.\n *\n * See ExpectedCondition Class in Selenium WebDriver codebase.\n * http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html\n *\n *\n * @example\n * var EC = protractor.ExpectedConditions;\n * var button = $('#xyz');\n * var isClickable = EC.elementToBeClickable(button);\n *\n * browser.get(URL);\n * browser.wait(isClickable, 5000); //wait for an element to become clickable\n * button.click();\n *\n * // You can define your own expected condition, which is a function that\n * // takes no parameter and evaluates to a promise of a boolean.\n * var urlChanged = function() {\n *   return browser.getCurrentUrl().then(function(url) {\n *     return url === 'http://www.angularjs.org';\n *   });\n * };\n *\n * // You can customize the conditions with EC.and, EC.or, and EC.not.\n * // Here's a condition to wait for url to change, $('abc') element to contain\n * // text 'bar', and button becomes clickable.\n * var condition = EC.and(urlChanged, EC.textToBePresentInElement($('abc'),\n * 'bar'), isClickable);\n * browser.get(URL);\n * browser.wait(condition, 5000); //wait for condition to be true.\n * button.click();\n *\n * @alias ExpectedConditions\n * @constructor\n */\n\n\nclass ProtractorExpectedConditions {\n  constructor(browser) {\n    this.browser = browser;\n  }\n\n  /**\n   * Negates the result of a promise.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * var titleIsNotFoo = EC.not(EC.titleIs('Foo'));\n   * // Waits for title to become something besides 'foo'.\n   * browser.wait(titleIsNotFoo, 5000);\n   *\n   * @alias ExpectedConditions.not\n   * @param {!function} expectedCondition\n   *\n   * @returns {!function} An expected condition that returns the negated value.\n   */\n  not(expectedCondition) {\n    return () => {\n      return expectedCondition().then(bool => {\n        return !bool;\n      });\n    };\n  }\n  /**\n   * Helper function that is equivalent to the logical_and if defaultRet==true,\n   * or logical_or if defaultRet==false\n   *\n   * @private\n   * @param {boolean} defaultRet\n   * @param {Array.<Function>} fns An array of expected conditions to chain.\n   *\n   * @returns {!function} An expected condition that returns a promise which\n   *     evaluates to the result of the logical chain.\n   */\n\n\n  logicalChain_(defaultRet, fns) {\n    let self = this;\n    return () => {\n      if (fns.length === 0) {\n        return defaultRet;\n      }\n\n      let fn = fns[0];\n      return fn().then(bool => {\n        if (bool === defaultRet) {\n          return self.logicalChain_(defaultRet, fns.slice(1))();\n        } else {\n          return !defaultRet;\n        }\n      });\n    };\n  }\n  /**\n   * Chain a number of expected conditions using logical_and, short circuiting\n   * at the first expected condition that evaluates to false.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * var titleContainsFoo = EC.titleContains('Foo');\n   * var titleIsNotFooBar = EC.not(EC.titleIs('FooBar'));\n   * // Waits for title to contain 'Foo', but is not 'FooBar'\n   * browser.wait(EC.and(titleContainsFoo, titleIsNotFooBar), 5000);\n   *\n   * @alias ExpectedConditions.and\n   * @param {Array.<Function>} fns An array of expected conditions to 'and'\n   * together.\n   *\n   * @returns {!function} An expected condition that returns a promise which\n   *     evaluates to the result of the logical and.\n   */\n\n\n  and(...args) {\n    return this.logicalChain_(true, args);\n  }\n  /**\n   * Chain a number of expected conditions using logical_or, short circuiting\n   * at the first expected condition that evaluates to true.\n   *\n   * @alias ExpectedConditions.or\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * var titleContainsFoo = EC.titleContains('Foo');\n   * var titleContainsBar = EC.titleContains('Bar');\n   * // Waits for title to contain either 'Foo' or 'Bar'\n   * browser.wait(EC.or(titleContainsFoo, titleContainsBar), 5000);\n   *\n   * @param {Array.<Function>} fns An array of expected conditions to 'or'\n   * together.\n   *\n   * @returns {!function} An expected condition that returns a promise which\n   *     evaluates to the result of the logical or.\n   */\n\n\n  or(...args) {\n    return this.logicalChain_(false, args);\n  }\n  /**\n   * Expect an alert to be present.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for an alert pops up.\n   * browser.wait(EC.alertIsPresent(), 5000);\n   *\n   * @alias ExpectedConditions.alertIsPresent\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether an alert is present.\n   */\n\n\n  alertIsPresent() {\n    return () => {\n      return this.browser.driver.switchTo().alert().then(() => {\n        return true;\n      }, err => {\n        if (err instanceof selenium_webdriver_1.error.NoSuchAlertError) {\n          return false;\n        } else {\n          throw err;\n        }\n      });\n    };\n  }\n  /**\n   * An Expectation for checking an element is visible and enabled such that you\n   * can click it.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be clickable.\n   * browser.wait(EC.elementToBeClickable($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.elementToBeClickable\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is clickable.\n   */\n\n\n  elementToBeClickable(elementFinder) {\n    return this.and(this.visibilityOf(elementFinder), () => {\n      return elementFinder.isEnabled().then(util_1.passBoolean, util_1.falseIfMissing);\n    });\n  }\n  /**\n   * An expectation for checking if the given text is present in the\n   * element. Returns false if the elementFinder does not find an element.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to contain the text 'foo'.\n   * browser.wait(EC.textToBePresentInElement($('#abc'), 'foo'), 5000);\n   *\n   * @alias ExpectedConditions.textToBePresentInElement\n   * @param {!ElementFinder} elementFinder The element to check\n   * @param {!string} text The text to verify against\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the text is present in the element.\n   */\n\n\n  textToBePresentInElement(elementFinder, text) {\n    let hasText = () => {\n      return elementFinder.getText().then(actualText => {\n        // MSEdge does not properly remove newlines, which causes false\n        // negatives\n        return actualText.replace(/\\r?\\n|\\r/g, '').indexOf(text) > -1;\n      }, util_1.falseIfMissing);\n    };\n\n    return this.and(this.presenceOf(elementFinder), hasText);\n  }\n  /**\n   * An expectation for checking if the given text is present in the elementâ€™s\n   * value. Returns false if the elementFinder does not find an element.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'myInput' to contain the input 'foo'.\n   * browser.wait(EC.textToBePresentInElementValue($('#myInput'), 'foo'), 5000);\n   *\n   * @alias ExpectedConditions.textToBePresentInElementValue\n   * @param {!ElementFinder} elementFinder The element to check\n   * @param {!string} text The text to verify against\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the text is present in the element's value.\n   */\n\n\n  textToBePresentInElementValue(elementFinder, text) {\n    let hasText = () => {\n      return elementFinder.getAttribute('value').then(actualText => {\n        return actualText.indexOf(text) > -1;\n      }, util_1.falseIfMissing);\n    };\n\n    return this.and(this.presenceOf(elementFinder), hasText);\n  }\n  /**\n   * An expectation for checking that the title contains a case-sensitive\n   * substring.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the title to contain 'foo'.\n   * browser.wait(EC.titleContains('foo'), 5000);\n   *\n   * @alias ExpectedConditions.titleContains\n   * @param {!string} title The fragment of title expected\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the title contains the string.\n   */\n\n\n  titleContains(title) {\n    return () => {\n      return this.browser.driver.getTitle().then(actualTitle => {\n        return actualTitle.indexOf(title) > -1;\n      });\n    };\n  }\n  /**\n   * An expectation for checking the title of a page.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the title to be 'foo'.\n   * browser.wait(EC.titleIs('foo'), 5000);\n   *\n   * @alias ExpectedConditions.titleIs\n   * @param {!string} title The expected title, which must be an exact match.\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the title equals the string.\n   */\n\n\n  titleIs(title) {\n    return () => {\n      return this.browser.driver.getTitle().then(actualTitle => {\n        return actualTitle === title;\n      });\n    };\n  }\n  /**\n   * An expectation for checking that the URL contains a case-sensitive\n   * substring.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the URL to contain 'foo'.\n   * browser.wait(EC.urlContains('foo'), 5000);\n   *\n   * @alias ExpectedConditions.urlContains\n   * @param {!string} url The fragment of URL expected\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the URL contains the string.\n   */\n\n\n  urlContains(url) {\n    return () => {\n      return this.browser.driver.getCurrentUrl().then(actualUrl => {\n        return actualUrl.indexOf(url) > -1;\n      });\n    };\n  }\n  /**\n   * An expectation for checking the URL of a page.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the URL to be 'foo'.\n   * browser.wait(EC.urlIs('foo'), 5000);\n   *\n   * @alias ExpectedConditions.urlIs\n   * @param {!string} url The expected URL, which must be an exact match.\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the url equals the string.\n   */\n\n\n  urlIs(url) {\n    return () => {\n      return this.browser.driver.getCurrentUrl().then(actualUrl => {\n        return actualUrl === url;\n      });\n    };\n  }\n  /**\n   * An expectation for checking that an element is present on the DOM\n   * of a page. This does not necessarily mean that the element is visible.\n   * This is the opposite of 'stalenessOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be present on the dom.\n   * browser.wait(EC.presenceOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.presenceOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is present.\n   */\n\n\n  presenceOf(elementFinder) {\n    return elementFinder.isPresent.bind(elementFinder);\n  }\n\n  /**\n   * An expectation for checking that an element is not attached to the DOM\n   * of a page. This is the opposite of 'presenceOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be no longer present on the dom.\n   * browser.wait(EC.stalenessOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.stalenessOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is stale.\n   */\n  stalenessOf(elementFinder) {\n    return this.not(this.presenceOf(elementFinder));\n  }\n  /**\n   * An expectation for checking that an element is present on the DOM of a\n   * page and visible. Visibility means that the element is not only displayed\n   * but also has a height and width that is greater than 0. This is the\n   * opposite\n   * of 'invisibilityOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be visible on the dom.\n   * browser.wait(EC.visibilityOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.visibilityOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is visible.\n   */\n\n\n  visibilityOf(elementFinder) {\n    return this.and(this.presenceOf(elementFinder), () => {\n      return elementFinder.isDisplayed().then(util_1.passBoolean, util_1.falseIfMissing);\n    });\n  }\n  /**\n   * An expectation for checking that an element is either invisible or not\n   * present on the DOM. This is the opposite of 'visibilityOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be no longer visible on the dom.\n   * browser.wait(EC.invisibilityOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.invisibilityOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is invisible.\n   */\n\n\n  invisibilityOf(elementFinder) {\n    return this.not(this.visibilityOf(elementFinder));\n  }\n  /**\n   * An expectation for checking the selection is selected.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'myCheckbox' to be selected.\n   * browser.wait(EC.elementToBeSelected($('#myCheckbox')), 5000);\n   *\n   * @alias ExpectedConditions.elementToBeSelected\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is selected.\n   */\n\n\n  elementToBeSelected(elementFinder) {\n    return this.and(this.presenceOf(elementFinder), () => {\n      return elementFinder.isSelected().then(util_1.passBoolean, util_1.falseIfMissing);\n    });\n  }\n\n}\n\nexports.ProtractorExpectedConditions = ProtractorExpectedConditions; //# sourceMappingURL=expectedConditions.js.map","map":null,"metadata":{},"sourceType":"script"}