{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nconst command = require('./command');\n\nconst error = require('./error');\n\nconst input = require('./input');\n/**\n * @param {!IArrayLike} args .\n * @return {!Array} .\n */\n\n\nfunction flatten(args) {\n  let result = [];\n\n  for (let i = 0; i < args.length; i++) {\n    let element = args[i];\n\n    if (Array.isArray(element)) {\n      result.push.apply(result, flatten(element));\n    } else {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\nconst MODIFIER_KEYS = new Set([input.Key.ALT, input.Key.CONTROL, input.Key.SHIFT, input.Key.COMMAND]);\n/**\n * Checks that a key is a modifier key.\n * @param {!input.Key} key The key to check.\n * @throws {error.InvalidArgumentError} If the key is not a modifier key.\n * @private\n */\n\nfunction checkModifierKey(key) {\n  if (!MODIFIER_KEYS.has(key)) {\n    throw new error.InvalidArgumentError('Not a modifier key');\n  }\n}\n/**\n * Class for defining sequences of complex user interactions. Each sequence\n * will not be executed until {@link #perform} is called.\n *\n * This class should not be instantiated directly. Instead, obtain an instance\n * using {@link ./webdriver.WebDriver#actions() WebDriver.actions()}.\n *\n * Sample usage:\n *\n *     driver.actions().\n *         keyDown(Key.SHIFT).\n *         click(element1).\n *         click(element2).\n *         dragAndDrop(element3, element4).\n *         keyUp(Key.SHIFT).\n *         perform();\n *\n */\n\n\nclass ActionSequence {\n  /**\n   * @param {!./webdriver.WebDriver} driver The driver that should be used to\n   *     perform this action sequence.\n   */\n  constructor(driver) {\n    /** @private {!./webdriver.WebDriver} */\n    this.driver_ = driver;\n    /** @private {!Array<{description: string, command: !command.Command}>} */\n\n    this.actions_ = [];\n  }\n  /**\n   * Schedules an action to be executed each time {@link #perform} is called on\n   * this instance.\n   *\n   * @param {string} description A description of the command.\n   * @param {!command.Command} command The command.\n   * @private\n   */\n\n\n  schedule_(description, command) {\n    this.actions_.push({\n      description: description,\n      command: command\n    });\n  }\n  /**\n   * Executes this action sequence.\n   *\n   * @return {!./promise.Thenable} A promise that will be resolved once\n   *     this sequence has completed.\n   */\n\n\n  perform() {\n    // Make a protected copy of the scheduled actions. This will protect against\n    // users defining additional commands before this sequence is actually\n    // executed.\n    let actions = this.actions_.concat();\n    let driver = this.driver_;\n    return driver.controlFlow().execute(function () {\n      let results = actions.map(action => {\n        return driver.schedule(action.command, action.description);\n      });\n      return Promise.all(results);\n    }, 'ActionSequence.perform');\n  }\n  /**\n   * Moves the mouse. The location to move to may be specified in terms of the\n   * mouse's current location, an offset relative to the top-left corner of an\n   * element, or an element (in which case the middle of the element is used).\n   *\n   * @param {(!./webdriver.WebElement|{x: number, y: number})} location The\n   *     location to drag to, as either another WebElement or an offset in\n   *     pixels.\n   * @param {{x: number, y: number}=} opt_offset If the target {@code location}\n   *     is defined as a {@link ./webdriver.WebElement}, this parameter defines\n   *     an offset within that element. The offset should be specified in pixels\n   *     relative to the top-left corner of the element's bounding box. If\n   *     omitted, the element's center will be used as the target offset.\n   * @return {!ActionSequence} A self reference.\n   */\n\n\n  mouseMove(location, opt_offset) {\n    let cmd = new command.Command(command.Name.MOVE_TO);\n\n    if (typeof location.x === 'number') {\n      setOffset(location);\n    } else {\n      cmd.setParameter('element', location.getId());\n\n      if (opt_offset) {\n        setOffset(opt_offset);\n      }\n    }\n\n    this.schedule_('mouseMove', cmd);\n    return this;\n    /** @param {{x: number, y: number}} offset The offset to use. */\n\n    function setOffset(offset) {\n      cmd.setParameter('xoffset', offset.x || 0);\n      cmd.setParameter('yoffset', offset.y || 0);\n    }\n  }\n  /**\n   * Schedules a mouse action.\n   * @param {string} description A simple descriptive label for the scheduled\n   *     action.\n   * @param {!command.Name} commandName The name of the command.\n   * @param {(./webdriver.WebElement|input.Button)=} opt_elementOrButton Either\n   *     the element to interact with or the button to click with.\n   *     Defaults to {@link input.Button.LEFT} if neither an element nor\n   *     button is specified.\n   * @param {input.Button=} opt_button The button to use. Defaults to\n   *     {@link input.Button.LEFT}. Ignored if the previous argument is\n   *     provided as a button.\n   * @return {!ActionSequence} A self reference.\n   * @private\n   */\n\n\n  scheduleMouseAction_(description, commandName, opt_elementOrButton, opt_button) {\n    let button;\n\n    if (typeof opt_elementOrButton === 'number') {\n      button = opt_elementOrButton;\n    } else {\n      if (opt_elementOrButton) {\n        this.mouseMove(opt_elementOrButton);\n      }\n\n      button = opt_button !== void 0 ? opt_button : input.Button.LEFT;\n    }\n\n    let cmd = new command.Command(commandName).setParameter('button', button);\n    this.schedule_(description, cmd);\n    return this;\n  }\n  /**\n   * Presses a mouse button. The mouse button will not be released until\n   * {@link #mouseUp} is called, regardless of whether that call is made in this\n   * sequence or another. The behavior for out-of-order events (e.g. mouseDown,\n   * click) is undefined.\n   *\n   * If an element is provided, the mouse will first be moved to the center\n   * of that element. This is equivalent to:\n   *\n   *     sequence.mouseMove(element).mouseDown()\n   *\n   * Warning: this method currently only supports the left mouse button. See\n   * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).\n   *\n   * @param {(./webdriver.WebElement|input.Button)=} opt_elementOrButton Either\n   *     the element to interact with or the button to click with.\n   *     Defaults to {@link input.Button.LEFT} if neither an element nor\n   *     button is specified.\n   * @param {input.Button=} opt_button The button to use. Defaults to\n   *     {@link input.Button.LEFT}. Ignored if a button is provided as the\n   *     first argument.\n   * @return {!ActionSequence} A self reference.\n   */\n\n\n  mouseDown(opt_elementOrButton, opt_button) {\n    return this.scheduleMouseAction_('mouseDown', command.Name.MOUSE_DOWN, opt_elementOrButton, opt_button);\n  }\n  /**\n   * Releases a mouse button. Behavior is undefined for calling this function\n   * without a previous call to {@link #mouseDown}.\n   *\n   * If an element is provided, the mouse will first be moved to the center\n   * of that element. This is equivalent to:\n   *\n   *     sequence.mouseMove(element).mouseUp()\n   *\n   * Warning: this method currently only supports the left mouse button. See\n   * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).\n   *\n   * @param {(./webdriver.WebElement|input.Button)=} opt_elementOrButton Either\n   *     the element to interact with or the button to click with.\n   *     Defaults to {@link input.Button.LEFT} if neither an element nor\n   *     button is specified.\n   * @param {input.Button=} opt_button The button to use. Defaults to\n   *     {@link input.Button.LEFT}. Ignored if a button is provided as the\n   *     first argument.\n   * @return {!ActionSequence} A self reference.\n   */\n\n\n  mouseUp(opt_elementOrButton, opt_button) {\n    return this.scheduleMouseAction_('mouseUp', command.Name.MOUSE_UP, opt_elementOrButton, opt_button);\n  }\n  /**\n   * Convenience function for performing a \"drag and drop\" manuever. The target\n   * element may be moved to the location of another element, or by an offset (in\n   * pixels).\n   *\n   * @param {!./webdriver.WebElement} element The element to drag.\n   * @param {(!./webdriver.WebElement|{x: number, y: number})} location The\n   *     location to drag to, either as another WebElement or an offset in\n   *     pixels.\n   * @return {!ActionSequence} A self reference.\n   */\n\n\n  dragAndDrop(element, location) {\n    return this.mouseDown(element).mouseMove(location).mouseUp();\n  }\n  /**\n   * Clicks a mouse button.\n   *\n   * If an element is provided, the mouse will first be moved to the center\n   * of that element. This is equivalent to:\n   *\n   *     sequence.mouseMove(element).click()\n   *\n   * @param {(./webdriver.WebElement|input.Button)=} opt_elementOrButton Either\n   *     the element to interact with or the button to click with.\n   *     Defaults to {@link input.Button.LEFT} if neither an element nor\n   *     button is specified.\n   * @param {input.Button=} opt_button The button to use. Defaults to\n   *     {@link input.Button.LEFT}. Ignored if a button is provided as the\n   *     first argument.\n   * @return {!ActionSequence} A self reference.\n   */\n\n\n  click(opt_elementOrButton, opt_button) {\n    return this.scheduleMouseAction_('click', command.Name.CLICK, opt_elementOrButton, opt_button);\n  }\n  /**\n   * Double-clicks a mouse button.\n   *\n   * If an element is provided, the mouse will first be moved to the center of\n   * that element. This is equivalent to:\n   *\n   *     sequence.mouseMove(element).doubleClick()\n   *\n   * Warning: this method currently only supports the left mouse button. See\n   * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).\n   *\n   * @param {(./webdriver.WebElement|input.Button)=} opt_elementOrButton Either\n   *     the element to interact with or the button to click with.\n   *     Defaults to {@link input.Button.LEFT} if neither an element nor\n   *     button is specified.\n   * @param {input.Button=} opt_button The button to use. Defaults to\n   *     {@link input.Button.LEFT}. Ignored if a button is provided as the\n   *     first argument.\n   * @return {!ActionSequence} A self reference.\n   */\n\n\n  doubleClick(opt_elementOrButton, opt_button) {\n    return this.scheduleMouseAction_('doubleClick', command.Name.DOUBLE_CLICK, opt_elementOrButton, opt_button);\n  }\n  /**\n   * Schedules a keyboard action.\n   *\n   * @param {string} description A simple descriptive label for the scheduled\n   *     action.\n   * @param {!Array<(string|!input.Key)>} keys The keys to send.\n   * @return {!ActionSequence} A self reference.\n   * @private\n   */\n\n\n  scheduleKeyboardAction_(description, keys) {\n    let cmd = new command.Command(command.Name.SEND_KEYS_TO_ACTIVE_ELEMENT).setParameter('value', keys);\n    this.schedule_(description, cmd);\n    return this;\n  }\n  /**\n   * Performs a modifier key press. The modifier key is <em>not released</em>\n   * until {@link #keyUp} or {@link #sendKeys} is called. The key press will be\n   * targeted at the currently focused element.\n   *\n   * @param {!input.Key} key The modifier key to push. Must be one of\n   *     {ALT, CONTROL, SHIFT, COMMAND, META}.\n   * @return {!ActionSequence} A self reference.\n   * @throws {error.InvalidArgumentError} If the key is not a valid modifier\n   *     key.\n   */\n\n\n  keyDown(key) {\n    checkModifierKey(key);\n    return this.scheduleKeyboardAction_('keyDown', [key]);\n  }\n  /**\n   * Performs a modifier key release. The release is targeted at the currently\n   * focused element.\n   * @param {!input.Key} key The modifier key to release. Must be one of\n   *     {ALT, CONTROL, SHIFT, COMMAND, META}.\n   * @return {!ActionSequence} A self reference.\n   * @throws {error.InvalidArgumentError} If the key is not a valid modifier\n   *     key.\n   */\n\n\n  keyUp(key) {\n    checkModifierKey(key);\n    return this.scheduleKeyboardAction_('keyUp', [key]);\n  }\n  /**\n   * Simulates typing multiple keys. Each modifier key encountered in the\n   * sequence will not be released until it is encountered again. All key events\n   * will be targeted at the currently focused element.\n   *\n   * @param {...(string|!input.Key|!Array<(string|!input.Key)>)} var_args\n   *     The keys to type.\n   * @return {!ActionSequence} A self reference.\n   * @throws {Error} If the key is not a valid modifier key.\n   */\n\n\n  sendKeys(var_args) {\n    let keys = flatten(arguments);\n    return this.scheduleKeyboardAction_('sendKeys', keys);\n  }\n\n}\n/**\n * Class for defining sequences of user touch interactions. Each sequence\n * will not be executed until {@link #perform} is called.\n *\n * This class should not be instantiated directly. Instead, obtain an instance\n * using {@link ./webdriver.WebDriver#touchActions() WebDriver.touchActions()}.\n *\n * Sample usage:\n *\n *     driver.touchActions().\n *         tapAndHold({x: 0, y: 0}).\n *         move({x: 3, y: 4}).\n *         release({x: 10, y: 10}).\n *         perform();\n *\n */\n\n\nclass TouchSequence {\n  /**\n   * @param {!./webdriver.WebDriver} driver The driver that should be used to\n   *     perform this action sequence.\n   */\n  constructor(driver) {\n    /** @private {!./webdriver.WebDriver} */\n    this.driver_ = driver;\n    /** @private {!Array<{description: string, command: !command.Command}>} */\n\n    this.actions_ = [];\n  }\n  /**\n   * Schedules an action to be executed each time {@link #perform} is called on\n   * this instance.\n   * @param {string} description A description of the command.\n   * @param {!command.Command} command The command.\n   * @private\n   */\n\n\n  schedule_(description, command) {\n    this.actions_.push({\n      description: description,\n      command: command\n    });\n  }\n  /**\n   * Executes this action sequence.\n   * @return {!./promise.Thenable} A promise that will be resolved once\n   *     this sequence has completed.\n   */\n\n\n  perform() {\n    // Make a protected copy of the scheduled actions. This will protect against\n    // users defining additional commands before this sequence is actually\n    // executed.\n    let actions = this.actions_.concat();\n    let driver = this.driver_;\n    return driver.controlFlow().execute(function () {\n      let results = actions.map(action => {\n        return driver.schedule(action.command, action.description);\n      });\n      return Promise.all(results);\n    }, 'TouchSequence.perform');\n  }\n  /**\n   * Taps an element.\n   *\n   * @param {!./webdriver.WebElement} elem The element to tap.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  tap(elem) {\n    let cmd = new command.Command(command.Name.TOUCH_SINGLE_TAP).setParameter('element', elem.getId());\n    this.schedule_('tap', cmd);\n    return this;\n  }\n  /**\n   * Double taps an element.\n   *\n   * @param {!./webdriver.WebElement} elem The element to double tap.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  doubleTap(elem) {\n    let cmd = new command.Command(command.Name.TOUCH_DOUBLE_TAP).setParameter('element', elem.getId());\n    this.schedule_('doubleTap', cmd);\n    return this;\n  }\n  /**\n   * Long press on an element.\n   *\n   * @param {!./webdriver.WebElement} elem The element to long press.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  longPress(elem) {\n    let cmd = new command.Command(command.Name.TOUCH_LONG_PRESS).setParameter('element', elem.getId());\n    this.schedule_('longPress', cmd);\n    return this;\n  }\n  /**\n   * Touch down at the given location.\n   *\n   * @param {{x: number, y: number}} location The location to touch down at.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  tapAndHold(location) {\n    let cmd = new command.Command(command.Name.TOUCH_DOWN).setParameter('x', location.x).setParameter('y', location.y);\n    this.schedule_('tapAndHold', cmd);\n    return this;\n  }\n  /**\n   * Move a held {@linkplain #tapAndHold touch} to the specified location.\n   *\n   * @param {{x: number, y: number}} location The location to move to.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  move(location) {\n    let cmd = new command.Command(command.Name.TOUCH_MOVE).setParameter('x', location.x).setParameter('y', location.y);\n    this.schedule_('move', cmd);\n    return this;\n  }\n  /**\n   * Release a held {@linkplain #tapAndHold touch} at the specified location.\n   *\n   * @param {{x: number, y: number}} location The location to release at.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  release(location) {\n    let cmd = new command.Command(command.Name.TOUCH_UP).setParameter('x', location.x).setParameter('y', location.y);\n    this.schedule_('release', cmd);\n    return this;\n  }\n  /**\n   * Scrolls the touch screen by the given offset.\n   *\n   * @param {{x: number, y: number}} offset The offset to scroll to.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  scroll(offset) {\n    let cmd = new command.Command(command.Name.TOUCH_SCROLL).setParameter('xoffset', offset.x).setParameter('yoffset', offset.y);\n    this.schedule_('scroll', cmd);\n    return this;\n  }\n  /**\n   * Scrolls the touch screen, starting on `elem` and moving by the specified\n   * offset.\n   *\n   * @param {!./webdriver.WebElement} elem The element where scroll starts.\n   * @param {{x: number, y: number}} offset The offset to scroll to.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  scrollFromElement(elem, offset) {\n    let cmd = new command.Command(command.Name.TOUCH_SCROLL).setParameter('element', elem.getId()).setParameter('xoffset', offset.x).setParameter('yoffset', offset.y);\n    this.schedule_('scrollFromElement', cmd);\n    return this;\n  }\n  /**\n   * Flick, starting anywhere on the screen, at speed xspeed and yspeed.\n   *\n   * @param {{xspeed: number, yspeed: number}} speed The speed to flick in each\n         direction, in pixels per second.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  flick(speed) {\n    let cmd = new command.Command(command.Name.TOUCH_FLICK).setParameter('xspeed', speed.xspeed).setParameter('yspeed', speed.yspeed);\n    this.schedule_('flick', cmd);\n    return this;\n  }\n  /**\n   * Flick starting at elem and moving by x and y at specified speed.\n   *\n   * @param {!./webdriver.WebElement} elem The element where flick starts.\n   * @param {{x: number, y: number}} offset The offset to flick to.\n   * @param {number} speed The speed to flick at in pixels per second.\n   * @return {!TouchSequence} A self reference.\n   */\n\n\n  flickElement(elem, offset, speed) {\n    let cmd = new command.Command(command.Name.TOUCH_FLICK).setParameter('element', elem.getId()).setParameter('xoffset', offset.x).setParameter('yoffset', offset.y).setParameter('speed', speed);\n    this.schedule_('flickElement', cmd);\n    return this;\n  }\n\n} // PUBLIC API\n\n\nmodule.exports = {\n  ActionSequence: ActionSequence,\n  TouchSequence: TouchSequence\n};","map":null,"metadata":{},"sourceType":"script"}