{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\"); // Will use chalk if chalk is available to add color to console logging\n\n\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\n\ntry {\n  chalk = require('chalk');\n  printRed = chalk.red;\n  printYellow = chalk.yellow;\n  printGray = chalk.gray;\n} catch (e) {\n  printRed = printYellow = printGray = msg => {\n    return msg;\n  };\n}\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\nvar WriteTo;\n\n(function (WriteTo) {\n  WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n  WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n  WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n  WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\n\nlet logFile = 'webdriver.log'; // the default log file name\n\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\n\nclass Logger {\n  /**\n   * Creates a logger instance with an ID for the logger.\n   * @constructor\n   */\n  constructor(id) {\n    this.id = id;\n  }\n  /**\n   * Set up the write location. If writing to a file, get the file descriptor.\n   * @param writeTo The enum for where to write the logs.\n   * @param opt_logFile An optional parameter to override the log file location.\n   */\n\n\n  static setWrite(writeTo, opt_logFile) {\n    if (opt_logFile) {\n      logFile = opt_logFile;\n    }\n\n    Logger.writeTo = writeTo;\n\n    if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n      Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n      Logger.firstWrite = false;\n    }\n  }\n  /**\n   * Log INFO\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  info(...msgs) {\n    this.log_(LogLevel.INFO, msgs);\n  }\n  /**\n   * Log DEBUG\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  debug(...msgs) {\n    this.log_(LogLevel.DEBUG, msgs);\n  }\n  /**\n   * Log WARN\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  warn(...msgs) {\n    this.log_(LogLevel.WARN, msgs);\n  }\n  /**\n   * Log ERROR\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  error(...msgs) {\n    this.log_(LogLevel.ERROR, msgs);\n  }\n  /**\n   * For the log level set, check to see if the messages should be logged.\n   * @param logLevel The log level of the message.\n   * @param msgs The messages to be logged\n   */\n\n\n  log_(logLevel, msgs) {\n    switch (Logger.logLevel) {\n      case LogLevel.ERROR:\n        if (logLevel <= LogLevel.ERROR) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      case LogLevel.WARN:\n        if (logLevel <= LogLevel.WARN) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      case LogLevel.INFO:\n        if (logLevel <= LogLevel.INFO) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      case LogLevel.DEBUG:\n        if (logLevel <= LogLevel.DEBUG) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      default:\n        throw new Error('Log level undefined');\n    }\n  }\n  /**\n   * Format with timestamp, log level, identifier, and message and log to\n   * specified medium (console, file, both, none).\n   * @param logLevel The log level of the message.\n   * @param msgs The messages to be logged.\n   */\n\n\n  print_(logLevel, msgs) {\n    let consoleLog = '';\n    let fileLog = '';\n\n    if (Logger.showTimestamp) {\n      consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n      fileLog += Logger.timestamp_(WriteTo.FILE);\n    }\n\n    consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n    fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n\n    if (Logger.showId) {\n      consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n      fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n    }\n\n    consoleLog += ' -';\n    fileLog += ' - ';\n\n    switch (Logger.writeTo) {\n      case WriteTo.CONSOLE:\n        msgs.unshift(consoleLog);\n        console.log.apply(console, msgs);\n        break;\n\n      case WriteTo.FILE:\n        // for the first line written to the file, add a space\n        if (!Logger.firstWrite) {\n          fs.writeSync(Logger.fd, '\\n');\n          Logger.firstWrite = true;\n        }\n\n        fileLog += ' ' + Logger.msgToFile_(msgs);\n        fs.writeSync(Logger.fd, fileLog + '\\n');\n        break;\n\n      case WriteTo.BOTH:\n        // for the first line written to the file, add a space\n        if (!Logger.firstWrite) {\n          fs.writeSync(Logger.fd, '\\n');\n          Logger.firstWrite = true;\n        }\n\n        fileLog += ' ' + Logger.msgToFile_(msgs);\n        fs.writeSync(Logger.fd, fileLog + '\\n');\n        msgs.unshift(consoleLog);\n        console.log.apply(console, msgs);\n        break;\n\n      case WriteTo.NONE:\n        break;\n    }\n  }\n  /**\n   * Get a timestamp formatted with [hh:mm:ss]\n   * @param writeTo The enum for where to write the logs.\n   * @return The string of the formatted timestamp\n   */\n\n\n  static timestamp_(writeTo) {\n    let d = new Date();\n    let ts = '[';\n    let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n    let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n    let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n\n    if (writeTo == WriteTo.CONSOLE) {\n      ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n    } else {\n      ts += hours + ':' + minutes + ':' + seconds + ']';\n    }\n\n    ts += ' ';\n    return ts;\n  }\n  /**\n   * Get the identifier of the logger as '/<id>'\n   * @param logLevel The log level of the message.\n   * @param writeTo The enum for where to write the logs.\n   * @return The string of the formatted id\n   */\n\n\n  static id_(logLevel, id, writeTo) {\n    let level = LogLevel[logLevel].toString();\n\n    if (writeTo === WriteTo.FILE) {\n      return '/' + id;\n    } else if (logLevel === LogLevel.ERROR) {\n      return printRed('/' + id);\n    } else if (logLevel === LogLevel.WARN) {\n      return printYellow('/' + id);\n    } else {\n      return '/' + id;\n    }\n  }\n  /**\n   * Get the log level formatted with the first letter. For info, it is I.\n   * @param logLevel The log level of the message.\n   * @param writeTo The enum for where to write the logs.\n   * @return The string of the formatted log level\n   */\n\n\n  static level_(logLevel, id, writeTo) {\n    let level = LogLevel[logLevel].toString();\n\n    if (writeTo === WriteTo.FILE) {\n      return level[0];\n    } else if (logLevel === LogLevel.ERROR) {\n      return printRed(level[0]);\n    } else if (logLevel === LogLevel.WARN) {\n      return printYellow(level[0]);\n    } else {\n      return level[0];\n    }\n  }\n  /**\n   * Convert the list of messages to a single string message.\n   * @param msgs The list of messages.\n   * @return The string of the formatted messages\n   */\n\n\n  static msgToFile_(msgs) {\n    let log = '';\n\n    for (let pos = 0; pos < msgs.length; pos++) {\n      let msg = msgs[pos];\n      let ret;\n\n      if (typeof msg === 'object') {\n        ret = JSON.stringify(msg);\n      } else {\n        ret = msg;\n      }\n\n      if (pos !== msgs.length - 1) {\n        ret += ' ';\n      }\n\n      log += ret;\n    }\n\n    return log;\n  }\n\n}\n\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger; //# sourceMappingURL=logger.js.map","map":null,"metadata":{},"sourceType":"script"}