{"ast":null,"code":"/**\n * Copied from Protractor 5.2.0\n *\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunction waitForAngular(rootSelector, callback) {\n  try {\n    // Wait for both angular1 testability and angular2 testability.\n    var testCallback = callback; // Wait for angular1 testability first and run waitForAngular2 as a callback\n\n    var waitForAngular1 = function (callback) {\n      if (window.angular) {\n        var hooks = getNg1Hooks(rootSelector);\n\n        if (!hooks) {\n          callback(); // not an angular1 app\n        } else {\n          if (hooks.$$testability) {\n            hooks.$$testability.whenStable(callback);\n          } else if (hooks.$injector) {\n            hooks.$injector.get('$browser').notifyWhenNoOutstandingRequests(callback);\n          } else if (!!rootSelector) {\n            throw new Error('Could not automatically find injector on page: \"' + window.location.toString() + '\".  Consider using config.rootEl');\n          } else {\n            throw new Error('root element (' + rootSelector + ') has no injector.' + ' this may mean it is not inside ng-app.');\n          }\n        }\n      } else {\n        callback();\n      } // not an angular1 app\n\n    }; // Wait for Angular2 testability and then run test callback\n\n\n    var waitForAngular2 = function () {\n      if (window.getAngularTestability) {\n        if (rootSelector) {\n          var testability = null;\n          var el = document.querySelector(rootSelector);\n\n          try {\n            testability = window.getAngularTestability(el);\n          } catch (e) {}\n\n          if (testability) {\n            return testability.whenStable(testCallback);\n          }\n        } // Didn't specify root element or testability could not be found\n        // by rootSelector. This may happen in a hybrid app, which could have\n        // more than one root.\n\n\n        var testabilities = window.getAllAngularTestabilities();\n        var count = testabilities.length; // No angular2 testability, this happens when\n        // going to a hybrid page and going back to a pure angular1 page\n\n        if (count === 0) {\n          return testCallback();\n        }\n\n        var decrement = function () {\n          count--;\n\n          if (count === 0) {\n            testCallback();\n          }\n        };\n\n        testabilities.forEach(function (testability) {\n          testability.whenStable(decrement);\n        });\n      } else {\n        testCallback();\n      } // not an angular2 app\n\n    };\n\n    if (!window.angular && !window.getAngularTestability) {\n      // no testability hook\n      throw new Error('both angularJS testability and angular testability are undefined.' + '  This could be either ' + 'because this is a non-angular page or because your test involves ' + 'client-side navigation, which can interfere with Protractor\\'s ' + 'bootstrapping.  See http://git.io/v4gXM for details');\n    } else {\n      waitForAngular1(waitForAngular2);\n    } // Wait for angular1 and angular2\n    // Testability hooks sequentially\n\n  } catch (err) {\n    callback(err.message);\n  }\n}\n\n;\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\n\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n\n        if ($$testability) {\n          return {\n            $$testability: $$testability\n          };\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n\n        if ($injector) {\n          return {\n            $injector: $injector\n          };\n        }\n      }\n    } catch (err) {}\n  }\n\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n\n    return {\n      $injector: $injector,\n      $$testability: $$testability\n    };\n  } else {\n    return tryEl(document.body) || trySelector('[ng-app]') || trySelector('[ng\\\\:app]') || trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\n\n\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n\n  if (!helpers.length) {\n    return fun;\n  }\n\n  var FunClass = Function; // Get the linter to allow this eval\n\n  return new FunClass(helpers.join(';') + String.fromCharCode(59) + '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\nexports.NG_WAIT_FN = wrapWithHelpers(waitForAngular, getNg1Hooks);","map":null,"metadata":{},"sourceType":"script"}