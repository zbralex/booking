{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/** @fileoverview Utilities for working with Firefox extensions. */\n'use strict';\n\nconst fs = require('fs'),\n      path = require('path'),\n      xml = require('xml2js');\n\nconst io = require('../io');\n\nconst zip = require('../io/zip');\n/**\n * Thrown when there an add-on is malformed.\n */\n\n\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg);\n    /** @override */\n\n    this.name = this.constructor.name;\n  }\n\n}\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the extension to install, as either a xpi\n *     file or a directory.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\n\n\nfunction install(extension, dir) {\n  return getDetails(extension).then(function (details) {\n    var dst = path.join(dir, details.id);\n\n    if (extension.slice(-4) === '.xpi') {\n      if (!details.unpack) {\n        return io.copy(extension, dst + '.xpi').then(() => details.id);\n      } else {\n        return zip.unzip(extension, dst).then(() => details.id);\n      }\n    } else {\n      return io.copyDir(extension, dst).then(() => details.id);\n    }\n  });\n}\n/**\n * Describes a Firefox add-on.\n * @typedef {{id: string, name: string, version: string, unpack: boolean}}\n */\n\n\nvar AddonDetails;\n/** @typedef {{$: !Object<string, string>}} */\n\nvar RdfRoot;\n/**\n * Extracts the details needed to install an add-on.\n * @param {string} addonPath Path to the extension directory.\n * @return {!Promise<!AddonDetails>} A promise for the add-on details.\n */\n\nfunction getDetails(addonPath) {\n  return io.stat(addonPath).then(stats => {\n    if (stats.isDirectory()) {\n      return parseDirectory(addonPath);\n    } else if (addonPath.slice(-4) === '.xpi') {\n      return parseXpiFile(addonPath);\n    } else {\n      throw Error('Add-on path is not an xpi or a directory: ' + addonPath);\n    }\n  });\n  /**\n   * Parse an install.rdf for a Firefox add-on.\n   * @param {string} rdf The contents of install.rdf for the add-on.\n   * @return {!Promise<!AddonDetails>} A promise for the add-on details.\n   */\n\n  function parseInstallRdf(rdf) {\n    return parseXml(rdf).then(function (doc) {\n      var em = getNamespaceId(doc, 'http://www.mozilla.org/2004/em-rdf#');\n      var rdf = getNamespaceId(doc, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');\n      var description = doc[rdf + 'RDF'][rdf + 'Description'][0];\n      var details = {\n        id: getNodeText(description, em + 'id'),\n        name: getNodeText(description, em + 'name'),\n        version: getNodeText(description, em + 'version'),\n        unpack: getNodeText(description, em + 'unpack') || false\n      };\n\n      if (typeof details.unpack === 'string') {\n        details.unpack = details.unpack.toLowerCase() === 'true';\n      }\n\n      if (!details.id) {\n        throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n      }\n\n      return details;\n    });\n\n    function parseXml(text) {\n      return new Promise((resolve, reject) => {\n        xml.parseString(text, (err, data) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n\n    function getNodeText(node, name) {\n      return node[name] && node[name][0] || '';\n    }\n\n    function getNamespaceId(doc, url) {\n      var keys = Object.keys(doc);\n\n      if (keys.length !== 1) {\n        throw new AddonFormatError('Malformed manifest for add-on ' + addonPath);\n      }\n\n      var namespaces =\n      /** @type {!RdfRoot} */\n      doc[keys[0]].$;\n      var id = '';\n      Object.keys(namespaces).some(function (ns) {\n        if (namespaces[ns] !== url) {\n          return false;\n        }\n\n        if (ns.indexOf(':') != -1) {\n          id = ns.split(':')[1] + ':';\n        }\n\n        return true;\n      });\n      return id;\n    }\n  }\n  /**\n   * Parse a manifest for a Firefox WebExtension.\n   * @param {{\n   *   name: string,\n   *   version: string,\n   *   applications: {gecko:{id:string}}\n   * }} json JSON representation of the manifest.\n   * @return {!AddonDetails} The add-on details.\n   */\n\n\n  function parseManifestJson({\n    name,\n    version,\n    applications\n  }) {\n    if (!(applications && applications.gecko && applications.gecko.id)) {\n      throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n    }\n\n    return {\n      id: applications.gecko.id,\n      name,\n      version,\n      unpack: false\n    };\n  }\n\n  function parseXpiFile(filePath) {\n    return zip.load(filePath).then(archive => {\n      if (archive.has('install.rdf')) {\n        return archive.getFile('install.rdf').then(buf => parseInstallRdf(buf.toString('utf8')));\n      }\n\n      if (archive.has('manifest.json')) {\n        return archive.getFile('manifest.json').then(buf => JSON.parse(buf.toString('utf8'))).then(parseManifestJson);\n      }\n\n      throw new AddonFormatError(`Couldn't find install.rdf or manifest.json in ${filePath}`);\n    });\n  }\n\n  function parseDirectory(dirPath) {\n    const rdfPath = path.join(dirPath, 'install.rdf');\n    const jsonPath = path.join(dirPath, 'manifest.json');\n    return io.exists(rdfPath).then(rdfExists => {\n      if (rdfExists) {\n        return io.read(rdfPath).then(buf => parseInstallRdf(buf.toString('utf8')));\n      }\n\n      return io.exists(jsonPath).then(jsonExists => {\n        if (jsonExists) {\n          return io.read(jsonPath).then(buf => JSON.parse(buf.toString('utf8'))).then(parseManifestJson);\n        }\n\n        throw new AddonFormatError(`Couldn't find install.rdf or manifest.json in ${dirPath}`);\n      });\n    });\n  }\n} // PUBLIC API\n\n\nexports.install = install;","map":null,"metadata":{},"sourceType":"script"}