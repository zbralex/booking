{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\n\nclass Listener {\n  /**\n   * @param {!Function} fn The actual listener function.\n   * @param {(Object|undefined)} scope The object in whose scope to invoke the\n   *     listener.\n   * @param {boolean} oneshot Whether this listener should only be used once.\n   */\n  constructor(fn, scope, oneshot) {\n    this.fn = fn;\n    this.scope = scope;\n    this.oneshot = oneshot;\n  }\n\n}\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\n\n\nconst EVENTS = new WeakMap();\n/**\n * Object that can emit events for others to listen for.\n */\n\nclass EventEmitter {\n  /**\n   * Fires an event and calls all listeners.\n   * @param {string} type The type of event to emit.\n   * @param {...*} var_args Any arguments to pass to each listener.\n   */\n  emit(type, var_args) {\n    let events = EVENTS.get(this);\n\n    if (!events) {\n      return;\n    }\n\n    let args = Array.prototype.slice.call(arguments, 1);\n    let listeners = events.get(type);\n\n    if (listeners) {\n      for (let listener of listeners) {\n        listener.fn.apply(listener.scope, args);\n\n        if (listener.oneshot) {\n          listeners.delete(listener);\n        }\n      }\n    }\n  }\n  /**\n   * Returns a mutable list of listeners for a specific type of event.\n   * @param {string} type The type of event to retrieve the listeners for.\n   * @return {!Set<!Listener>} The registered listeners for the given event\n   *     type.\n   */\n\n\n  listeners(type) {\n    let events = EVENTS.get(this);\n\n    if (!events) {\n      events = new Map();\n      EVENTS.set(this, events);\n    }\n\n    let listeners = events.get(type);\n\n    if (!listeners) {\n      listeners = new Set();\n      events.set(type, listeners);\n    }\n\n    return listeners;\n  }\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n   *    the first event is fired.\n   * @return {!EventEmitter} A self reference.\n   * @private\n   */\n\n\n  addListener_(type, fn, opt_self, opt_oneshot) {\n    let listeners = this.listeners(type);\n\n    for (let listener of listeners) {\n      if (listener.fn === fn) {\n        return this;\n      }\n    }\n\n    listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n    return this;\n  }\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  addListener(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, false);\n  }\n  /**\n   * Registers a one-time listener which will be called only the first time an\n   * event is emitted, after which it will be removed.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  once(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, true);\n  }\n  /**\n   * An alias for {@link #addListener() addListener()}.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  on(type, fn, opt_self) {\n    return this.addListener(type, fn, opt_self);\n  }\n  /**\n   * Removes a previously registered event listener.\n   * @param {string} type The type of event to unregister.\n   * @param {!Function} listenerFn The handler function to remove.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  removeListener(type, listenerFn) {\n    if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n      throw TypeError('invalid args: expected (string, function), got (' + typeof type + ', ' + typeof listenerFn + ')');\n    }\n\n    let events = EVENTS.get(this);\n\n    if (!events) {\n      return this;\n    }\n\n    let listeners = events.get(type);\n\n    if (!listeners) {\n      return this;\n    }\n\n    let match;\n\n    for (let listener of listeners) {\n      if (listener.fn === listenerFn) {\n        match = listener;\n        break;\n      }\n    }\n\n    if (match) {\n      listeners.delete(match);\n\n      if (!listeners.size) {\n        events.delete(type);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Removes all listeners for a specific type of event. If no event is\n   * specified, all listeners across all types will be removed.\n   * @param {string=} opt_type The type of event to remove listeners from.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  removeAllListeners(opt_type) {\n    let events = EVENTS.get(this);\n\n    if (events) {\n      if (typeof opt_type === 'string') {\n        events.delete(opt_type);\n      } else {\n        EVENTS.delete(this);\n      }\n    }\n\n    return this;\n  }\n\n} // PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};","map":null,"metadata":{},"sourceType":"script"}