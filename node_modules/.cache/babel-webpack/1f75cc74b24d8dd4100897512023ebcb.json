{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * This is an implementation of the Local Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n *\n * TODO - it would be nice to do this in the launcher phase,\n * so that we only start the local selenium once per entire launch.\n */\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst q = require(\"q\");\n\nconst exitCodes_1 = require(\"../exitCodes\");\n\nconst logger_1 = require(\"../logger\");\n\nconst driverProvider_1 = require(\"./driverProvider\");\n\nconst SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\n\nconst remote = require('selenium-webdriver/remote');\n\nlet logger = new logger_1.Logger('local');\n\nclass Local extends driverProvider_1.DriverProvider {\n  constructor(config) {\n    super(config);\n    this.server_ = null;\n  }\n  /**\n   * Helper to locate the default jar path if none is provided by the user.\n   * @private\n   */\n\n\n  addDefaultBinaryLocs_() {\n    if (!this.config_.seleniumServerJar) {\n      logger.debug('Attempting to find the SeleniumServerJar in the default ' + 'location used by webdriver-manager');\n\n      try {\n        let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n        let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n        this.config_.seleniumServerJar = updateConfig.standalone.last;\n      } catch (err) {\n        throw new exitCodes_1.BrowserError(logger, 'No update-config.json found.' + ' Run \\'webdriver-manager update\\' to download binaries.');\n      }\n    }\n\n    if (!fs.existsSync(this.config_.seleniumServerJar)) {\n      throw new exitCodes_1.BrowserError(logger, 'No selenium server jar found at ' + this.config_.seleniumServerJar + '. Run \\'webdriver-manager update\\' to download binaries.');\n    }\n\n    if (this.config_.capabilities.browserName === 'chrome') {\n      if (!this.config_.chromeDriver) {\n        logger.debug('Attempting to find the chromedriver binary in the default ' + 'location used by webdriver-manager');\n\n        try {\n          let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n          let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n          this.config_.chromeDriver = updateConfig.chrome.last;\n        } catch (err) {\n          throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n        }\n      } // Check if file exists, if not try .exe or fail accordingly\n\n\n      if (!fs.existsSync(this.config_.chromeDriver)) {\n        if (fs.existsSync(this.config_.chromeDriver + '.exe')) {\n          this.config_.chromeDriver += '.exe';\n        } else {\n          throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + this.config_.chromeDriver + '. Run \\'webdriver-manager update\\' to download binaries.');\n        }\n      }\n    }\n\n    if (this.config_.capabilities.browserName === 'firefox') {\n      if (!this.config_.geckoDriver) {\n        logger.debug('Attempting to find the gecko driver binary in the default ' + 'location used by webdriver-manager');\n\n        try {\n          let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n          let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n          this.config_.geckoDriver = updateConfig.gecko.last;\n        } catch (err) {\n          throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n        }\n      } // Check if file exists, if not try .exe or fail accordingly\n\n\n      if (!fs.existsSync(this.config_.geckoDriver)) {\n        if (fs.existsSync(this.config_.geckoDriver + '.exe')) {\n          this.config_.geckoDriver += '.exe';\n        } else {\n          throw new exitCodes_1.BrowserError(logger, 'Could not find gecko driver at ' + this.config_.geckoDriver + '. Run \\'webdriver-manager update\\' to download binaries.');\n        }\n      }\n    }\n  }\n  /**\n   * Configure and launch (if applicable) the object's environment.\n   * @public\n   * @return {q.promise} A promise which will resolve when the environment is\n   *     ready to test.\n   */\n\n\n  setupDriverEnv() {\n    this.addDefaultBinaryLocs_();\n    logger.info('Starting selenium standalone server...');\n    let serverConf = this.config_.localSeleniumStandaloneOpts || {}; // If args or port is not set use seleniumArgs and seleniumPort\n    // for backward compatibility\n\n    if (serverConf.args === undefined) {\n      serverConf.args = this.config_.seleniumArgs || [];\n    }\n\n    if (serverConf.jvmArgs === undefined) {\n      serverConf.jvmArgs = this.config_.jvmArgs || [];\n    } else {\n      if (!Array.isArray(serverConf.jvmArgs)) {\n        throw new exitCodes_1.ConfigError(logger, 'jvmArgs should be an array.');\n      }\n    }\n\n    if (serverConf.port === undefined) {\n      serverConf.port = this.config_.seleniumPort;\n    } // configure server\n\n\n    if (this.config_.chromeDriver) {\n      serverConf.jvmArgs.push('-Dwebdriver.chrome.driver=' + this.config_.chromeDriver);\n    }\n\n    if (this.config_.geckoDriver) {\n      serverConf.jvmArgs.push('-Dwebdriver.gecko.driver=' + this.config_.geckoDriver);\n    }\n\n    this.server_ = new remote.SeleniumServer(this.config_.seleniumServerJar, serverConf);\n    let deferred = q.defer(); // start local server, grab hosted address, and resolve promise\n\n    this.server_.start(this.config_.seleniumServerStartTimeout).then(url => {\n      logger.info('Selenium standalone server started at ' + url);\n      return this.server_.address();\n    }).then(address => {\n      this.config_.seleniumAddress = address;\n      deferred.resolve();\n    }).catch(err => {\n      deferred.reject(err);\n    });\n    return deferred.promise;\n  }\n  /**\n   * Teardown and destroy the environment and do any associated cleanup.\n   * Shuts down the drivers and server.\n   *\n   * @public\n   * @override\n   * @return {q.promise} A promise which will resolve when the environment\n   *     is down.\n   */\n\n\n  teardownEnv() {\n    return super.teardownEnv().then(() => {\n      logger.info('Shutting down selenium standalone server.');\n      return this.server_.stop();\n    });\n  }\n\n}\n\nexports.Local = Local; //# sourceMappingURL=local.js.map","map":null,"metadata":{},"sourceType":"script"}