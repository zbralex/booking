{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http = require(\"http\");\n\nconst url = require(\"url\");\n\nconst webdriver_commands_1 = require(\"./webdriver_commands\");\n/**\n * A proxy that understands WebDriver commands. Users can add barriers (similar to middleware in\n * express) that will be called before forwarding the request to WebDriver. The proxy will wait for\n * each barrier to finish, calling them in the order in which they were added.\n */\n\n\nclass WebDriverProxy {\n  constructor(seleniumAddress) {\n    this.barriers = [];\n    this.seleniumAddress = seleniumAddress;\n  }\n\n  addBarrier(barrier) {\n    this.barriers.push(barrier);\n  }\n\n  handleRequest(originalRequest, response) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let command = webdriver_commands_1.parseWebDriverCommand(originalRequest.url, originalRequest.method);\n\n      let replyWithError = err => {\n        response.writeHead(502);\n\n        if (err && err.toString) {\n          response.write(err.toString());\n        }\n\n        response.end();\n      }; // Process barriers in order, one at a time.\n\n\n      try {\n        for (let barrier of this.barriers) {\n          yield barrier.onCommand(command);\n        }\n      } catch (err) {\n        replyWithError(err); // Don't call through if a barrier fails.\n\n        return;\n      }\n\n      let parsedUrl = url.parse(this.seleniumAddress);\n      let options = {};\n      options.method = originalRequest.method;\n      options.path = parsedUrl.path + originalRequest.url;\n      options.hostname = parsedUrl.hostname;\n      options.port = parseInt(parsedUrl.port);\n      options.headers = originalRequest.headers;\n      let forwardedRequest = http.request(options); // clang-format off\n\n      let reqData = '';\n      originalRequest.on('data', d => {\n        reqData += d;\n        forwardedRequest.write(d);\n      }).on('end', () => {\n        command.handleData(reqData);\n        forwardedRequest.end();\n      }).on('error', replyWithError);\n      forwardedRequest.on('response', seleniumResponse => {\n        response.writeHead(seleniumResponse.statusCode, seleniumResponse.headers);\n        let respData = '';\n        seleniumResponse.on('data', d => {\n          respData += d;\n          response.write(d);\n        }).on('end', () => {\n          command.handleResponse(seleniumResponse.statusCode, respData);\n          response.end();\n        }).on('error', replyWithError);\n      }).on('error', replyWithError); // clang-format on\n    });\n  }\n\n}\n\nexports.WebDriverProxy = WebDriverProxy; //# sourceMappingURL=webdriver_proxy.js.map","map":null,"metadata":{},"sourceType":"script"}