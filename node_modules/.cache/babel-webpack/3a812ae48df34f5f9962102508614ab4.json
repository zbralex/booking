{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nconst jszip = require('jszip');\n\nconst path = require('path');\n\nconst io = require('./index');\n\nconst {\n  InvalidArgumentError\n} = require('../lib/error');\n/**\n * Manages a zip archive.\n */\n\n\nclass Zip {\n  constructor() {\n    /** @private @const */\n    this.z_ = new jszip();\n    /** @private @const {!Set<!Promise<?>>} */\n\n    this.pendingAdds_ = new Set();\n  }\n  /**\n   * Adds a file to this zip.\n   *\n   * @param {string} filePath path to the file to add.\n   * @param {string=} zipPath path to the file in the zip archive, defaults\n   *     to the basename of `filePath`.\n   * @return {!Promise<?>} a promise that will resolve when added.\n   */\n\n\n  addFile(filePath, zipPath = path.basename(filePath)) {\n    let add = io.read(filePath).then(buffer => this.z_.file(zipPath, buffer));\n    this.pendingAdds_.add(add);\n    return add.then(() => this.pendingAdds_.delete(add), e => {\n      this.pendingAdds_.delete(add);\n      throw e;\n    });\n  }\n  /**\n   * Recursively adds a directory and all of its contents to this archive.\n   *\n   * @param {string} dirPath path to the directory to add.\n   * @param {string=} zipPath path to the folder in the archive to add the\n   *     directory contents to. Defaults to the root folder.\n   * @return {!Promise<?>} returns a promise that will resolve when the\n   *     the operation is complete.\n   */\n\n\n  addDir(dirPath, zipPath = '') {\n    return io.walkDir(dirPath).then(entries => {\n      let archive = this.z_;\n\n      if (zipPath) {\n        archive = archive.folder(zipPath);\n      }\n\n      let files = [];\n      entries.forEach(spec => {\n        if (spec.dir) {\n          archive.folder(spec.path);\n        } else {\n          files.push(this.addFile(path.join(dirPath, spec.path), path.join(zipPath, spec.path)));\n        }\n      });\n      return Promise.all(files);\n    });\n  }\n  /**\n   * @param {string} path File path to test for within the archive.\n   * @return {boolean} Whether this zip archive contains an entry with the given\n   *     path.\n   */\n\n\n  has(path) {\n    return this.z_.file(path) !== null;\n  }\n  /**\n   * Returns the contents of the file in this zip archive with the given `path`.\n   * The returned promise will be rejected with an {@link InvalidArgumentError}\n   * if either `path` does not exist within the archive, or if `path` refers\n   * to a directory.\n   *\n   * @param {string} path the path to the file whose contents to return.\n   * @return {!Promise<!Buffer>} a promise that will be resolved with the file's\n   *     contents as a buffer.\n   */\n\n\n  getFile(path) {\n    let file = this.z_.file(path);\n\n    if (!file) {\n      return Promise.reject(new InvalidArgumentError(`No such file in zip archive: ${path}`));\n    }\n\n    if (file.dir) {\n      return Promise.reject(new InvalidArgumentError(`The requested file is a directory: ${path}`));\n    }\n\n    return Promise.resolve(file.async('nodebuffer'));\n  }\n  /**\n   * Returns the compressed data for this archive in a buffer. _This method will\n   * not wait for any outstanding {@link #addFile add}\n   * {@link #addDir operations} before encoding the archive._\n   *\n   * @param {string} compression The desired compression.\n   *     Must be `STORE` (the default) or `DEFLATE`.\n   * @return {!Promise<!Buffer>} a promise that will resolve with this archive\n   *     as a buffer.\n   */\n\n\n  toBuffer(compression = 'STORE') {\n    if (compression !== 'STORE' && compression !== 'DEFLATE') {\n      return Promise.reject(new InvalidArgumentError(`compression must be one of {STORE, DEFLATE}, got ${compression}`));\n    }\n\n    return Promise.resolve(this.z_.generateAsync({\n      compression,\n      type: 'nodebuffer'\n    }));\n  }\n\n}\n/**\n * Asynchronously opens a zip archive.\n *\n * @param {string} path to the zip archive to load.\n * @return {!Promise<!Zip>} a promise that will resolve with the opened\n *     archive.\n */\n\n\nfunction load(path) {\n  return io.read(path).then(data => {\n    let zip = new Zip();\n    return zip.z_.loadAsync(data).then(() => zip);\n  });\n}\n/**\n * Asynchronously unzips an archive file.\n *\n * @param {string} src path to the source file to unzip.\n * @param {string} dst path to the destination directory.\n * @return {!Promise<string>} a promise that will resolve with `dst` once the\n *     archive has been unzipped.\n */\n\n\nfunction unzip(src, dst) {\n  return load(src).then(zip => {\n    let promisedDirs = new Map();\n    let promises = [];\n    zip.z_.forEach((relPath, file) => {\n      let p;\n\n      if (file.dir) {\n        p = createDir(relPath);\n      } else {\n        let dirname = path.dirname(relPath);\n\n        if (dirname === '.') {\n          p = writeFile(relPath, file);\n        } else {\n          p = createDir(dirname).then(() => writeFile(relPath, file));\n        }\n      }\n\n      promises.push(p);\n    });\n    return Promise.all(promises).then(() => dst);\n\n    function createDir(dir) {\n      let p = promisedDirs.get(dir);\n\n      if (!p) {\n        p = io.mkdirp(path.join(dst, dir));\n        promisedDirs.set(dir, p);\n      }\n\n      return p;\n    }\n\n    function writeFile(relPath, file) {\n      return file.async('nodebuffer').then(buffer => io.write(path.join(dst, relPath), buffer));\n    }\n  });\n} // PUBLIC API\n\n\nexports.Zip = Zip;\nexports.load = load;\nexports.unzip = unzip;","map":null,"metadata":{},"sourceType":"script"}