{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst q = require(\"q\");\n\nconst webdriver = require(\"selenium-webdriver\");\n\nconst configParser_1 = require(\"./configParser\");\n\nconst logger_1 = require(\"./logger\");\n\nconst ptor_1 = require(\"./ptor\");\n\nlet logger = new logger_1.Logger('plugins');\nvar PromiseType;\n\n(function (PromiseType) {\n  PromiseType[PromiseType[\"Q\"] = 0] = \"Q\";\n  PromiseType[PromiseType[\"WEBDRIVER\"] = 1] = \"WEBDRIVER\";\n})(PromiseType = exports.PromiseType || (exports.PromiseType = {}));\n/**\n * The plugin API for Protractor.  Note that this API is unstable. See\n * plugins/README.md for more information.\n *\n * @constructor\n * @param {Object} config parsed from the config file\n */\n\n\nclass Plugins {\n  constructor(config) {\n    /**\n     * @see docs/plugins.md#writing-plugins for information on these functions\n     */\n    this.setup = this.pluginFunFactory('setup', PromiseType.Q);\n    this.onPrepare = this.pluginFunFactory('onPrepare', PromiseType.Q);\n    this.teardown = this.pluginFunFactory('teardown', PromiseType.Q);\n    this.postResults = this.pluginFunFactory('postResults', PromiseType.Q);\n    this.postTest = this.pluginFunFactory('postTest', PromiseType.Q);\n    this.onPageLoad = this.pluginFunFactory('onPageLoad', PromiseType.WEBDRIVER);\n    this.onPageStable = this.pluginFunFactory('onPageStable', PromiseType.WEBDRIVER);\n    this.waitForPromise = this.pluginFunFactory('waitForPromise', PromiseType.WEBDRIVER);\n    this.waitForCondition = this.pluginFunFactory('waitForCondition', PromiseType.WEBDRIVER, true);\n    this.pluginObjs = [];\n    this.assertions = {};\n    this.resultsReported = false;\n\n    if (config.plugins) {\n      config.plugins.forEach((pluginConf, i) => {\n        let path;\n\n        if (pluginConf.path) {\n          path = configParser_1.ConfigParser.resolveFilePatterns(pluginConf.path, true, config.configDir)[0];\n\n          if (!path) {\n            throw new Error('Invalid path to plugin: ' + pluginConf.path);\n          }\n        } else {\n          path = pluginConf.package;\n        }\n\n        let pluginObj;\n\n        if (path) {\n          pluginObj = require(path);\n        } else if (pluginConf.inline) {\n          pluginObj = pluginConf.inline;\n        } else {\n          throw new Error('Plugin configuration did not contain a valid path or ' + 'inline definition.');\n        }\n\n        this.annotatePluginObj(pluginObj, pluginConf, i);\n        logger.debug('Plugin \"' + pluginObj.name + '\" loaded.');\n        this.pluginObjs.push(pluginObj);\n      });\n    }\n  }\n\n  /**\n   * Adds properties to a plugin's object\n   *\n   * @see docs/plugins.md#provided-properties-and-functions\n   */\n  annotatePluginObj(obj, conf, i) {\n    let addAssertion = (info, passed, message) => {\n      if (this.resultsReported) {\n        throw new Error('Cannot add new tests results, since they were already ' + 'reported.');\n      }\n\n      info = info || {};\n      const specName = info.specName || obj.name + ' Plugin Tests';\n      const assertion = {\n        passed: passed\n      };\n\n      if (!passed) {\n        assertion.errorMsg = message;\n\n        if (info.stackTrace) {\n          assertion.stackTrace = info.stackTrace;\n        }\n      }\n\n      this.assertions[specName] = this.assertions[specName] || [];\n      this.assertions[specName].push(assertion);\n    };\n\n    obj.name = obj.name || conf.name || conf.path || conf.package || 'Plugin #' + i;\n    obj.config = conf;\n\n    obj.addFailure = (message, info) => {\n      addAssertion(info, false, message);\n    };\n\n    obj.addSuccess = options => {\n      addAssertion(options, true);\n    };\n\n    obj.addWarning = (message, options) => {\n      options = options || {};\n      logger.warn('Warning ' + (options.specName ? 'in ' + options.specName : 'from \"' + obj.name + '\" plugin') + ': ' + message);\n    };\n  }\n\n  printPluginResults(specResults) {\n    const green = '\\x1b[32m';\n    const red = '\\x1b[31m';\n    const normalColor = '\\x1b[39m';\n\n    const printResult = (message, pass) => {\n      logger.info(pass ? green : red, '\\t', pass ? 'Pass: ' : 'Fail: ', message, normalColor);\n    };\n\n    for (const specResult of specResults) {\n      const passed = specResult.assertions.map(x => x.passed).reduce((x, y) => x && y, true);\n      printResult(specResult.description, passed);\n\n      if (!passed) {\n        for (const assertion of specResult.assertions) {\n          if (!assertion.passed) {\n            logger.error('\\t\\t' + assertion.errorMsg);\n\n            if (assertion.stackTrace) {\n              logger.error('\\t\\t' + assertion.stackTrace.replace(/\\n/g, '\\n\\t\\t'));\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Gets the tests results generated by any plugins\n   *\n   * @see lib/frameworks/README.md#requirements for a complete description of what\n   *     the results object must look like\n   *\n   * @return {Object} The results object\n   */\n\n\n  getResults() {\n    const results = {\n      failedCount: 0,\n      specResults: []\n    };\n\n    for (const specName in this.assertions) {\n      results.specResults.push({\n        description: specName,\n        assertions: this.assertions[specName]\n      });\n      results.failedCount += this.assertions[specName].filter(assertion => !assertion.passed).length;\n    }\n\n    this.printPluginResults(results.specResults);\n    this.resultsReported = true;\n    return results;\n  }\n\n  /**\n   * Returns true if any loaded plugin has skipAngularStability enabled.\n   *\n   * @return {boolean}\n   */\n  skipAngularStability() {\n    const result = this.pluginObjs.some(pluginObj => pluginObj.skipAngularStability);\n    return result;\n  }\n\n  /**\n   * Calls a function from a plugin safely.  If the plugin's function throws an\n   * exception or returns a rejected promise, that failure will be logged as a\n   * failed test result instead of crashing protractor.  If the tests results have\n   * already been reported, the failure will be logged to the console.\n   *\n   * @param {Object} pluginObj The plugin object containing the function to be run\n   * @param {string} funName The name of the function we want to run\n   * @param {*[]} args The arguments we want to invoke the function with\n   * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that\n   *    should be used\n   * @param {boolean} resultsReported If the results have already been reported\n   * @param {*} failReturnVal The value to return if the function fails\n   *\n   * @return {webdriver.promise.Promise|Q.Promise} A promise which resolves to the\n   *     function's return value\n   */\n  safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal) {\n    const resolver = done => {\n      const logError = e => {\n        if (this.resultsReported) {\n          this.printPluginResults([{\n            description: pluginObj.name + ' Runtime',\n            assertions: [{\n              passed: false,\n              errorMsg: 'Failure during ' + funName + ': ' + (e.message || e),\n              stackTrace: e.stack\n            }]\n          }]);\n        } else {\n          pluginObj.addFailure('Failure during ' + funName + ': ' + e.message || e, {\n            stackTrace: e.stack\n          });\n        }\n\n        done(failReturnVal);\n      };\n\n      try {\n        const result = pluginObj[funName].apply(pluginObj, args);\n\n        if (webdriver.promise.isPromise(result)) {\n          result.then(done, logError);\n        } else {\n          done(result);\n        }\n      } catch (e) {\n        logError(e);\n      }\n    };\n\n    if (promiseType == PromiseType.Q) {\n      return q.Promise(resolver);\n    } else if (ptor_1.protractor.browser.controlFlowIsEnabled()) {\n      return new webdriver.promise.Promise(resolver);\n    } else {\n      return new Promise(resolver);\n    }\n  }\n\n  pluginFunFactory(funName, promiseType, failReturnVal) {\n    return (...args) => {\n      const promises = this.pluginObjs.filter(pluginObj => typeof pluginObj[funName] === 'function').map(pluginObj => this.safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal));\n      return promiseType == PromiseType.Q ? q.all(promises) : webdriver.promise.all(promises);\n    };\n  }\n\n}\n\nexports.Plugins = Plugins; //# sourceMappingURL=plugins.js.map","map":null,"metadata":{},"sourceType":"script"}