{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview\n *\n * > ### IMPORTANT NOTICE\n * >\n * > The promise manager contained in this module is in the process of being\n * > phased out in favor of native JavaScript promises. This will be a long\n * > process and will not be completed until there have been two major LTS Node\n * > releases (approx. Node v10.0) that support\n * > [async functions](https://tc39.github.io/ecmascript-asyncawait/).\n * >\n * > At this time, the promise manager can be disabled by setting an environment\n * > variable, `SELENIUM_PROMISE_MANAGER=0`. In the absence of async functions,\n * > users may use generators with the\n * > {@link ./promise.consume promise.consume()} function to write \"synchronous\"\n * > style tests:\n * >\n * > ```js\n * > const {Builder, By, Key, promise, until} = require('selenium-webdriver');\n * >\n * > let result = promise.consume(function* doGoogleSearch() {\n * >   let driver = new Builder().forBrowser('firefox').build();\n * >   yield driver.get('http://www.google.com/ncr');\n * >   yield driver.findElement(By.name('q')).sendKeys('webdriver', Key.RETURN);\n * >   yield driver.wait(until.titleIs('webdriver - Google Search'), 1000);\n * >   yield driver.quit();\n * > });\n * >\n * > result.then(_ => console.log('SUCCESS!'),\n * >             e => console.error('FAILURE: ' + e));\n * > ```\n * >\n * > The motivation behind this change and full deprecation plan are documented\n * > in [issue 2969](https://github.com/SeleniumHQ/selenium/issues/2969).\n * >\n * >\n *\n * The promise module is centered around the {@linkplain ControlFlow}, a class\n * that coordinates the execution of asynchronous tasks. The ControlFlow allows\n * users to focus on the imperative commands for their script without worrying\n * about chaining together every single asynchronous action, which can be\n * tedious and verbose. APIs may be layered on top of the control flow to read\n * as if they were synchronous. For instance, the core\n * {@linkplain ./webdriver.WebDriver WebDriver} API is built on top of the\n * control flow, allowing users to write\n *\n *     driver.get('http://www.google.com/ncr');\n *     driver.findElement({name: 'q'}).sendKeys('webdriver', Key.RETURN);\n *\n * instead of\n *\n *     driver.get('http://www.google.com/ncr')\n *     .then(function() {\n *       return driver.findElement({name: 'q'});\n *     })\n *     .then(function(q) {\n *       return q.sendKeys('webdriver', Key.RETURN);\n *     });\n *\n * ## Tasks and Task Queues\n *\n * The control flow is based on the concept of tasks and task queues. Tasks are\n * functions that define the basic unit of work for the control flow to execute.\n * Each task is scheduled via {@link ControlFlow#execute()}, which will return\n * a {@link ManagedPromise} that will be resolved with the task's result.\n *\n * A task queue contains all of the tasks scheduled within a single turn of the\n * [JavaScript event loop][JSEL]. The control flow will create a new task queue\n * the first time a task is scheduled within an event loop.\n *\n *     var flow = promise.controlFlow();\n *     flow.execute(foo);       // Creates a new task queue and inserts foo.\n *     flow.execute(bar);       // Inserts bar into the same queue as foo.\n *     setTimeout(function() {\n *       flow.execute(baz);     // Creates a new task queue and inserts baz.\n *     }, 0);\n *\n * Whenever the control flow creates a new task queue, it will automatically\n * begin executing tasks in the next available turn of the event loop. This\n * execution is [scheduled as a microtask][MicrotasksArticle] like e.g. a\n * (native) `Promise.then()` callback.\n *\n *     setTimeout(() => console.log('a'));\n *     Promise.resolve().then(() => console.log('b'));  // A native promise.\n *     flow.execute(() => console.log('c'));\n *     Promise.resolve().then(() => console.log('d'));\n *     setTimeout(() => console.log('fin'));\n *     // b\n *     // c\n *     // d\n *     // a\n *     // fin\n *\n * In the example above, b/c/d is logged before a/fin because native promises\n * and this module use \"microtask\" timers, which have a higher priority than\n * \"macrotasks\" like `setTimeout`.\n *\n * ## Task Execution\n *\n * Upon creating a task queue, and whenever an existing queue completes a task,\n * the control flow will schedule a microtask timer to process any scheduled\n * tasks. This ensures no task is ever started within the same turn of the\n * JavaScript event loop in which it was scheduled, nor is a task ever started\n * within the same turn that another finishes.\n *\n * When the execution timer fires, a single task will be dequeued and executed.\n * There are several important events that may occur while executing a task\n * function:\n *\n * 1. A new task queue is created by a call to {@link ControlFlow#execute()}.\n *    Any tasks scheduled within this task queue are considered subtasks of the\n *    current task.\n * 2. The task function throws an error. Any scheduled tasks are immediately\n *    discarded and the task's promised result (previously returned by\n *    {@link ControlFlow#execute()}) is immediately rejected with the thrown\n *    error.\n * 3. The task function returns successfully.\n *\n * If a task function created a new task queue, the control flow will wait for\n * that queue to complete before processing the task result. If the queue\n * completes without error, the flow will settle the task's promise with the\n * value originally returned by the task function. On the other hand, if the task\n * queue terminates with an error, the task's promise will be rejected with that\n * error.\n *\n *     flow.execute(function() {\n *       flow.execute(() => console.log('a'));\n *       flow.execute(() => console.log('b'));\n *     });\n *     flow.execute(() => console.log('c'));\n *     // a\n *     // b\n *     // c\n *\n * ## ManagedPromise Integration\n *\n * In addition to the {@link ControlFlow} class, the promise module also exports\n * a [Promises/A+] {@linkplain ManagedPromise implementation} that is deeply\n * integrated with the ControlFlow. First and foremost, each promise\n * {@linkplain ManagedPromise#then() callback} is scheduled with the\n * control flow as a task. As a result, each callback is invoked in its own turn\n * of the JavaScript event loop with its own task queue. If any tasks are\n * scheduled within a callback, the callback's promised result will not be\n * settled until the task queue has completed.\n *\n *     promise.fulfilled().then(function() {\n *       flow.execute(function() {\n *         console.log('b');\n *       });\n *     }).then(() => console.log('a'));\n *     // b\n *     // a\n *\n * ### Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a>\n *\n * How callbacks are scheduled in the control flow depends on when they are\n * attached to the promise. Callbacks attached to a _previously_ resolved\n * promise are immediately enqueued as subtasks of the currently running task.\n *\n *     var p = promise.fulfilled();\n *     flow.execute(function() {\n *       flow.execute(() => console.log('A'));\n *       p.then(      () => console.log('B'));\n *       flow.execute(() => console.log('C'));\n *       p.then(      () => console.log('D'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * When a promise is resolved while a task function is on the call stack, any\n * callbacks also registered in that stack frame are scheduled as if the promise\n * were already resolved:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * Callbacks attached to an _unresolved_ promise within a task function are\n * only weakly scheduled as subtasks and will be dropped if they reach the\n * front of the queue before the promise is resolved. In the example below, the\n * callbacks for `B` & `D` are dropped as sub-tasks since they are attached to\n * an unresolved promise when they reach the front of the task queue.\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       setTimeout(d.fulfill, 20);\n *     }).then(function() {\n *       console.log('fin')\n *     });\n *     // A\n *     // C\n *     // fin\n *     // B\n *     // D\n *\n * If a promise is resolved while a task function is on the call stack, any\n * previously registered and unqueued callbacks (i.e. either attached while no\n * task was on the call stack, or previously dropped as described above) act as\n * _interrupts_ and are inserted at the front of the task queue. If multiple\n * promises are fulfilled, their interrupts are enqueued in the order the\n * promises are resolved.\n *\n *     var d1 = promise.defer();\n *     d1.promise.then(() => console.log('A'));\n *\n *     var d2 = promise.defer();\n *     d2.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       d1.promise.then(() => console.log('C'));\n *       flow.execute(() => console.log('D'));\n *     });\n *     flow.execute(function() {\n *       flow.execute(() => console.log('E'));\n *       flow.execute(() => console.log('F'));\n *       d1.fulfill();\n *       d2.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // D\n *     // A\n *     // C\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Within a task function (or callback), each step of a promise chain acts as\n * an interrupt on the task queue:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       d.promise.\n *           then(() => console.log('A')).\n *           then(() => console.log('B')).\n *           then(() => console.log('C')).\n *           then(() => console.log('D'));\n *\n *       flow.execute(() => console.log('E'));\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // fin\n *\n * If there are multiple promise chains derived from a single promise, they are\n * processed in the order created:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       var chain = d.promise.then(() => console.log('A'));\n *\n *       chain.then(() => console.log('B')).\n *           then(() => console.log('C'));\n *\n *       chain.then(() => console.log('D')).\n *           then(() => console.log('E'));\n *\n *       flow.execute(() => console.log('F'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // fin\n *\n * Even though a subtask's promised result will never resolve while the task\n * function is on the stack, it will be treated as a promise resolved within the\n * task. In all other scenarios, a task's promise behaves just like a normal\n * promise. In the sample below, `C/D` is logged before `B` because the\n * resolution of `subtask1` interrupts the flow of the enclosing task. Within\n * the final subtask, `E/F` is logged in order because `subtask1` is a resolved\n * promise when that task runs.\n *\n *     flow.execute(function() {\n *       var subtask1 = flow.execute(() => console.log('A'));\n *       var subtask2 = flow.execute(() => console.log('B'));\n *\n *       subtask1.then(() => console.log('C'));\n *       subtask1.then(() => console.log('D'));\n *\n *       flow.execute(function() {\n *         flow.execute(() => console.log('E'));\n *         subtask1.then(() => console.log('F'));\n *       });\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // C\n *     // D\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Finally, consider the following:\n *\n *     var d = promise.defer();\n *     d.promise.then(() => console.log('A'));\n *     d.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       flow.execute(  () => console.log('E'));\n *       d.promise.then(() => console.log('F'));\n *\n *       d.fulfill();\n *\n *       flow.execute(  () => console.log('G'));\n *       d.promise.then(() => console.log('H'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // G\n *     // H\n *     // fin\n *\n * In this example, callbacks are registered on `d.promise` both before and\n * during the invocation of the task function. When `d.fulfill()` is called,\n * the callbacks registered before the task (`A` & `B`) are registered as\n * interrupts. The remaining callbacks were all attached within the task and\n * are scheduled in the flow as standard tasks.\n *\n * ## Generator Support\n *\n * [Generators][GF] may be scheduled as tasks within a control flow or attached\n * as callbacks to a promise. Each time the generator yields a promise, the\n * control flow will wait for that promise to settle before executing the next\n * iteration of the generator. The yielded promise's fulfilled value will be\n * passed back into the generator:\n *\n *     flow.execute(function* () {\n *       var d = promise.defer();\n *\n *       setTimeout(() => console.log('...waiting...'), 25);\n *       setTimeout(() => d.fulfill(123), 50);\n *\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield d.promise;\n *       console.log('mid: %d; value = %d', Date.now(), value);\n *\n *       yield promise.delayed(10);\n *       console.log('end: ' + Date.now());\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // ...waiting...\n *     // mid: 50; value = 123\n *     // end: 60\n *     // fin\n *\n * Yielding the result of a promise chain will wait for the entire chain to\n * complete:\n *\n *     promise.fulfilled().then(function* () {\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield flow.\n *           execute(() => console.log('A')).\n *           then(   () => console.log('B')).\n *           then(   () => 123);\n *\n *       console.log('mid: %s; value = %d', Date.now(), value);\n *\n *       yield flow.execute(() => console.log('C'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // A\n *     // B\n *     // mid: 2; value = 123\n *     // C\n *     // fin\n *\n * Yielding a _rejected_ promise will cause the rejected value to be thrown\n * within the generator function:\n *\n *     flow.execute(function* () {\n *       console.log('start: ' + Date.now());\n *       try {\n *         yield promise.delayed(10).then(function() {\n *           throw Error('boom');\n *         });\n *       } catch (ex) {\n *         console.log('caught time: ' + Date.now());\n *         console.log(ex.message);\n *       }\n *     });\n *     // start: 0\n *     // caught time: 10\n *     // boom\n *\n * # Error Handling\n *\n * ES6 promises do not require users to handle a promise rejections. This can\n * result in subtle bugs as the rejections are silently \"swallowed\" by the\n * Promise class.\n *\n *     Promise.reject(Error('boom'));\n *     // ... *crickets* ...\n *\n * Selenium's promise module, on the other hand, requires that every rejection\n * be explicitly handled. When a {@linkplain ManagedPromise ManagedPromise} is\n * rejected and no callbacks are defined on that promise, it is considered an\n * _unhandled rejection_ and reported to the active task queue. If the rejection\n * remains unhandled after a single turn of the [event loop][JSEL] (scheduled\n * with a microtask), it will propagate up the stack.\n *\n * ## Error Propagation\n *\n * If an unhandled rejection occurs within a task function, that task's promised\n * result is rejected and all remaining subtasks are discarded:\n *\n *     flow.execute(function() {\n *       // No callbacks registered on promise -> unhandled rejection\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('this will never run'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * The promised results for discarded tasks are silently rejected with a\n * cancellation error and existing callback chains will never fire.\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('a'); }).\n *           then(function() { console.log('b'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * An unhandled rejection takes precedence over a task function's returned\n * result, even if that value is another promise:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       return flow.execute(someOtherTask);\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * If there are multiple unhandled rejections within a task, they are packaged\n * in a {@link MultipleUnhandledRejectionError}, which has an `errors` property\n * that is a `Set` of the recorded unhandled rejections:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom1'));\n *       promise.rejected(Error('boom2'));\n *     }).catch(function(ex) {\n *       console.log(ex instanceof MultipleUnhandledRejectionError);\n *       for (var e of ex.errors) {\n *         console.log(e.message);\n *       }\n *     });\n *     // boom1\n *     // boom2\n *\n * When a subtask is discarded due to an unreported rejection in its parent\n * frame, the existing callbacks on that task will never settle and the\n * callbacks will not be invoked. If a new callback is attached to the subtask\n * _after_ it has been discarded, it is handled the same as adding a callback\n * to a cancelled promise: the error-callback path is invoked. This behavior is\n * intended to handle cases where the user saves a reference to a task promise,\n * as illustrated below.\n *\n *     var subTask;\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       subTask = flow.execute(function() {});\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     }).then(function() {\n *       return subTask.then(\n *           () => console.log('subtask success!'),\n *           (e) => console.log('subtask failed:\\n' + e));\n *     });\n *     // boom\n *     // subtask failed:\n *     // DiscardedTaskError: Task was discarded due to a previous failure: boom\n *\n * When a subtask fails, its promised result is treated the same as any other\n * promise: it must be handled within one turn of the rejection or the unhandled\n * rejection is propagated to the parent task. This means users can catch errors\n * from complex flows from the top level task:\n *\n *     flow.execute(function() {\n *       flow.execute(function() {\n *         flow.execute(function() {\n *           throw Error('fail!');\n *         });\n *       });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // fail!\n *\n * ## Unhandled Rejection Events\n *\n * When an unhandled rejection propagates to the root of the control flow, the\n * flow will emit an __uncaughtException__ event. If no listeners are registered\n * on the flow, the error will be rethrown to the global error handler: an\n * __uncaughtException__ event from the\n * [`process`](https://nodejs.org/api/process.html) object in node, or\n * `window.onerror` when running in a browser.\n *\n * Bottom line: you __*must*__ handle rejected promises.\n *\n * # Promises/A+ Compatibility\n *\n * This `promise` module is compliant with the [Promises/A+] specification\n * except for sections `2.2.6.1` and `2.2.6.2`:\n *\n * >\n * > - `then` may be called multiple times on the same promise.\n * >    - If/when `promise` is fulfilled, all respective `onFulfilled` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >    - If/when `promise` is rejected, all respective `onRejected` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >\n *\n * Specifically, the conformance tests contain the following scenario (for\n * brevity, only the fulfillment version is shown):\n *\n *     var p1 = Promise.resolve();\n *     p1.then(function() {\n *       console.log('A');\n *       p1.then(() => console.log('B'));\n *     });\n *     p1.then(() => console.log('C'));\n *     // A\n *     // C\n *     // B\n *\n * Since the [ControlFlow](#scheduling_callbacks) executes promise callbacks as\n * tasks, with this module, the result would be:\n *\n *     var p2 = promise.fulfilled();\n *     p2.then(function() {\n *       console.log('A');\n *       p2.then(() => console.log('B');\n *     });\n *     p2.then(() => console.log('C'));\n *     // A\n *     // B\n *     // C\n *\n * [JSEL]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n * [GF]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n * [Promises/A+]: https://promisesaplus.com/\n * [MicrotasksArticle]: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n */\n'use strict';\n\nconst error = require('./error');\n\nconst events = require('./events');\n\nconst logging = require('./logging');\n/**\n * Alias to help with readability and differentiate types.\n * @const\n */\n\n\nconst NativePromise = Promise;\n/**\n * Whether to append traces of `then` to rejection errors.\n * @type {boolean}\n */\n\nvar LONG_STACK_TRACES = false; // TODO: this should not be CONSTANT_CASE\n\n/** @const */\n\nconst LOG = logging.getLogger('promise');\nconst UNIQUE_IDS = new WeakMap();\nlet nextId = 1;\n\nfunction getUid(obj) {\n  let id = UNIQUE_IDS.get(obj);\n\n  if (!id) {\n    id = nextId;\n    nextId += 1;\n    UNIQUE_IDS.set(obj, id);\n  }\n\n  return id;\n}\n/**\n * Runs the given function after a microtask yield.\n * @param {function()} fn The function to run.\n */\n\n\nfunction asyncRun(fn) {\n  NativePromise.resolve().then(function () {\n    try {\n      fn();\n    } catch (ignored) {// Do nothing.\n    }\n  });\n}\n/**\n * @param {number} level What level of verbosity to log with.\n * @param {(string|function(this: T): string)} loggable The message to log.\n * @param {T=} opt_self The object in whose context to run the loggable\n *     function.\n * @template T\n */\n\n\nfunction vlog(level, loggable, opt_self) {\n  var logLevel = logging.Level.FINE;\n\n  if (level > 1) {\n    logLevel = logging.Level.FINEST;\n  } else if (level > 0) {\n    logLevel = logging.Level.FINER;\n  }\n\n  if (typeof loggable === 'function') {\n    loggable = loggable.bind(opt_self);\n  }\n\n  LOG.log(logLevel, loggable);\n}\n/**\n * Generates an error to capture the current stack trace.\n * @param {string} name Error name for this stack trace.\n * @param {string} msg Message to record.\n * @param {Function=} opt_topFn The function that should appear at the top of\n *     the stack; only applicable in V8.\n * @return {!Error} The generated error.\n */\n\n\nfunction captureStackTrace(name, msg, opt_topFn) {\n  var e = Error(msg);\n  e.name = name;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, opt_topFn);\n  } else {\n    var stack = Error().stack;\n\n    if (stack) {\n      e.stack = e.toString();\n      e.stack += '\\n' + stack;\n    }\n  }\n\n  return e;\n}\n/**\n * Error used when the computation of a promise is cancelled.\n */\n\n\nclass CancellationError extends Error {\n  /**\n   * @param {string=} opt_msg The cancellation message.\n   */\n  constructor(opt_msg) {\n    super(opt_msg);\n    /** @override */\n\n    this.name = this.constructor.name;\n    /** @private {boolean} */\n\n    this.silent_ = false;\n  }\n  /**\n   * Wraps the given error in a CancellationError.\n   *\n   * @param {*} error The error to wrap.\n   * @param {string=} opt_msg The prefix message to use.\n   * @return {!CancellationError} A cancellation error.\n   */\n\n\n  static wrap(error, opt_msg) {\n    var message;\n\n    if (error instanceof CancellationError) {\n      return new CancellationError(opt_msg ? opt_msg + ': ' + error.message : error.message);\n    } else if (opt_msg) {\n      message = opt_msg;\n\n      if (error) {\n        message += ': ' + error;\n      }\n\n      return new CancellationError(message);\n    }\n\n    if (error) {\n      message = error + '';\n    }\n\n    return new CancellationError(message);\n  }\n\n}\n/**\n * Error used to cancel tasks when a control flow is reset.\n * @final\n */\n\n\nclass FlowResetError extends CancellationError {\n  constructor() {\n    super('ControlFlow was reset');\n    this.silent_ = true;\n  }\n\n}\n/**\n * Error used to cancel tasks that have been discarded due to an uncaught error\n * reported earlier in the control flow.\n * @final\n */\n\n\nclass DiscardedTaskError extends CancellationError {\n  /** @param {*} error The original error. */\n  constructor(error) {\n    if (error instanceof DiscardedTaskError) {\n      return error;\n    }\n\n    var msg = '';\n\n    if (error) {\n      msg = ': ' + (typeof error.message === 'string' ? error.message : error);\n    }\n\n    super('Task was discarded due to a previous failure' + msg);\n    this.silent_ = true;\n  }\n\n}\n/**\n * Error used when there are multiple unhandled promise rejections detected\n * within a task or callback.\n *\n * @final\n */\n\n\nclass MultipleUnhandledRejectionError extends Error {\n  /**\n   * @param {!(Set<*>)} errors The errors to report.\n   */\n  constructor(errors) {\n    super('Multiple unhandled promise rejections reported');\n    /** @override */\n\n    this.name = this.constructor.name;\n    /** @type {!Set<*>} */\n\n    this.errors = errors;\n  }\n\n}\n/**\n * Property used to flag constructor's as implementing the Thenable interface\n * for runtime type checking.\n * @const\n */\n\n\nconst IMPLEMENTED_BY_SYMBOL = Symbol('promise.Thenable');\nconst CANCELLABLE_SYMBOL = Symbol('promise.CancellableThenable');\n/**\n * @param {function(new: ?)} ctor\n * @param {!Object} symbol\n */\n\nfunction addMarkerSymbol(ctor, symbol) {\n  try {\n    ctor.prototype[symbol] = true;\n  } catch (ignored) {// Property access denied?\n  }\n}\n/**\n * @param {*} object\n * @param {!Object} symbol\n * @return {boolean}\n */\n\n\nfunction hasMarkerSymbol(object, symbol) {\n  if (!object) {\n    return false;\n  }\n\n  try {\n    return !!object[symbol];\n  } catch (e) {\n    return false; // Property access seems to be forbidden.\n  }\n}\n/**\n * Thenable is a promise-like object with a {@code then} method which may be\n * used to schedule callbacks on a promised value.\n *\n * @record\n * @extends {IThenable<T>}\n * @template T\n */\n\n\nclass Thenable {\n  /**\n   * Adds a property to a class prototype to allow runtime checks of whether\n   * instances of that class implement the Thenable interface.\n   * @param {function(new: Thenable, ...?)} ctor The\n   *     constructor whose prototype to modify.\n   */\n  static addImplementation(ctor) {\n    addMarkerSymbol(ctor, IMPLEMENTED_BY_SYMBOL);\n  }\n  /**\n   * Checks if an object has been tagged for implementing the Thenable\n   * interface as defined by {@link Thenable.addImplementation}.\n   * @param {*} object The object to test.\n   * @return {boolean} Whether the object is an implementation of the Thenable\n   *     interface.\n   */\n\n\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, IMPLEMENTED_BY_SYMBOL);\n  }\n  /**\n   * Registers listeners for when this instance is resolved.\n   *\n   * @param {?(function(T): (R|IThenable<R>))=} opt_callback The\n   *     function to call if this promise is successfully resolved. The function\n   *     should expect a single argument: the promise's resolved value.\n   * @param {?(function(*): (R|IThenable<R>))=} opt_errback\n   *     The function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n\n\n  then(opt_callback, opt_errback) {}\n  /**\n   * Registers a listener for when this promise is rejected. This is synonymous\n   * with the {@code catch} clause in a synchronous API:\n   *\n   *     // Synchronous API:\n   *     try {\n   *       doSynchronousWork();\n   *     } catch (ex) {\n   *       console.error(ex);\n   *     }\n   *\n   *     // Asynchronous promise API:\n   *     doAsynchronousWork().catch(function(ex) {\n   *       console.error(ex);\n   *     });\n   *\n   * @param {function(*): (R|IThenable<R>)} errback The\n   *     function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n\n\n  catch(errback) {}\n\n}\n/**\n * Marker interface for objects that allow consumers to request the cancellation\n * of a promise-based operation. A cancelled promise will be rejected with a\n * {@link CancellationError}.\n *\n * This interface is considered package-private and should not be used outside\n * of selenium-webdriver.\n *\n * @interface\n * @extends {Thenable<T>}\n * @template T\n * @package\n */\n\n\nclass CancellableThenable {\n  /**\n   * @param {function(new: CancellableThenable, ...?)} ctor\n   */\n  static addImplementation(ctor) {\n    Thenable.addImplementation(ctor);\n    addMarkerSymbol(ctor, CANCELLABLE_SYMBOL);\n  }\n  /**\n   * @param {*} object\n   * @return {boolean}\n   */\n\n\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, CANCELLABLE_SYMBOL);\n  }\n  /**\n   * Requests the cancellation of the computation of this promise's value,\n   * rejecting the promise in the process. This method is a no-op if the promise\n   * has already been resolved.\n   *\n   * @param {(string|Error)=} opt_reason The reason this promise is being\n   *     cancelled. This value will be wrapped in a {@link CancellationError}.\n   */\n\n\n  cancel(opt_reason) {}\n\n}\n/**\n * @enum {string}\n */\n\n\nconst PromiseState = {\n  PENDING: 'pending',\n  BLOCKED: 'blocked',\n  REJECTED: 'rejected',\n  FULFILLED: 'fulfilled'\n};\n/**\n * Internal map used to store cancellation handlers for {@link ManagedPromise}\n * objects. This is an internal implementation detail used by the\n * {@link TaskQueue} class to monitor for when a promise is cancelled without\n * generating an extra promise via then().\n *\n * @const {!WeakMap<!ManagedPromise, function(!CancellationError)>}\n */\n\nconst ON_CANCEL_HANDLER = new WeakMap();\nconst SKIP_LOG = Symbol('skip-log');\nconst FLOW_LOG = logging.getLogger('promise.ControlFlow');\n/**\n * Represents the eventual value of a completed operation. Each promise may be\n * in one of three states: pending, fulfilled, or rejected. Each promise starts\n * in the pending state and may make a single transition to either a\n * fulfilled or rejected state, at which point the promise is considered\n * resolved.\n *\n * @implements {CancellableThenable<T>}\n * @template T\n * @see http://promises-aplus.github.io/promises-spec/\n */\n\nclass ManagedPromise {\n  /**\n   * @param {function(\n   *           function((T|IThenable<T>|Thenable)=),\n   *           function(*=))} resolver\n   *     Function that is invoked immediately to begin computation of this\n   *     promise's value. The function should accept a pair of callback\n   *     functions, one for fulfilling the promise and another for rejecting it.\n   * @param {ControlFlow=} opt_flow The control flow\n   *     this instance was created under. Defaults to the currently active flow.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(resolver, opt_flow, opt_skipLog) {\n    if (!usePromiseManager()) {\n      throw TypeError('Unable to create a managed promise instance: the promise manager has' + ' been disabled by the SELENIUM_PROMISE_MANAGER environment' + ' variable: ' + process.env['SELENIUM_PROMISE_MANAGER']);\n    } else if (opt_skipLog !== SKIP_LOG) {\n      FLOW_LOG.warning(() => {\n        let e = captureStackTrace('ManagedPromiseError', 'Creating a new managed Promise. This call will fail when the' + ' promise manager is disabled', ManagedPromise);\n        return e.stack;\n      });\n    }\n\n    getUid(this);\n    /** @private {!ControlFlow} */\n\n    this.flow_ = opt_flow || controlFlow();\n    /** @private {Error} */\n\n    this.stack_ = null;\n\n    if (LONG_STACK_TRACES) {\n      this.stack_ = captureStackTrace('ManagedPromise', 'new', this.constructor);\n    }\n    /** @private {Thenable<?>} */\n\n\n    this.parent_ = null;\n    /** @private {Array<!Task>} */\n\n    this.callbacks_ = null;\n    /** @private {PromiseState} */\n\n    this.state_ = PromiseState.PENDING;\n    /** @private {boolean} */\n\n    this.handled_ = false;\n    /** @private {*} */\n\n    this.value_ = undefined;\n    /** @private {TaskQueue} */\n\n    this.queue_ = null;\n\n    try {\n      var self = this;\n      resolver(function (value) {\n        self.resolve_(PromiseState.FULFILLED, value);\n      }, function (reason) {\n        self.resolve_(PromiseState.REJECTED, reason);\n      });\n    } catch (ex) {\n      this.resolve_(PromiseState.REJECTED, ex);\n    }\n  }\n  /**\n   * Creates a promise that is immediately resolved with the given value.\n   *\n   * @param {T=} opt_value The value to resolve.\n   * @return {!ManagedPromise<T>} A promise resolved with the given value.\n   * @template T\n   */\n\n\n  static resolve(opt_value) {\n    if (opt_value instanceof ManagedPromise) {\n      return opt_value;\n    }\n\n    return new ManagedPromise(resolve => resolve(opt_value));\n  }\n  /**\n   * Creates a promise that is immediately rejected with the given reason.\n   *\n   * @param {*=} opt_reason The rejection reason.\n   * @return {!ManagedPromise<?>} A new rejected promise.\n   */\n\n\n  static reject(opt_reason) {\n    return new ManagedPromise((_, reject) => reject(opt_reason));\n  }\n  /** @override */\n\n\n  toString() {\n    return 'ManagedPromise::' + getUid(this) + ' {[[PromiseStatus]]: \"' + this.state_ + '\"}';\n  }\n  /**\n   * Resolves this promise. If the new value is itself a promise, this function\n   * will wait for it to be resolved before notifying the registered listeners.\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @throws {TypeError} If {@code newValue === this}.\n   * @private\n   */\n\n\n  resolve_(newState, newValue) {\n    if (PromiseState.PENDING !== this.state_) {\n      return;\n    }\n\n    if (newValue === this) {\n      // See promise a+, 2.3.1\n      // http://promises-aplus.github.io/promises-spec/#point-48\n      newValue = new TypeError('A promise may not resolve to itself');\n      newState = PromiseState.REJECTED;\n    }\n\n    this.parent_ = null;\n    this.state_ = PromiseState.BLOCKED;\n\n    if (newState !== PromiseState.REJECTED) {\n      if (Thenable.isImplementation(newValue)) {\n        // 2.3.2\n        newValue = newValue;\n        this.parent_ = newValue;\n        newValue.then(this.unblockAndResolve_.bind(this, PromiseState.FULFILLED), this.unblockAndResolve_.bind(this, PromiseState.REJECTED));\n        return;\n      } else if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        // 2.3.3\n        try {\n          // 2.3.3.1\n          var then = newValue['then'];\n        } catch (e) {\n          // 2.3.3.2\n          this.state_ = PromiseState.REJECTED;\n          this.value_ = e;\n          this.scheduleNotifications_();\n          return;\n        }\n\n        if (typeof then === 'function') {\n          // 2.3.3.3\n          this.invokeThen_(newValue, then);\n          return;\n        }\n      }\n    }\n\n    if (newState === PromiseState.REJECTED && isError(newValue) && newValue.stack && this.stack_) {\n      newValue.stack += '\\nFrom: ' + (this.stack_.stack || this.stack_);\n    } // 2.3.3.4 and 2.3.4\n\n\n    this.state_ = newState;\n    this.value_ = newValue;\n    this.scheduleNotifications_();\n  }\n  /**\n   * Invokes a thenable's \"then\" method according to 2.3.3.3 of the promise\n   * A+ spec.\n   * @param {!Object} x The thenable object.\n   * @param {!Function} then The \"then\" function to invoke.\n   * @private\n   */\n\n\n  invokeThen_(x, then) {\n    var called = false;\n    var self = this;\n\n    var resolvePromise = function (value) {\n      if (!called) {\n        // 2.3.3.3.3\n        called = true; // 2.3.3.3.1\n\n        self.unblockAndResolve_(PromiseState.FULFILLED, value);\n      }\n    };\n\n    var rejectPromise = function (reason) {\n      if (!called) {\n        // 2.3.3.3.3\n        called = true; // 2.3.3.3.2\n\n        self.unblockAndResolve_(PromiseState.REJECTED, reason);\n      }\n    };\n\n    try {\n      // 2.3.3.3\n      then.call(x, resolvePromise, rejectPromise);\n    } catch (e) {\n      // 2.3.3.3.4.2\n      rejectPromise(e);\n    }\n  }\n  /**\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @private\n   */\n\n\n  unblockAndResolve_(newState, newValue) {\n    if (this.state_ === PromiseState.BLOCKED) {\n      this.state_ = PromiseState.PENDING;\n      this.resolve_(newState, newValue);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  scheduleNotifications_() {\n    vlog(2, () => this + ' scheduling notifications', this);\n    ON_CANCEL_HANDLER.delete(this);\n\n    if (this.value_ instanceof CancellationError && this.value_.silent_) {\n      this.callbacks_ = null;\n    }\n\n    if (!this.queue_) {\n      this.queue_ = this.flow_.getActiveQueue_();\n    }\n\n    if (!this.handled_ && this.state_ === PromiseState.REJECTED && !(this.value_ instanceof CancellationError)) {\n      this.queue_.addUnhandledRejection(this);\n    }\n\n    this.queue_.scheduleCallbacks(this);\n  }\n  /** @override */\n\n\n  cancel(opt_reason) {\n    if (!canCancel(this)) {\n      return;\n    }\n\n    if (this.parent_ && canCancel(this.parent_)) {\n      /** @type {!CancellableThenable} */\n      this.parent_.cancel(opt_reason);\n    } else {\n      var reason = CancellationError.wrap(opt_reason);\n      let onCancel = ON_CANCEL_HANDLER.get(this);\n\n      if (onCancel) {\n        onCancel(reason);\n        ON_CANCEL_HANDLER.delete(this);\n      }\n\n      if (this.state_ === PromiseState.BLOCKED) {\n        this.unblockAndResolve_(PromiseState.REJECTED, reason);\n      } else {\n        this.resolve_(PromiseState.REJECTED, reason);\n      }\n    }\n\n    function canCancel(promise) {\n      if (!(promise instanceof ManagedPromise)) {\n        return CancellableThenable.isImplementation(promise);\n      }\n\n      return promise.state_ === PromiseState.PENDING || promise.state_ === PromiseState.BLOCKED;\n    }\n  }\n  /** @override */\n\n\n  then(opt_callback, opt_errback) {\n    return this.addCallback_(opt_callback, opt_errback, 'then', ManagedPromise.prototype.then);\n  }\n  /** @override */\n\n\n  catch(errback) {\n    return this.addCallback_(null, errback, 'catch', ManagedPromise.prototype.catch);\n  }\n  /**\n   * @param {function(): (R|IThenable<R>)} callback\n   * @return {!ManagedPromise<R>}\n   * @template R\n   * @see ./promise.finally()\n   */\n\n\n  finally(callback) {\n    let result = thenFinally(this, callback);\n    return result;\n  }\n  /**\n   * Registers a new callback with this promise\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @param {string} name The callback name.\n   * @param {!Function} fn The function to use as the top of the stack when\n   *     recording the callback's creation point.\n   * @return {!ManagedPromise<R>} A new promise which will be resolved with the\n   *     result of the invoked callback.\n   * @template R\n   * @private\n   */\n\n\n  addCallback_(callback, errback, name, fn) {\n    if (typeof callback !== 'function' && typeof errback !== 'function') {\n      return this;\n    }\n\n    this.handled_ = true;\n\n    if (this.queue_) {\n      this.queue_.clearUnhandledRejection(this);\n    }\n\n    var cb = new Task(this.flow_, this.invokeCallback_.bind(this, callback, errback), name, LONG_STACK_TRACES ? {\n      name: 'Promise',\n      top: fn\n    } : undefined);\n    cb.promise.parent_ = this;\n\n    if (this.state_ !== PromiseState.PENDING && this.state_ !== PromiseState.BLOCKED) {\n      this.flow_.getActiveQueue_().enqueue(cb);\n    } else {\n      if (!this.callbacks_) {\n        this.callbacks_ = [];\n      }\n\n      this.callbacks_.push(cb);\n      cb.blocked = true;\n      this.flow_.getActiveQueue_().enqueue(cb);\n    }\n\n    return cb.promise;\n  }\n  /**\n   * Invokes a callback function attached to this promise.\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @template R\n   * @private\n   */\n\n\n  invokeCallback_(callback, errback) {\n    var callbackFn = callback;\n\n    if (this.state_ === PromiseState.REJECTED) {\n      callbackFn = errback;\n    }\n\n    if (typeof callbackFn === 'function') {\n      if (isGenerator(callbackFn)) {\n        return consume(callbackFn, null, this.value_);\n      }\n\n      return callbackFn(this.value_);\n    } else if (this.state_ === PromiseState.REJECTED) {\n      throw this.value_;\n    } else {\n      return this.value_;\n    }\n  }\n\n}\n\nCancellableThenable.addImplementation(ManagedPromise);\n/**\n * @param {!ManagedPromise} promise\n * @return {boolean}\n */\n\nfunction isPending(promise) {\n  return promise.state_ === PromiseState.PENDING;\n}\n/**\n * Structural interface for a deferred promise resolver.\n * @record\n * @template T\n */\n\n\nfunction Resolver() {}\n/**\n * The promised value for this resolver.\n * @type {!Thenable<T>}\n */\n\n\nResolver.prototype.promise;\n/**\n * Resolves the promised value with the given `value`.\n * @param {T|Thenable<T>} value\n * @return {void}\n */\n\nResolver.prototype.resolve;\n/**\n * Rejects the promised value with the given `reason`.\n * @param {*} reason\n * @return {void}\n */\n\nResolver.prototype.reject;\n/**\n * Represents a value that will be resolved at some point in the future. This\n * class represents the protected \"producer\" half of a ManagedPromise - each Deferred\n * has a {@code promise} property that may be returned to consumers for\n * registering callbacks, reserving the ability to resolve the deferred to the\n * producer.\n *\n * If this Deferred is rejected and there are no listeners registered before\n * the next turn of the event loop, the rejection will be passed to the\n * {@link ControlFlow} as an unhandled failure.\n *\n * @template T\n * @implements {Resolver<T>}\n */\n\nclass Deferred {\n  /**\n   * @param {ControlFlow=} opt_flow The control flow this instance was\n   *     created under. This should only be provided during unit tests.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(opt_flow, opt_skipLog) {\n    var fulfill, reject;\n    /** @type {!ManagedPromise<T>} */\n\n    this.promise = new ManagedPromise(function (f, r) {\n      fulfill = f;\n      reject = r;\n    }, opt_flow, opt_skipLog);\n    var self = this;\n\n    var checkNotSelf = function (value) {\n      if (value === self) {\n        throw new TypeError('May not resolve a Deferred with itself');\n      }\n    };\n    /**\n     * Resolves this deferred with the given value. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {(T|IThenable<T>|Thenable)=} opt_value The fulfilled value.\n     * @const\n     */\n\n\n    this.resolve = function (opt_value) {\n      checkNotSelf(opt_value);\n      fulfill(opt_value);\n    };\n    /**\n     * An alias for {@link #resolve}.\n     * @const\n     */\n\n\n    this.fulfill = this.resolve;\n    /**\n     * Rejects this promise with the given reason. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {*=} opt_reason The rejection reason.\n     * @const\n     */\n\n    this.reject = function (opt_reason) {\n      checkNotSelf(opt_reason);\n      reject(opt_reason);\n    };\n  }\n\n}\n/**\n * Tests if a value is an Error-like object. This is more than an straight\n * instanceof check since the value may originate from another context.\n * @param {*} value The value to test.\n * @return {boolean} Whether the value is an error.\n */\n\n\nfunction isError(value) {\n  return value instanceof Error || !!value && typeof value === 'object' && typeof value.message === 'string';\n}\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\n\n\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value && (typeof value === 'object' || typeof value === 'function') && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Thenable} The promise.\n */\n\n\nfunction delayed(ms) {\n  return createPromise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n/**\n * Creates a new deferred resolver.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@link Deferred} instance. Otherwise, it will return a resolver for a\n * {@linkplain NativePromise native promise}.\n *\n * @return {!Resolver<T>} A new deferred resolver.\n * @template T\n */\n\n\nfunction defer() {\n  if (usePromiseManager()) {\n    return new Deferred();\n  }\n\n  let resolve, reject;\n  let promise = new NativePromise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n/**\n * Creates a promise that has been resolved with the given value.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {T=} opt_value The resolved value.\n * @return {!Thenable<T>} The resolved promise.\n * @template T\n */\n\n\nfunction fulfilled(opt_value) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n\n  if (opt_value instanceof ctor) {\n    return opt_value;\n  }\n\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(resolve => resolve(opt_value), undefined, SKIP_LOG);\n  }\n\n  return NativePromise.resolve(opt_value);\n}\n/**\n * Creates a promise that has been rejected with the given reason.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {*=} opt_reason The rejection reason; may be any value, but is\n *     usually an Error or a string.\n * @return {!Thenable<?>} The rejected promise.\n */\n\n\nfunction rejected(opt_reason) {\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise((_, reject) => reject(opt_reason), undefined, SKIP_LOG);\n  }\n\n  return NativePromise.reject(opt_reason);\n}\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} var_args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\n\n\nfunction checkedNodeCall(fn, var_args) {\n  let args = Array.prototype.slice.call(arguments, 1);\n  return createPromise(function (fulfill, reject) {\n    try {\n      args.push(function (error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n      fn.apply(undefined, args);\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!IThenable<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\n\n\nfunction thenFinally(promise, callback) {\n  let error;\n  let mustThrow = false;\n  return promise.then(function () {\n    return callback();\n  }, function (err) {\n    error = err;\n    mustThrow = true;\n    return callback();\n  }).then(function () {\n    if (mustThrow) {\n      throw error;\n    }\n  });\n}\n/**\n * Registers an observer on a promised {@code value}, returning a new promise\n * that will be resolved when the value is. If {@code value} is not a promise,\n * then the return promise will be immediately resolved.\n * @param {*} value The value to observe.\n * @param {Function=} opt_callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n * @return {!Thenable} A new promise.\n * @deprecated Use `promise.fulfilled(value).then(opt_callback, opt_errback)`\n */\n\n\nfunction when(value, opt_callback, opt_errback) {\n  return fulfilled(value).then(opt_callback, opt_errback);\n}\n/**\n * Invokes the appropriate callback function as soon as a promised `value` is\n * resolved.\n *\n * @param {*} value The value to observe.\n * @param {Function} callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n */\n\n\nfunction asap(value, callback, opt_errback) {\n  if (isPromise(value)) {\n    value.then(callback, opt_errback);\n  } else if (callback) {\n    callback(value);\n  }\n}\n/**\n * Given an array of promises, will return a promise that will be fulfilled\n * with the fulfillment values of the input array's values. If any of the\n * input array's promises are rejected, the returned promise will be rejected\n * with the same reason.\n *\n * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of\n *     promises to wait on.\n * @return {!Thenable<!Array<T>>} A promise that is\n *     fulfilled with an array containing the fulfilled values of the\n *     input array, or rejected with the same reason as the first\n *     rejected value.\n * @template T\n */\n\n\nfunction all(arr) {\n  return createPromise(function (fulfill, reject) {\n    var n = arr.length;\n    var values = [];\n\n    if (!n) {\n      fulfill(values);\n      return;\n    }\n\n    var toFulfill = n;\n\n    var onFulfilled = function (index, value) {\n      values[index] = value;\n      toFulfill--;\n\n      if (toFulfill == 0) {\n        fulfill(values);\n      }\n    };\n\n    function processPromise(index) {\n      asap(arr[index], function (value) {\n        onFulfilled(index, value);\n      }, reject);\n    }\n\n    for (var i = 0; i < n; ++i) {\n      processPromise(i);\n    }\n  });\n}\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\n\n\nfunction map(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n\n    var arr = v;\n    return createPromise(function (fulfill, reject) {\n      var n = arr.length;\n      var values = new Array(n);\n\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n\n        try {\n          asap(fn.call(opt_self, arr[i], i, arr), function (value) {\n            values[i] = value;\n            processNext(i + 1);\n          }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|ManagedPromise<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\n\n\nfunction filter(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n\n    var arr = v;\n    return createPromise(function (fulfill, reject) {\n      var n = arr.length;\n      var values = [];\n      var valuesLength = 0;\n\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n\n        try {\n          var value = arr[i];\n          var include = fn.call(opt_self, value, i, arr);\n          asap(include, function (include) {\n            if (include) {\n              values[valuesLength++] = value;\n            }\n\n            processNext(i + 1);\n          }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\n\n\nfunction fullyResolved(value) {\n  if (isPromise(value)) {\n    return fulfilled(value).then(fullyResolveValue);\n  }\n\n  return fullyResolveValue(value);\n}\n/**\n * @param {*} value The value to fully resolve. If a promise, assumed to\n *     already be resolved.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\n\n\nfunction fullyResolveValue(value) {\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(value);\n  }\n\n  if (isPromise(value)) {\n    if (isPromise(value)) {\n      // We get here when the original input value is a promise that\n      // resolves to itself. When the user provides us with such a promise,\n      // trust that it counts as a \"fully resolved\" value and return it.\n      // Of course, since it's already a promise, we can just return it\n      // to the user instead of wrapping it in another promise.\n      return value;\n    }\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(value);\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(value);\n  }\n\n  return createPromise(resolve => resolve(value));\n}\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\n\n\nfunction fullyResolveKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : function () {\n    let n = 0;\n\n    for (let key in obj) {\n      n += 1;\n    }\n\n    return n;\n  }();\n\n  if (!numKeys) {\n    return createPromise(resolve => resolve(obj));\n  }\n\n  function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n\n  function forEachElement(arr, fn) {\n    arr.forEach(fn);\n  }\n\n  var numResolved = 0;\n  return createPromise(function (fulfill, reject) {\n    var forEachKey = isArray ? forEachElement : forEachProperty;\n    forEachKey(obj, function (partialValue, key) {\n      if (!Array.isArray(partialValue) && (!partialValue || typeof partialValue !== 'object')) {\n        maybeResolveValue();\n        return;\n      }\n\n      fullyResolved(partialValue).then(function (resolvedValue) {\n        obj[key] = resolvedValue;\n        maybeResolveValue();\n      }, reject);\n    });\n\n    function maybeResolveValue() {\n      if (++numResolved == numKeys) {\n        fulfill(obj);\n      }\n    }\n  });\n} //////////////////////////////////////////////////////////////////////////////\n//\n//  ControlFlow\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Defines methods for coordinating the execution of asynchronous tasks.\n * @record\n */\n\n\nclass Scheduler {\n  /**\n   * Schedules a task for execution. If the task function is a generator, the\n   * task will be executed using {@link ./promise.consume consume()}.\n   *\n   * @param {function(): (T|IThenable<T>)} fn The function to call to start the\n   *     task.\n   * @param {string=} opt_description A description of the task for debugging\n   *     purposes.\n   * @return {!Thenable<T>} A promise that will be resolved with the task\n   *     result.\n   * @template T\n   */\n  execute(fn, opt_description) {}\n  /**\n   * Creates a new promise using the given resolver function.\n   *\n   * @param {function(\n   *             function((T|IThenable<T>|Thenable|null)=),\n   *             function(*=))} resolver\n   * @return {!Thenable<T>}\n   * @template T\n   */\n\n\n  promise(resolver) {}\n  /**\n   * Schedules a `setTimeout` call.\n   *\n   * @param {number} ms The timeout delay, in milliseconds.\n   * @param {string=} opt_description A description to accompany the timeout.\n   * @return {!Thenable<void>} A promise that will be resolved when the timeout\n   *     fires.\n   */\n\n\n  timeout(ms, opt_description) {}\n  /**\n   * Schedules a task to wait for a condition to hold.\n   *\n   * If the condition is defined as a function, it may return any value. Promise\n   * will be resolved before testing if the condition holds (resolution time\n   * counts towards the timeout). Once resolved, values are always evaluated as\n   * booleans.\n   *\n   * If the condition function throws, or returns a rejected promise, the\n   * wait task will fail.\n   *\n   * If the condition is defined as a promise, the scheduler will wait for it to\n   * settle. If the timeout expires before the promise settles, the promise\n   * returned by this function will be rejected.\n   *\n   * If this function is invoked with `timeout === 0`, or the timeout is\n   * omitted, this scheduler will wait indefinitely for the condition to be\n   * satisfied.\n   *\n   * @param {(!IThenable<T>|function())} condition The condition to poll,\n   *     or a promise to wait on.\n   * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n   *     condition to hold before timing out. If omitted, the flow will wait\n   *     indefinitely.\n   * @param {string=} opt_message An optional error message to include if the\n   *     wait times out; defaults to the empty string.\n   * @return {!Thenable<T>} A promise that will be fulfilled\n   *     when the condition has been satisfied. The promise shall be rejected\n   *     if the wait times out waiting for the condition.\n   * @throws {TypeError} If condition is not a function or promise or if timeout\n   *     is not a number >= 0.\n   * @template T\n   */\n\n\n  wait(condition, opt_timeout, opt_message) {}\n\n}\n\nlet USE_PROMISE_MANAGER;\n\nfunction usePromiseManager() {\n  if (typeof USE_PROMISE_MANAGER !== 'undefined') {\n    return !!USE_PROMISE_MANAGER;\n  }\n\n  return process.env['SELENIUM_PROMISE_MANAGER'] === undefined || !/^0|false$/i.test(process.env['SELENIUM_PROMISE_MANAGER']);\n}\n/**\n * Creates a new promise with the given `resolver` function. If the promise\n * manager is currently enabled, the returned promise will be a\n * {@linkplain ManagedPromise} instance. Otherwise, it will be a native promise.\n *\n * @param {function(\n *             function((T|IThenable<T>|Thenable|null)=),\n *             function(*=))} resolver\n * @return {!Thenable<T>}\n * @template T\n */\n\n\nfunction createPromise(resolver) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  return new ctor(resolver);\n}\n/**\n * @param {!Scheduler} scheduler The scheduler to use.\n * @param {(!IThenable<T>|function())} condition The condition to poll,\n *     or a promise to wait on.\n * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n *     condition to hold before timing out. If omitted, the flow will wait\n *     indefinitely.\n * @param {string=} opt_message An optional error message to include if the\n *     wait times out; defaults to the empty string.\n * @return {!Thenable<T>} A promise that will be fulfilled\n *     when the condition has been satisfied. The promise shall be rejected\n *     if the wait times out waiting for the condition.\n * @throws {TypeError} If condition is not a function or promise or if timeout\n *     is not a number >= 0.\n * @template T\n */\n\n\nfunction scheduleWait(scheduler, condition, opt_timeout, opt_message) {\n  let timeout = opt_timeout || 0;\n\n  if (typeof timeout !== 'number' || timeout < 0) {\n    throw TypeError('timeout must be a number >= 0: ' + timeout);\n  }\n\n  if (isPromise(condition)) {\n    return scheduler.execute(function () {\n      if (!timeout) {\n        return condition;\n      }\n\n      return scheduler.promise(function (fulfill, reject) {\n        let start = Date.now();\n        let timer = setTimeout(function () {\n          timer = null;\n          reject(new error.TimeoutError((opt_message ? opt_message + '\\n' : '') + 'Timed out waiting for promise to resolve after ' + (Date.now() - start) + 'ms'));\n        }, timeout);\n        /** @type {Thenable} */\n\n        condition.then(function (value) {\n          timer && clearTimeout(timer);\n          fulfill(value);\n        }, function (error) {\n          timer && clearTimeout(timer);\n          reject(error);\n        });\n      });\n    }, opt_message || '<anonymous wait: promise resolution>');\n  }\n\n  if (typeof condition !== 'function') {\n    throw TypeError('Invalid condition; must be a function or promise: ' + typeof condition);\n  }\n\n  if (isGenerator(condition)) {\n    let original = condition;\n\n    condition = () => consume(original);\n  }\n\n  return scheduler.execute(function () {\n    var startTime = Date.now();\n    return scheduler.promise(function (fulfill, reject) {\n      pollCondition();\n\n      function pollCondition() {\n        var conditionFn = condition;\n        scheduler.execute(conditionFn).then(function (value) {\n          var elapsed = Date.now() - startTime;\n\n          if (!!value) {\n            fulfill(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(new error.TimeoutError((opt_message ? opt_message + '\\n' : '') + `Wait timed out after ${elapsed}ms`));\n          } else {\n            // Do not use asyncRun here because we need a non-micro yield\n            // here so the UI thread is given a chance when running in a\n            // browser.\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      }\n    });\n  }, opt_message || '<anonymous wait>');\n}\n/**\n * A scheduler that executes all tasks immediately, with no coordination. This\n * class is an event emitter for API compatibility with the {@link ControlFlow},\n * however, it emits no events.\n *\n * @implements {Scheduler}\n */\n\n\nclass SimpleScheduler extends events.EventEmitter {\n  /** @override */\n  execute(fn) {\n    return this.promise((resolve, reject) => {\n      try {\n        if (isGenerator(fn)) {\n          consume(fn).then(resolve, reject);\n        } else {\n          resolve(fn.call(undefined));\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    });\n  }\n  /** @override */\n\n\n  promise(resolver) {\n    return new NativePromise(resolver);\n  }\n  /** @override */\n\n\n  timeout(ms) {\n    return this.promise(resolve => setTimeout(_ => resolve(), ms));\n  }\n  /** @override */\n\n\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n\n}\n\nconst SIMPLE_SCHEDULER = new SimpleScheduler();\n/**\n * Handles the execution of scheduled tasks, each of which may be an\n * asynchronous operation. The control flow will ensure tasks are executed in\n * the order scheduled, starting each task only once those before it have\n * completed.\n *\n * Each task scheduled within this flow may return a {@link ManagedPromise} to\n * indicate it is an asynchronous operation. The ControlFlow will wait for such\n * promises to be resolved before marking the task as completed.\n *\n * Tasks and each callback registered on a {@link ManagedPromise} will be run\n * in their own ControlFlow frame. Any tasks scheduled within a frame will take\n * priority over previously scheduled tasks. Furthermore, if any of the tasks in\n * the frame fail, the remainder of the tasks in that frame will be discarded\n * and the failure will be propagated to the user through the callback/task's\n * promised result.\n *\n * Each time a ControlFlow empties its task queue, it will fire an\n * {@link ControlFlow.EventType.IDLE IDLE} event. Conversely, whenever\n * the flow terminates due to an unhandled error, it will remove all\n * remaining tasks in its queue and fire an\n * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION UNCAUGHT_EXCEPTION} event.\n * If there are no listeners registered with the flow, the error will be\n * rethrown to the global error handler.\n *\n * Refer to the {@link ./promise} module documentation for a detailed\n * explanation of how the ControlFlow coordinates task execution.\n *\n * @implements {Scheduler}\n * @final\n */\n\nlet ControlFlow = /*#__PURE__*/(() => {\n  class ControlFlow extends events.EventEmitter {\n    constructor() {\n      if (!usePromiseManager()) {\n        throw TypeError('Cannot instantiate control flow when the promise manager has' + ' been disabled');\n      }\n\n      super();\n      /** @private {boolean} */\n\n      this.propagateUnhandledRejections_ = true;\n      /** @private {TaskQueue} */\n\n      this.activeQueue_ = null;\n      /** @private {Set<TaskQueue>} */\n\n      this.taskQueues_ = null;\n      /**\n       * Microtask that controls shutting down the control flow. Upon shut down,\n       * the flow will emit an\n       * {@link ControlFlow.EventType.IDLE} event. Idle events\n       * always follow a brief timeout in order to catch latent errors from the\n       * last completed task. If this task had a callback registered, but no\n       * errback, and the task fails, the unhandled failure would not be reported\n       * by the promise system until the next turn of the event loop:\n       *\n       *   // Schedule 1 task that fails.\n       *   var result = promise.controlFlow().execute(\n       *       () => promise.rejected('failed'), 'example');\n       *   // Set a callback on the result. This delays reporting the unhandled\n       *   // failure for 1 turn of the event loop.\n       *   result.then(function() {});\n       *\n       * @private {MicroTask}\n       */\n\n      this.shutdownTask_ = null;\n      /**\n       * ID for a long running interval used to keep a Node.js process running\n       * while a control flow's event loop is still working. This is a cheap hack\n       * required since JS events are only scheduled to run when there is\n       * _actually_ something to run. When a control flow is waiting on a task,\n       * there will be nothing in the JS event loop and the process would\n       * terminate without this.\n       * @private\n       */\n\n      this.hold_ = null;\n    }\n    /**\n     * Returns a string representation of this control flow, which is its current\n     * {@linkplain #getSchedule() schedule}, sans task stack traces.\n     * @return {string} The string representation of this control flow.\n     * @override\n     */\n\n\n    toString() {\n      return this.getSchedule();\n    }\n    /**\n     * Sets whether any unhandled rejections should propagate up through the\n     * control flow stack and cause rejections within parent tasks. If error\n     * propagation is disabled, tasks will not be aborted when an unhandled\n     * promise rejection is detected, but the rejection _will_ trigger an\n     * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n     *\n     * The default behavior is to propagate all unhandled rejections. _The use\n     * of this option is highly discouraged._\n     *\n     * @param {boolean} propagate whether to propagate errors.\n     */\n\n\n    setPropagateUnhandledRejections(propagate) {\n      this.propagateUnhandledRejections_ = propagate;\n    }\n    /**\n     * @return {boolean} Whether this flow is currently idle.\n     */\n\n\n    isIdle() {\n      return !this.shutdownTask_ && (!this.taskQueues_ || !this.taskQueues_.size);\n    }\n    /**\n     * Resets this instance, clearing its queue and removing all event listeners.\n     */\n\n\n    reset() {\n      this.cancelQueues_(new FlowResetError());\n      this.emit(ControlFlow.EventType.RESET);\n      this.removeAllListeners();\n      this.cancelShutdown_();\n    }\n    /**\n     * Generates an annotated string describing the internal state of this control\n     * flow, including the currently executing as well as pending tasks. If\n     * {@code opt_includeStackTraces === true}, the string will include the\n     * stack trace from when each task was scheduled.\n     * @param {string=} opt_includeStackTraces Whether to include the stack traces\n     * from when each task was scheduled. Defaults to false.\n     * @return {string} String representation of this flow's internal state.\n     */\n\n\n    getSchedule(opt_includeStackTraces) {\n      var ret = 'ControlFlow::' + getUid(this);\n      var activeQueue = this.activeQueue_;\n\n      if (!this.taskQueues_ || !this.taskQueues_.size) {\n        return ret;\n      }\n\n      var childIndent = '| ';\n\n      for (var q of this.taskQueues_) {\n        ret += '\\n' + printQ(q, childIndent);\n      }\n\n      return ret;\n\n      function printQ(q, indent) {\n        var ret = q.toString();\n\n        if (q === activeQueue) {\n          ret = '(active) ' + ret;\n        }\n\n        var prefix = indent + childIndent;\n\n        if (q.pending_) {\n          if (q.pending_.q.state_ !== TaskQueueState.FINISHED) {\n            ret += '\\n' + prefix + '(pending) ' + q.pending_.task;\n            ret += '\\n' + printQ(q.pending_.q, prefix + childIndent);\n          } else {\n            ret += '\\n' + prefix + '(blocked) ' + q.pending_.task;\n          }\n        }\n\n        if (q.interrupts_) {\n          q.interrupts_.forEach(task => {\n            ret += '\\n' + prefix + task;\n          });\n        }\n\n        if (q.tasks_) {\n          q.tasks_.forEach(task => ret += printTask(task, '\\n' + prefix));\n        }\n\n        return indent + ret;\n      }\n\n      function printTask(task, prefix) {\n        var ret = prefix + task;\n\n        if (opt_includeStackTraces && task.promise.stack_) {\n          ret += prefix + childIndent + (task.promise.stack_.stack || task.promise.stack_).replace(/\\n/g, prefix);\n        }\n\n        return ret;\n      }\n    }\n    /**\n     * Returns the currently active task queue for this flow. If there is no\n     * active queue, one will be created.\n     * @return {!TaskQueue} the currently active task queue for this flow.\n     * @private\n     */\n\n\n    getActiveQueue_() {\n      if (this.activeQueue_) {\n        return this.activeQueue_;\n      }\n\n      this.activeQueue_ = new TaskQueue(this);\n\n      if (!this.taskQueues_) {\n        this.taskQueues_ = new Set();\n      }\n\n      this.taskQueues_.add(this.activeQueue_);\n      this.activeQueue_.once('end', this.onQueueEnd_, this).once('error', this.onQueueError_, this);\n      asyncRun(() => this.activeQueue_ = null);\n      this.activeQueue_.start();\n      return this.activeQueue_;\n    }\n    /** @override */\n\n\n    execute(fn, opt_description) {\n      if (isGenerator(fn)) {\n        let original = fn;\n\n        fn = () => consume(original);\n      }\n\n      if (!this.hold_) {\n        let holdIntervalMs = 2147483647; // 2^31-1; max timer length for Node.js\n\n        this.hold_ = setInterval(function () {}, holdIntervalMs);\n      }\n\n      let task = new Task(this, fn, opt_description || '<anonymous>', {\n        name: 'Task',\n        top: ControlFlow.prototype.execute\n      }, true);\n      let q = this.getActiveQueue_();\n\n      for (let i = q.tasks_.length; i > 0; i--) {\n        let previousTask = q.tasks_[i - 1];\n\n        if (previousTask.userTask_) {\n          FLOW_LOG.warning(() => {\n            return `Detected scheduling of an unchained task.\nWhen the promise manager is disabled, unchained tasks will not wait for\npreviously scheduled tasks to finish before starting to execute.\nNew task: ${task.promise.stack_.stack}\nPrevious task: ${previousTask.promise.stack_.stack}`.split(/\\n/).join('\\n    ');\n          });\n          break;\n        }\n      }\n\n      q.enqueue(task);\n      this.emit(ControlFlow.EventType.SCHEDULE_TASK, task.description);\n      return task.promise;\n    }\n    /** @override */\n\n\n    promise(resolver) {\n      return new ManagedPromise(resolver, this, SKIP_LOG);\n    }\n    /** @override */\n\n\n    timeout(ms, opt_description) {\n      return this.execute(() => {\n        return this.promise(resolve => setTimeout(() => resolve(), ms));\n      }, opt_description);\n    }\n    /** @override */\n\n\n    wait(condition, opt_timeout, opt_message) {\n      return scheduleWait(this, condition, opt_timeout, opt_message);\n    }\n    /**\n     * Executes a function in the next available turn of the JavaScript event\n     * loop. This ensures the function runs with its own task queue and any\n     * scheduled tasks will run in \"parallel\" to those scheduled in the current\n     * function.\n     *\n     *     flow.execute(() => console.log('a'));\n     *     flow.execute(() => console.log('b'));\n     *     flow.execute(() => console.log('c'));\n     *     flow.async(() => {\n     *        flow.execute(() => console.log('d'));\n     *        flow.execute(() => console.log('e'));\n     *     });\n     *     flow.async(() => {\n     *        flow.execute(() => console.log('f'));\n     *        flow.execute(() => console.log('g'));\n     *     });\n     *     flow.once('idle', () => console.log('fin'));\n     *     // a\n     *     // d\n     *     // f\n     *     // b\n     *     // e\n     *     // g\n     *     // c\n     *     // fin\n     *\n     * If the function itself throws, the error will be treated the same as an\n     * unhandled rejection within the control flow.\n     *\n     * __NOTE__: This function is considered _unstable_.\n     *\n     * @param {!Function} fn The function to execute.\n     * @param {Object=} opt_self The object in whose context to run the function.\n     * @param {...*} var_args Any arguments to pass to the function.\n     */\n\n\n    async(fn, opt_self, var_args) {\n      asyncRun(() => {\n        // Clear any lingering queues, forces getActiveQueue_ to create a new one.\n        this.activeQueue_ = null;\n        var q = this.getActiveQueue_();\n\n        try {\n          q.execute_(fn.bind(opt_self, var_args));\n        } catch (ex) {\n          var cancellationError = CancellationError.wrap(ex, 'Function passed to ControlFlow.async() threw');\n          cancellationError.silent_ = true;\n          q.abort_(cancellationError);\n        } finally {\n          this.activeQueue_ = null;\n        }\n      });\n    }\n    /**\n     * Event handler for when a task queue is exhausted. This starts the shutdown\n     * sequence for this instance if there are no remaining task queues: after\n     * one turn of the event loop, this object will emit the\n     * {@link ControlFlow.EventType.IDLE IDLE} event to signal\n     * listeners that it has completed. During this wait, if another task is\n     * scheduled, the shutdown will be aborted.\n     *\n     * @param {!TaskQueue} q the completed task queue.\n     * @private\n     */\n\n\n    onQueueEnd_(q) {\n      if (!this.taskQueues_) {\n        return;\n      }\n\n      this.taskQueues_.delete(q);\n      vlog(1, () => q + ' has finished');\n      vlog(1, () => this.taskQueues_.size + ' queues remain\\n' + this, this);\n\n      if (!this.taskQueues_.size) {\n        if (this.shutdownTask_) {\n          throw Error('Already have a shutdown task??');\n        }\n\n        vlog(1, () => 'Scheduling shutdown\\n' + this);\n        this.shutdownTask_ = new MicroTask(() => this.shutdown_());\n      }\n    }\n    /**\n     * Event handler for when a task queue terminates with an error. This triggers\n     * the cancellation of all other task queues and a\n     * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n     * If there are no error event listeners registered with this instance, the\n     * error will be rethrown to the global error handler.\n     *\n     * @param {*} error the error that caused the task queue to terminate.\n     * @param {!TaskQueue} q the task queue.\n     * @private\n     */\n\n\n    onQueueError_(error, q) {\n      if (this.taskQueues_) {\n        this.taskQueues_.delete(q);\n      }\n\n      this.cancelQueues_(CancellationError.wrap(error, 'There was an uncaught error in the control flow'));\n      this.cancelShutdown_();\n      this.cancelHold_();\n      setTimeout(() => {\n        let listeners = this.listeners(ControlFlow.EventType.UNCAUGHT_EXCEPTION);\n\n        if (!listeners.size) {\n          throw error;\n        } else {\n          this.reportUncaughtException_(error);\n        }\n      }, 0);\n    }\n    /**\n     * Cancels all remaining task queues.\n     * @param {!CancellationError} reason The cancellation reason.\n     * @private\n     */\n\n\n    cancelQueues_(reason) {\n      reason.silent_ = true;\n\n      if (this.taskQueues_) {\n        for (var q of this.taskQueues_) {\n          q.removeAllListeners();\n          q.abort_(reason);\n        }\n\n        this.taskQueues_.clear();\n        this.taskQueues_ = null;\n      }\n    }\n    /**\n     * Reports an uncaught exception using a\n     * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n     *\n     * @param {*} e the error to report.\n     * @private\n     */\n\n\n    reportUncaughtException_(e) {\n      this.emit(ControlFlow.EventType.UNCAUGHT_EXCEPTION, e);\n    }\n    /** @private */\n\n\n    cancelHold_() {\n      if (this.hold_) {\n        clearInterval(this.hold_);\n        this.hold_ = null;\n      }\n    }\n    /** @private */\n\n\n    shutdown_() {\n      vlog(1, () => 'Going idle: ' + this);\n      this.cancelHold_();\n      this.shutdownTask_ = null;\n      this.emit(ControlFlow.EventType.IDLE);\n    }\n    /**\n     * Cancels the shutdown sequence if it is currently scheduled.\n     * @private\n     */\n\n\n    cancelShutdown_() {\n      if (this.shutdownTask_) {\n        this.shutdownTask_.cancel();\n        this.shutdownTask_ = null;\n      }\n    }\n\n  }\n\n  /**\n   * Events that may be emitted by an {@link ControlFlow}.\n   * @enum {string}\n   */\n  ControlFlow.EventType = {\n    /** Emitted when all tasks have been successfully executed. */\n    IDLE: 'idle',\n\n    /** Emitted when a ControlFlow has been reset. */\n    RESET: 'reset',\n\n    /** Emitted whenever a new task has been scheduled. */\n    SCHEDULE_TASK: 'scheduleTask',\n\n    /**\n     * Emitted whenever a control flow aborts due to an unhandled promise\n     * rejection. This event will be emitted along with the offending rejection\n     * reason. Upon emitting this event, the control flow will empty its task\n     * queue and revert to its initial state.\n     */\n    UNCAUGHT_EXCEPTION: 'uncaughtException'\n  };\n  /**\n   * Wraps a function to execute as a cancellable micro task.\n   * @final\n   */\n\n  return ControlFlow;\n})();\n\nclass MicroTask {\n  /**\n   * @param {function()} fn The function to run as a micro task.\n   */\n  constructor(fn) {\n    /** @private {boolean} */\n    this.cancelled_ = false;\n    asyncRun(() => {\n      if (!this.cancelled_) {\n        fn();\n      }\n    });\n  }\n  /**\n   * Runs the given function after a microtask yield.\n   * @param {function()} fn The function to run.\n   */\n\n\n  static run(fn) {\n    NativePromise.resolve().then(function () {\n      try {\n        fn();\n      } catch (ignored) {// Do nothing.\n      }\n    });\n  }\n  /**\n   * Cancels the execution of this task. Note: this will not prevent the task\n   * timer from firing, just the invocation of the wrapped function.\n   */\n\n\n  cancel() {\n    this.cancelled_ = true;\n  }\n\n}\n/**\n * A task to be executed by a {@link ControlFlow}.\n *\n * @template T\n * @final\n */\n\n\nclass Task extends Deferred {\n  /**\n   * @param {!ControlFlow} flow The flow this instances belongs\n   *     to.\n   * @param {function(): (T|!ManagedPromise<T>)} fn The function to\n   *     call when the task executes. If it returns a\n   *     {@link ManagedPromise}, the flow will wait for it to be\n   *     resolved before starting the next task.\n   * @param {string} description A description of the task for debugging.\n   * @param {{name: string, top: !Function}=} opt_stackOptions Options to use\n   *     when capturing the stacktrace for when this task was created.\n   * @param {boolean=} opt_isUserTask Whether this task was explicitly scheduled\n   *     by the use of the promise manager.\n   */\n  constructor(flow, fn, description, opt_stackOptions, opt_isUserTask) {\n    super(flow, SKIP_LOG);\n    getUid(this);\n    /** @type {function(): (T|!ManagedPromise<T>)} */\n\n    this.execute = fn;\n    /** @type {string} */\n\n    this.description = description;\n    /** @type {TaskQueue} */\n\n    this.queue = null;\n    /** @private @const {boolean} */\n\n    this.userTask_ = !!opt_isUserTask;\n    /**\n     * Whether this task is considered block. A blocked task may be registered\n     * in a task queue, but will be dropped if it is still blocked when it\n     * reaches the front of the queue. A dropped task may always be rescheduled.\n     *\n     * Blocked tasks are used when a callback is attached to an unsettled\n     * promise to reserve a spot in line (in a manner of speaking). If the\n     * promise is not settled before the callback reaches the front of the\n     * of the queue, it will be dropped. Once the promise is settled, the\n     * dropped task will be rescheduled as an interrupt on the currently task\n     * queue.\n     *\n     * @type {boolean}\n     */\n\n    this.blocked = false;\n\n    if (opt_stackOptions) {\n      this.promise.stack_ = captureStackTrace(opt_stackOptions.name, this.description, opt_stackOptions.top);\n    }\n  }\n  /** @override */\n\n\n  toString() {\n    return 'Task::' + getUid(this) + '<' + this.description + '>';\n  }\n\n}\n/** @enum {string} */\n\n\nconst TaskQueueState = {\n  NEW: 'new',\n  STARTED: 'started',\n  FINISHED: 'finished'\n};\n/**\n * @final\n */\n\nclass TaskQueue extends events.EventEmitter {\n  /** @param {!ControlFlow} flow . */\n  constructor(flow) {\n    super();\n    /** @private {string} */\n\n    this.name_ = 'TaskQueue::' + getUid(this);\n    /** @private {!ControlFlow} */\n\n    this.flow_ = flow;\n    /** @private {!Array<!Task>} */\n\n    this.tasks_ = [];\n    /** @private {Array<!Task>} */\n\n    this.interrupts_ = null;\n    /** @private {({task: !Task, q: !TaskQueue}|null)} */\n\n    this.pending_ = null;\n    /** @private {TaskQueue} */\n\n    this.subQ_ = null;\n    /** @private {TaskQueueState} */\n\n    this.state_ = TaskQueueState.NEW;\n    /** @private {!Set<!ManagedPromise>} */\n\n    this.unhandledRejections_ = new Set();\n  }\n  /** @override */\n\n\n  toString() {\n    return 'TaskQueue::' + getUid(this);\n  }\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n\n\n  addUnhandledRejection(promise) {\n    // TODO: node 4.0.0+\n    vlog(2, () => this + ' registering unhandled rejection: ' + promise, this);\n    this.unhandledRejections_.add(promise);\n  }\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n\n\n  clearUnhandledRejection(promise) {\n    var deleted = this.unhandledRejections_.delete(promise);\n\n    if (deleted) {\n      // TODO: node 4.0.0+\n      vlog(2, () => this + ' clearing unhandled rejection: ' + promise, this);\n    }\n  }\n  /**\n   * Enqueues a new task for execution.\n   * @param {!Task} task The task to enqueue.\n   * @throws {Error} If this instance has already started execution.\n   */\n\n\n  enqueue(task) {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw Error('TaskQueue has started: ' + this);\n    }\n\n    if (task.queue) {\n      throw Error('Task is already scheduled in another queue');\n    }\n\n    this.tasks_.push(task);\n    task.queue = this;\n    ON_CANCEL_HANDLER.set(task.promise, e => this.onTaskCancelled_(task, e));\n    vlog(1, () => this + '.enqueue(' + task + ')', this);\n    vlog(2, () => this.flow_.toString(), this);\n  }\n  /**\n   * Schedules the callbacks registered on the given promise in this queue.\n   *\n   * @param {!ManagedPromise} promise the promise whose callbacks should be\n   *     registered as interrupts in this task queue.\n   * @throws {Error} if this queue has already finished.\n   */\n\n\n  scheduleCallbacks(promise) {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      throw new Error('cannot interrupt a finished q(' + this + ')');\n    }\n\n    if (this.pending_ && this.pending_.task.promise === promise) {\n      this.pending_.task.promise.queue_ = null;\n      this.pending_ = null;\n      asyncRun(() => this.executeNext_());\n    }\n\n    if (!promise.callbacks_) {\n      return;\n    }\n\n    promise.callbacks_.forEach(function (cb) {\n      cb.blocked = false;\n\n      if (cb.queue) {\n        return;\n      }\n\n      ON_CANCEL_HANDLER.set(cb.promise, e => this.onTaskCancelled_(cb, e));\n\n      if (cb.queue === this && this.tasks_.indexOf(cb) !== -1) {\n        return;\n      }\n\n      if (cb.queue) {\n        cb.queue.dropTask_(cb);\n      }\n\n      cb.queue = this;\n\n      if (!this.interrupts_) {\n        this.interrupts_ = [];\n      }\n\n      this.interrupts_.push(cb);\n    }, this);\n    promise.callbacks_ = null;\n    vlog(2, () => this + ' interrupted\\n' + this.flow_, this);\n  }\n  /**\n   * Starts executing tasks in this queue. Once called, no further tasks may\n   * be {@linkplain #enqueue() enqueued} with this instance.\n   *\n   * @throws {Error} if this queue has already been started.\n   */\n\n\n  start() {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw new Error('TaskQueue has already started');\n    } // Always asynchronously execute next, even if there doesn't look like\n    // there is anything in the queue. This will catch pending unhandled\n    // rejections that were registered before start was called.\n\n\n    asyncRun(() => this.executeNext_());\n  }\n  /**\n   * Aborts this task queue. If there are any scheduled tasks, they are silently\n   * cancelled and discarded (their callbacks will never fire). If this queue\n   * has a _pending_ task, the abortion error is used to cancel that task.\n   * Otherwise, this queue will emit an error event.\n   *\n   * @param {*} error The abortion reason.\n   * @private\n   */\n\n\n  abort_(error) {\n    var cancellation;\n\n    if (error instanceof FlowResetError) {\n      cancellation = error;\n    } else {\n      cancellation = new DiscardedTaskError(error);\n    }\n\n    if (this.interrupts_ && this.interrupts_.length) {\n      this.interrupts_.forEach(t => t.reject(cancellation));\n      this.interrupts_ = [];\n    }\n\n    if (this.tasks_ && this.tasks_.length) {\n      this.tasks_.forEach(t => t.reject(cancellation));\n      this.tasks_ = [];\n    } // Now that all of the remaining tasks have been silently cancelled (e.g. no\n    // existing callbacks on those tasks will fire), clear the silence bit on\n    // the cancellation error. This ensures additional callbacks registered in\n    // the future will actually execute.\n\n\n    cancellation.silent_ = false;\n\n    if (this.pending_) {\n      vlog(2, () => this + '.abort(); cancelling pending task', this);\n      this.pending_.task.promise.cancel(error);\n    } else {\n      vlog(2, () => this + '.abort(); emitting error event', this);\n      this.emit('error', error, this);\n    }\n  }\n  /** @private */\n\n\n  executeNext_() {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      return;\n    }\n\n    this.state_ = TaskQueueState.STARTED;\n\n    if (this.pending_ !== null || this.processUnhandledRejections_()) {\n      return;\n    }\n\n    var task;\n\n    do {\n      task = this.getNextTask_();\n    } while (task && !isPending(task.promise));\n\n    if (!task) {\n      this.state_ = TaskQueueState.FINISHED;\n      this.tasks_ = [];\n      this.interrupts_ = null;\n      vlog(2, () => this + '.emit(end)', this);\n      this.emit('end', this);\n      return;\n    }\n\n    let result = undefined;\n    this.subQ_ = new TaskQueue(this.flow_);\n    this.subQ_.once('end', () => {\n      // On task completion.\n      this.subQ_ = null;\n      this.pending_ && this.pending_.task.resolve(result);\n    });\n    this.subQ_.once('error', e => {\n      // On task failure.\n      this.subQ_ = null;\n\n      if (Thenable.isImplementation(result)) {\n        result.cancel(CancellationError.wrap(e));\n      }\n\n      this.pending_ && this.pending_.task.reject(e);\n    });\n    vlog(2, () => `${this} created ${this.subQ_} for ${task}`);\n\n    try {\n      this.pending_ = {\n        task: task,\n        q: this.subQ_\n      };\n      task.promise.queue_ = this;\n      result = this.subQ_.execute_(task.execute);\n      this.subQ_.start();\n    } catch (ex) {\n      this.subQ_.abort_(ex);\n    }\n  }\n  /**\n   * @param {!Function} fn .\n   * @return {T} .\n   * @template T\n   * @private\n   */\n\n\n  execute_(fn) {\n    try {\n      activeFlows.push(this.flow_);\n      this.flow_.activeQueue_ = this;\n      return fn();\n    } finally {\n      this.flow_.activeQueue_ = null;\n      activeFlows.pop();\n    }\n  }\n  /**\n   * Process any unhandled rejections registered with this task queue. If there\n   * is a rejection, this queue will be aborted with the rejection error. If\n   * there are multiple rejections registered, this queue will be aborted with\n   * a {@link MultipleUnhandledRejectionError}.\n   * @return {boolean} whether there was an unhandled rejection.\n   * @private\n   */\n\n\n  processUnhandledRejections_() {\n    if (!this.unhandledRejections_.size) {\n      return false;\n    }\n\n    var errors = new Set();\n\n    for (var rejection of this.unhandledRejections_) {\n      errors.add(rejection.value_);\n    }\n\n    this.unhandledRejections_.clear();\n    var errorToReport = errors.size === 1 ? errors.values().next().value : new MultipleUnhandledRejectionError(errors);\n    vlog(1, () => this + ' aborting due to unhandled rejections', this);\n\n    if (this.flow_.propagateUnhandledRejections_) {\n      this.abort_(errorToReport);\n      return true;\n    } else {\n      vlog(1, 'error propagation disabled; reporting to control flow');\n      this.flow_.reportUncaughtException_(errorToReport);\n      return false;\n    }\n  }\n  /**\n   * @param {!Task} task The task to drop.\n   * @private\n   */\n\n\n  dropTask_(task) {\n    var index;\n\n    if (this.interrupts_) {\n      index = this.interrupts_.indexOf(task);\n\n      if (index != -1) {\n        task.queue = null;\n        this.interrupts_.splice(index, 1);\n        return;\n      }\n    }\n\n    index = this.tasks_.indexOf(task);\n\n    if (index != -1) {\n      task.queue = null;\n      this.tasks_.splice(index, 1);\n    }\n  }\n  /**\n   * @param {!Task} task The task that was cancelled.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n\n\n  onTaskCancelled_(task, reason) {\n    if (this.pending_ && this.pending_.task === task) {\n      this.pending_.q.abort_(reason);\n    } else {\n      this.dropTask_(task);\n    }\n  }\n  /**\n   * @return {(Task|undefined)} the next task scheduled within this queue,\n   *     if any.\n   * @private\n   */\n\n\n  getNextTask_() {\n    var task = undefined;\n\n    while (true) {\n      if (this.interrupts_) {\n        task = this.interrupts_.shift();\n      }\n\n      if (!task && this.tasks_) {\n        task = this.tasks_.shift();\n      }\n\n      if (task && task.blocked) {\n        vlog(2, () => this + ' skipping blocked task ' + task, this);\n        task.queue = null;\n        task = null; // TODO: recurse when tail-call optimization is available in node.\n      } else {\n        break;\n      }\n    }\n\n    return task;\n  }\n\n}\n/**\n * The default flow to use if no others are active.\n * @type {ControlFlow}\n */\n\n\nvar defaultFlow;\n/**\n * A stack of active control flows, with the top of the stack used to schedule\n * commands. When there are multiple flows on the stack, the flow at index N\n * represents a callback triggered within a task owned by the flow at index\n * N-1.\n * @type {!Array<!ControlFlow>}\n */\n\nvar activeFlows = [];\n/**\n * Changes the default flow to use when no others are active.\n * @param {!ControlFlow} flow The new default flow.\n * @throws {Error} If the default flow is not currently active.\n */\n\nfunction setDefaultFlow(flow) {\n  if (!usePromiseManager()) {\n    throw Error('You  may not change set the control flow when the promise' + ' manager is disabled');\n  }\n\n  if (activeFlows.length) {\n    throw Error('You may only change the default flow while it is active');\n  }\n\n  defaultFlow = flow;\n}\n/**\n * @return {!ControlFlow} The currently active control flow.\n * @suppress {checkTypes}\n */\n\n\nfunction controlFlow() {\n  if (!usePromiseManager()) {\n    return SIMPLE_SCHEDULER;\n  }\n\n  if (activeFlows.length) {\n    return activeFlows[activeFlows.length - 1];\n  }\n\n  if (!defaultFlow) {\n    defaultFlow = new ControlFlow();\n  }\n\n  return defaultFlow;\n}\n/**\n * Creates a new control flow. The provided callback will be invoked as the\n * first task within the new flow, with the flow as its sole argument. Returns\n * a promise that resolves to the callback result.\n * @param {function(!ControlFlow)} callback The entry point\n *     to the newly created flow.\n * @return {!Thenable} A promise that resolves to the callback result.\n */\n\n\nfunction createFlow(callback) {\n  var flow = new ControlFlow();\n  return flow.execute(function () {\n    return callback(flow);\n  });\n}\n/**\n * Tests is a function is a generator.\n * @param {!Function} fn The function to test.\n * @return {boolean} Whether the function is a generator.\n */\n\n\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n/**\n * Consumes a {@code GeneratorFunction}. Each time the generator yields a\n * promise, this function will wait for it to be fulfilled before feeding the\n * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n * rejected, the rejection error will be passed to {@code throw}.\n *\n * __Example 1:__ the Fibonacci Sequence.\n *\n *     promise.consume(function* fibonacci() {\n *       var n1 = 1, n2 = 1;\n *       for (var i = 0; i < 4; ++i) {\n *         var tmp = yield n1 + n2;\n *         n1 = n2;\n *         n2 = tmp;\n *       }\n *       return n1 + n2;\n *     }).then(function(result) {\n *       console.log(result);  // 13\n *     });\n *\n * __Example 2:__ a generator that throws.\n *\n *     promise.consume(function* () {\n *       yield promise.delayed(250).then(function() {\n *         throw Error('boom');\n *       });\n *     }).catch(function(e) {\n *       console.log(e.toString());  // Error: boom\n *     });\n *\n * @param {!Function} generatorFn The generator function to execute.\n * @param {Object=} opt_self The object to use as \"this\" when invoking the\n *     initial generator.\n * @param {...*} var_args Any arguments to pass to the initial generator.\n * @return {!Thenable<?>} A promise that will resolve to the\n *     generator's final result.\n * @throws {TypeError} If the given function is not a generator.\n */\n\n\nfunction consume(generatorFn, opt_self, ...var_args) {\n  if (!isGenerator(generatorFn)) {\n    throw new TypeError('Input is not a GeneratorFunction: ' + generatorFn.constructor.name);\n  }\n\n  let ret;\n  return ret = createPromise((resolve, reject) => {\n    let generator = generatorFn.apply(opt_self, var_args);\n    callNext();\n    /** @param {*=} opt_value . */\n\n    function callNext(opt_value) {\n      pump(generator.next, opt_value);\n    }\n    /** @param {*=} opt_error . */\n\n\n    function callThrow(opt_error) {\n      pump(generator.throw, opt_error);\n    }\n\n    function pump(fn, opt_arg) {\n      if (ret instanceof ManagedPromise && !isPending(ret)) {\n        return; // Deferred was cancelled; silently abort.\n      }\n\n      try {\n        var result = fn.call(generator, opt_arg);\n      } catch (ex) {\n        reject(ex);\n        return;\n      }\n\n      if (result.done) {\n        resolve(result.value);\n        return;\n      }\n\n      asap(result.value, callNext, callThrow);\n    }\n  });\n} // PUBLIC API\n\n\nmodule.exports = {\n  CancellableThenable: CancellableThenable,\n  CancellationError: CancellationError,\n  ControlFlow: ControlFlow,\n  Deferred: Deferred,\n  MultipleUnhandledRejectionError: MultipleUnhandledRejectionError,\n  Thenable: Thenable,\n  Promise: ManagedPromise,\n  Resolver: Resolver,\n  Scheduler: Scheduler,\n  all: all,\n  asap: asap,\n  captureStackTrace: captureStackTrace,\n  checkedNodeCall: checkedNodeCall,\n  consume: consume,\n  controlFlow: controlFlow,\n  createFlow: createFlow,\n  createPromise: createPromise,\n  defer: defer,\n  delayed: delayed,\n  filter: filter,\n  finally: thenFinally,\n  fulfilled: fulfilled,\n  fullyResolved: fullyResolved,\n  isGenerator: isGenerator,\n  isPromise: isPromise,\n  map: map,\n  rejected: rejected,\n  setDefaultFlow: setDefaultFlow,\n  when: when,\n\n  /**\n   * Indicates whether the promise manager is currently enabled. When disabled,\n   * attempting to use the {@link ControlFlow} or {@link ManagedPromise Promise}\n   * classes will generate an error.\n   *\n   * The promise manager is currently enabled by default, but may be disabled\n   * by setting the environment variable `SELENIUM_PROMISE_MANAGER=0` or by\n   * setting this property to false. Setting this property will always take\n   * precedence over the use of the environment variable.\n   *\n   * @return {boolean} Whether the promise manager is enabled.\n   * @see <https://github.com/SeleniumHQ/selenium/issues/2969>\n   */\n  get USE_PROMISE_MANAGER() {\n    return usePromiseManager();\n  },\n\n  set USE_PROMISE_MANAGER(\n  /** boolean */\n  value) {\n    USE_PROMISE_MANAGER = value;\n  },\n\n  get LONG_STACK_TRACES() {\n    return LONG_STACK_TRACES;\n  },\n\n  set LONG_STACK_TRACES(v) {\n    LONG_STACK_TRACES = v;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}