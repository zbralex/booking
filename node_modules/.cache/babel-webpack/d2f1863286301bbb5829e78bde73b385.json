{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for the Chrome\n * web browser. Before using this module, you must download the latest\n * [ChromeDriver release] and ensure it can be found on your system [PATH].\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link selenium-webdriver/remote.DriverService remote.DriverService}\n *     that manages the [ChromeDriver] child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new Chrome\n *     session, such as which {@linkplain Options#setProxy proxy} to use,\n *     what {@linkplain Options#addExtensions extensions} to install, or\n *     what {@linkplain Options#addArguments command-line switches} to use when\n *     starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session with a clean user profile (unless otherwise\n *     configured through the {@link Options} class).\n *\n * __Headless Chrome__ <a id=\"headless\"></a>\n *\n * To start Chrome in headless mode, simply call\n * {@linkplain Options#headless Options.headless()}. Note, starting in headless\n * mode currently also disables GPU acceleration.\n *\n *     let chrome = require('selenium-webdriver/chrome');\n *     let {Builder} = require('selenium-webdriver');\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options().headless())\n *         .build();\n *\n * __Customizing the ChromeDriver Server__ <a id=\"custom-server\"></a>\n *\n * By default, every Chrome session will use a single driver service, which is\n * started the first time a {@link Driver} instance is created and terminated\n * when this process exits. The default service will inherit its environment\n * from the current process and direct all output to /dev/null. You may obtain\n * a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     let chrome = require('selenium-webdriver/chrome');\n *\n *     let service = new chrome.ServiceBuilder()\n *         .loggingTo('/my/log/file.txt')\n *         .enableVerboseLogging()\n *         .build();\n *\n *     let options = new chrome.Options();\n *     // configure browser options ...\n *\n *     let driver = chrome.Driver.createSession(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start Chrome using the\n * {@link selenium-webdriver.Builder}.\n *\n * __Working with Android__ <a id=\"android\"></a>\n *\n * The [ChromeDriver][android] supports running tests on the Chrome browser as\n * well as [WebView apps][webview] starting in Android 4.4 (KitKat). In order to\n * work with Android, you must first start the adb\n *\n *     adb start-server\n *\n * By default, adb will start on port 5037. You may change this port, but this\n * will require configuring a [custom server](#custom-server) that will connect\n * to adb on the {@linkplain ServiceBuilder#setAdbPort correct port}:\n *\n *     let service = new chrome.ServiceBuilder()\n *         .setAdbPort(1234)\n *         build();\n *     // etc.\n *\n * The ChromeDriver may be configured to launch Chrome on Android using\n * {@link Options#androidChrome()}:\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options().androidChrome())\n *         .build();\n *\n * Alternatively, you can configure the ChromeDriver to launch an app with a\n * Chrome-WebView by setting the {@linkplain Options#androidActivity\n * androidActivity} option:\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options()\n *             .androidPackage('com.example')\n *             .androidActivity('com.example.Activity'))\n *         .build();\n *\n * [Refer to the ChromeDriver site] for more information on using the\n * [ChromeDriver with Android][android].\n *\n * [ChromeDriver]: https://sites.google.com/a/chromium.org/chromedriver/\n * [ChromeDriver release]: http://chromedriver.storage.googleapis.com/index.html\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n * [android]: https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android\n * [webview]: https://developer.chrome.com/multidevice/webview/overview\n */\n'use strict';\n\nconst fs = require('fs');\n\nconst util = require('util');\n\nconst http = require('./http');\n\nconst io = require('./io');\n\nconst {\n  Capabilities,\n  Capability\n} = require('./lib/capabilities');\n\nconst command = require('./lib/command');\n\nconst logging = require('./lib/logging');\n\nconst promise = require('./lib/promise');\n\nconst Symbols = require('./lib/symbols');\n\nconst webdriver = require('./lib/webdriver');\n\nconst portprober = require('./net/portprober');\n\nconst remote = require('./remote');\n/**\n * Name of the ChromeDriver executable.\n * @type {string}\n * @const\n */\n\n\nconst CHROMEDRIVER_EXE = process.platform === 'win32' ? 'chromedriver.exe' : 'chromedriver';\n/**\n * Custom command names supported by ChromeDriver.\n * @enum {string}\n */\n\nconst Command = {\n  LAUNCH_APP: 'launchApp',\n  GET_NETWORK_CONDITIONS: 'getNetworkConditions',\n  SET_NETWORK_CONDITIONS: 'setNetworkConditions'\n};\n/**\n * Creates a command executor with support for ChromeDriver's custom commands.\n * @param {!Promise<string>} url The server's URL.\n * @return {!command.Executor} The new command executor.\n */\n\nfunction createExecutor(url) {\n  let client = url.then(url => new http.HttpClient(url));\n  let executor = new http.Executor(client);\n  configureExecutor(executor);\n  return executor;\n}\n/**\n * Configures the given executor with Chrome-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\n\n\nfunction configureExecutor(executor) {\n  executor.defineCommand(Command.LAUNCH_APP, 'POST', '/session/:sessionId/chromium/launch_app');\n  executor.defineCommand(Command.GET_NETWORK_CONDITIONS, 'GET', '/session/:sessionId/chromium/network_conditions');\n  executor.defineCommand(Command.SET_NETWORK_CONDITIONS, 'POST', '/session/:sessionId/chromium/network_conditions');\n}\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/)\n * server in a child process.\n */\n\n\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the chromedriver on the current\n   *     PATH.\n   * @throws {Error} If provided executable does not exist, or the chromedriver\n   *     cannot be found on the PATH.\n   */\n  constructor(opt_exe) {\n    let exe = opt_exe || io.findInPath(CHROMEDRIVER_EXE, true);\n\n    if (!exe) {\n      throw Error('The ChromeDriver could not be found on the current PATH. Please ' + 'download the latest version of the ChromeDriver from ' + 'http://chromedriver.storage.googleapis.com/index.html and ensure ' + 'it can be found on your PATH.');\n    }\n\n    super(exe);\n    this.setLoopback(true); // Required\n  }\n  /**\n   * Sets which port adb is listening to. _The ChromeDriver will connect to adb\n   * if an {@linkplain Options#androidPackage Android session} is requested, but\n   * adb **must** be started beforehand._\n   *\n   * @param {number} port Which port adb is running on.\n   * @return {!ServiceBuilder} A self reference.\n   */\n\n\n  setAdbPort(port) {\n    return this.addArguments('--adb-port=' + port);\n  }\n  /**\n   * Sets the path of the log file the driver should log to. If a log file is\n   * not specified, the driver will log to stderr.\n   * @param {string} path Path of the log file to use.\n   * @return {!ServiceBuilder} A self reference.\n   */\n\n\n  loggingTo(path) {\n    return this.addArguments('--log-path=' + path);\n  }\n  /**\n   * Enables verbose logging.\n   * @return {!ServiceBuilder} A self reference.\n   */\n\n\n  enableVerboseLogging() {\n    return this.addArguments('--verbose');\n  }\n  /**\n   * Sets the number of threads the driver should use to manage HTTP requests.\n   * By default, the driver will use 4 threads.\n   * @param {number} n The number of threads to use.\n   * @return {!ServiceBuilder} A self reference.\n   */\n\n\n  setNumHttpThreads(n) {\n    return this.addArguments('--http-threads=' + n);\n  }\n  /**\n   * @override\n   */\n\n\n  setPath(path) {\n    super.setPath(path);\n    return this.addArguments('--url-base=' + path);\n  }\n\n}\n/** @type {remote.DriverService} */\n\n\nlet defaultService = null;\n/**\n * Sets the default service to use for new ChromeDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\n\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error('The previously configured ChromeDriver service is still running. ' + 'You must shut it down before you may adjust its configuration.');\n  }\n\n  defaultService = service;\n}\n/**\n * Returns the default ChromeDriver service. If such a service has not been\n * configured, one will be constructed using the default configuration for\n * a ChromeDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default ChromeDriver service.\n */\n\n\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n\n  return defaultService;\n}\n\nconst OPTIONS_CAPABILITY_KEY = 'chromeOptions';\n/**\n * Class for managing ChromeDriver specific options.\n */\n\nclass Options {\n  constructor() {\n    /** @private {!Object} */\n    this.options_ = {};\n    /** @private {!Array<(string|!Buffer)>} */\n\n    this.extensions_ = [];\n    /** @private {?logging.Preferences} */\n\n    this.logPrefs_ = null;\n    /** @private {?./lib/capabilities.ProxyConfig} */\n\n    this.proxy_ = null;\n  }\n  /**\n   * Extracts the ChromeDriver specific options from the given capabilities\n   * object.\n   * @param {!Capabilities} caps The capabilities object.\n   * @return {!Options} The ChromeDriver options.\n   */\n\n\n  static fromCapabilities(caps) {\n    let options = new Options();\n    let o = caps.get(OPTIONS_CAPABILITY_KEY);\n\n    if (o instanceof Options) {\n      options = o;\n    } else if (o) {\n      options.addArguments(o.args || []).addExtensions(o.extensions || []).detachDriver(o.detach).excludeSwitches(o.excludeSwitches || []).setChromeBinaryPath(o.binary).setChromeLogFile(o.logPath).setChromeMinidumpPath(o.minidumpPath).setLocalState(o.localState).setMobileEmulation(o.mobileEmulation).setUserPreferences(o.prefs).setPerfLoggingPrefs(o.perfLoggingPrefs);\n    }\n\n    if (caps.has(Capability.PROXY)) {\n      options.setProxy(caps.get(Capability.PROXY));\n    }\n\n    if (caps.has(Capability.LOGGING_PREFS)) {\n      options.setLoggingPrefs(caps.get(Capability.LOGGING_PREFS));\n    }\n\n    return options;\n  }\n  /**\n   * Add additional command line arguments to use when launching the Chrome\n   * browser.  Each argument may be specified with or without the \"--\" prefix\n   * (e.g. \"--foo\" and \"foo\"). Arguments with an associated value should be\n   * delimited by an \"=\": \"foo=bar\".\n   *\n   * @param {...(string|!Array<string>)} args The arguments to add.\n   * @return {!Options} A self reference.\n   */\n\n\n  addArguments(...args) {\n    let newArgs = (this.options_.args || []).concat(...args);\n\n    if (newArgs.length) {\n      this.options_.args = newArgs;\n    }\n\n    return this;\n  }\n  /**\n   * Configures the chromedriver to start Chrome in headless mode.\n   *\n   * > __NOTE:__ Resizing the browser window in headless mode is only supported\n   * > in Chrome 60. Users are encouraged to set an initial window size with\n   * > the {@link #windowSize windowSize({width, height})} option.\n   *\n   * @return {!Options} A self reference.\n   */\n\n\n  headless() {\n    // TODO(jleyba): Remove `disable-gpu` once head Chrome no longer requires\n    // that to be set.\n    return this.addArguments('headless', 'disable-gpu');\n  }\n  /**\n   * Sets the initial window size.\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n\n\n  windowSize({\n    width,\n    height\n  }) {\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0');\n      }\n    }\n\n    checkArg(width);\n    checkArg(height);\n    return this.addArguments(`window-size=${width},${height}`);\n  }\n  /**\n   * List of Chrome command line switches to exclude that ChromeDriver by default\n   * passes when starting Chrome.  Do not prefix switches with \"--\".\n   *\n   * @param {...(string|!Array<string>)} args The switches to exclude.\n   * @return {!Options} A self reference.\n   */\n\n\n  excludeSwitches(...args) {\n    let switches = (this.options_.excludeSwitches || []).concat(...args);\n\n    if (switches.length) {\n      this.options_.excludeSwitches = switches;\n    }\n\n    return this;\n  }\n  /**\n   * Add additional extensions to install when launching Chrome. Each extension\n   * should be specified as the path to the packed CRX file, or a Buffer for an\n   * extension.\n   * @param {...(string|!Buffer|!Array<(string|!Buffer)>)} args The\n   *     extensions to add.\n   * @return {!Options} A self reference.\n   */\n\n\n  addExtensions(...args) {\n    this.extensions_ = this.extensions_.concat(...args);\n    return this;\n  }\n  /**\n   * Sets the path to the Chrome binary to use. On Mac OS X, this path should\n   * reference the actual Chrome executable, not just the application binary\n   * (e.g. \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\").\n   *\n   * The binary path be absolute or relative to the chromedriver server\n   * executable, but it must exist on the machine that will launch Chrome.\n   *\n   * @param {string} path The path to the Chrome binary to use.\n   * @return {!Options} A self reference.\n   */\n\n\n  setChromeBinaryPath(path) {\n    this.options_.binary = path;\n    return this;\n  }\n  /**\n   * Sets whether to leave the started Chrome browser running if the controlling\n   * ChromeDriver service is killed before {@link webdriver.WebDriver#quit()} is\n   * called.\n   * @param {boolean} detach Whether to leave the browser running if the\n   *     chromedriver service is killed before the session.\n   * @return {!Options} A self reference.\n   */\n\n\n  detachDriver(detach) {\n    this.options_.detach = detach;\n    return this;\n  }\n  /**\n   * Sets the user preferences for Chrome's user profile. See the \"Preferences\"\n   * file in Chrome's user data directory for examples.\n   * @param {!Object} prefs Dictionary of user preferences to use.\n   * @return {!Options} A self reference.\n   */\n\n\n  setUserPreferences(prefs) {\n    this.options_.prefs = prefs;\n    return this;\n  }\n  /**\n   * Sets the logging preferences for the new session.\n   * @param {!logging.Preferences} prefs The logging preferences.\n   * @return {!Options} A self reference.\n   */\n\n\n  setLoggingPrefs(prefs) {\n    this.logPrefs_ = prefs;\n    return this;\n  }\n  /**\n   * Sets the performance logging preferences. Options include:\n   *\n   * - `enableNetwork`: Whether or not to collect events from Network domain.\n   * - `enablePage`: Whether or not to collect events from Page domain.\n   * - `enableTimeline`: Whether or not to collect events from Timeline domain.\n   *     Note: when tracing is enabled, Timeline domain is implicitly disabled,\n   *     unless `enableTimeline` is explicitly set to true.\n   * - `tracingCategories`: A comma-separated string of Chrome tracing\n   *     categories for which trace events should be collected. An unspecified\n   *     or empty string disables tracing.\n   * - `bufferUsageReportingInterval`: The requested number of milliseconds\n   *     between DevTools trace buffer usage events. For example, if 1000, then\n   *     once per second, DevTools will report how full the trace buffer is. If\n   *     a report indicates the buffer usage is 100%, a warning will be issued.\n   *\n   * @param {{enableNetwork: boolean,\n   *          enablePage: boolean,\n   *          enableTimeline: boolean,\n   *          tracingCategories: string,\n   *          bufferUsageReportingInterval: number}} prefs The performance\n   *     logging preferences.\n   * @return {!Options} A self reference.\n   */\n\n\n  setPerfLoggingPrefs(prefs) {\n    this.options_.perfLoggingPrefs = prefs;\n    return this;\n  }\n  /**\n   * Sets preferences for the \"Local State\" file in Chrome's user data\n   * directory.\n   * @param {!Object} state Dictionary of local state preferences.\n   * @return {!Options} A self reference.\n   */\n\n\n  setLocalState(state) {\n    this.options_.localState = state;\n    return this;\n  }\n  /**\n   * Sets the name of the activity hosting a Chrome-based Android WebView. This\n   * option must be set to connect to an [Android WebView](\n   * https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android)\n   *\n   * @param {string} name The activity name.\n   * @return {!Options} A self reference.\n   */\n\n\n  androidActivity(name) {\n    this.options_.androidActivity = name;\n    return this;\n  }\n  /**\n   * Sets the device serial number to connect to via ADB. If not specified, the\n   * ChromeDriver will select an unused device at random. An error will be\n   * returned if all devices already have active sessions.\n   *\n   * @param {string} serial The device serial number to connect to.\n   * @return {!Options} A self reference.\n   */\n\n\n  androidDeviceSerial(serial) {\n    this.options_.androidDeviceSerial = serial;\n    return this;\n  }\n  /**\n   * Configures the ChromeDriver to launch Chrome on Android via adb. This\n   * function is shorthand for\n   * {@link #androidPackage options.androidPackage('com.android.chrome')}.\n   * @return {!Options} A self reference.\n   */\n\n\n  androidChrome() {\n    return this.androidPackage('com.android.chrome');\n  }\n  /**\n   * Sets the package name of the Chrome or WebView app.\n   *\n   * @param {?string} pkg The package to connect to, or `null` to disable Android\n   *     and switch back to using desktop Chrome.\n   * @return {!Options} A self reference.\n   */\n\n\n  androidPackage(pkg) {\n    this.options_.androidPackage = pkg;\n    return this;\n  }\n  /**\n   * Sets the process name of the Activity hosting the WebView (as given by\n   * `ps`). If not specified, the process name is assumed to be the same as\n   * {@link #androidPackage}.\n   *\n   * @param {string} processName The main activity name.\n   * @return {!Options} A self reference.\n   */\n\n\n  androidProcess(processName) {\n    this.options_.androidProcess = processName;\n    return this;\n  }\n  /**\n   * Sets whether to connect to an already-running instead of the specified\n   * {@linkplain #androidProcess app} instead of launching the app with a clean\n   * data directory.\n   *\n   * @param {boolean} useRunning Whether to connect to a running instance.\n   * @return {!Options} A self reference.\n   */\n\n\n  androidUseRunningApp(useRunning) {\n    this.options_.androidUseRunningApp = useRunning;\n    return this;\n  }\n  /**\n   * Sets the path to Chrome's log file. This path should exist on the machine\n   * that will launch Chrome.\n   * @param {string} path Path to the log file to use.\n   * @return {!Options} A self reference.\n   */\n\n\n  setChromeLogFile(path) {\n    this.options_.logPath = path;\n    return this;\n  }\n  /**\n   * Sets the directory to store Chrome minidumps in. This option is only\n   * supported when ChromeDriver is running on Linux.\n   * @param {string} path The directory path.\n   * @return {!Options} A self reference.\n   */\n\n\n  setChromeMinidumpPath(path) {\n    this.options_.minidumpPath = path;\n    return this;\n  }\n  /**\n   * Configures Chrome to emulate a mobile device. For more information, refer\n   * to the ChromeDriver project page on [mobile emulation][em]. Configuration\n   * options include:\n   *\n   * - `deviceName`: The name of a pre-configured [emulated device][devem]\n   * - `width`: screen width, in pixels\n   * - `height`: screen height, in pixels\n   * - `pixelRatio`: screen pixel ratio\n   *\n   * __Example 1: Using a Pre-configured Device__\n   *\n   *     let options = new chrome.Options().setMobileEmulation(\n   *         {deviceName: 'Google Nexus 5'});\n   *\n   *     let driver = chrome.Driver.createSession(options);\n   *\n   * __Example 2: Using Custom Screen Configuration__\n   *\n   *     let options = new chrome.Options().setMobileEmulation({\n   *         width: 360,\n   *         height: 640,\n   *         pixelRatio: 3.0\n   *     });\n   *\n   *     let driver = chrome.Driver.createSession(options);\n   *\n   *\n   * [em]: https://sites.google.com/a/chromium.org/chromedriver/mobile-emulation\n   * [devem]: https://developer.chrome.com/devtools/docs/device-mode\n   *\n   * @param {?({deviceName: string}|\n   *           {width: number, height: number, pixelRatio: number})} config The\n   *     mobile emulation configuration, or `null` to disable emulation.\n   * @return {!Options} A self reference.\n   */\n\n\n  setMobileEmulation(config) {\n    this.options_.mobileEmulation = config;\n    return this;\n  }\n  /**\n   * Sets the proxy settings for the new session.\n   * @param {./lib/capabilities.ProxyConfig} proxy The proxy configuration to\n   *    use.\n   * @return {!Options} A self reference.\n   */\n\n\n  setProxy(proxy) {\n    this.proxy_ = proxy;\n    return this;\n  }\n  /**\n   * Converts this options instance to a {@link Capabilities} object.\n   * @param {Capabilities=} opt_capabilities The capabilities to merge\n   *     these options into, if any.\n   * @return {!Capabilities} The capabilities.\n   */\n\n\n  toCapabilities(opt_capabilities) {\n    let caps = opt_capabilities || Capabilities.chrome();\n    caps.set(Capability.PROXY, this.proxy_).set(Capability.LOGGING_PREFS, this.logPrefs_).set(OPTIONS_CAPABILITY_KEY, this);\n    return caps;\n  }\n  /**\n   * Converts this instance to its JSON wire protocol representation. Note this\n   * function is an implementation not intended for general use.\n   * @return {!Object} The JSON wire protocol representation of this instance.\n   */\n\n\n  [Symbols.serialize]() {\n    let json = {};\n\n    for (let key in this.options_) {\n      if (this.options_[key] != null) {\n        json[key] = this.options_[key];\n      }\n    }\n\n    if (this.extensions_.length) {\n      json.extensions = this.extensions_.map(function (extension) {\n        if (Buffer.isBuffer(extension)) {\n          return extension.toString('base64');\n        }\n\n        return io.read(extension).then(buffer => buffer.toString('base64'));\n      });\n    }\n\n    return json;\n  }\n\n}\n/**\n * Creates a new WebDriver client for Chrome.\n */\n\n\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new session with the ChromeDriver.\n   *\n   * @param {(Capabilities|Options)=} opt_config The configuration options.\n   * @param {(remote.DriverService|http.Executor)=} opt_serviceExecutor Either\n   *     a  DriverService to use for the remote end, or a preconfigured executor\n   *     for an externally managed endpoint. If neither is provided, the\n   *     {@linkplain ##getDefaultService default service} will be used by\n   *     default.\n   * @param {promise.ControlFlow=} opt_flow The control flow to use, or `null`\n   *     to use the currently active flow.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_serviceExecutor, opt_flow) {\n    let executor;\n\n    if (opt_serviceExecutor instanceof http.Executor) {\n      executor = opt_serviceExecutor;\n      configureExecutor(executor);\n    } else {\n      let service = opt_serviceExecutor || getDefaultService();\n      executor = createExecutor(service.start());\n    }\n\n    let caps = opt_config instanceof Options ? opt_config.toCapabilities() : opt_config || Capabilities.chrome();\n    return super.createSession(executor, caps, opt_flow);\n  }\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n\n\n  setFileDetector() {}\n  /**\n   * Schedules a command to launch Chrome App with given ID.\n   * @param {string} id ID of the App to launch.\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when app is launched.\n   */\n\n\n  launchApp(id) {\n    return this.schedule(new command.Command(Command.LAUNCH_APP).setParameter('id', id), 'Driver.launchApp()');\n  }\n  /**\n   * Schedules a command to get Chrome network emulation settings.\n   * @return {!promise.Thenable<T>} A promise that will be resolved\n   *     when network emulation settings are retrievied.\n   */\n\n\n  getNetworkConditions() {\n    return this.schedule(new command.Command(Command.GET_NETWORK_CONDITIONS), 'Driver.getNetworkConditions()');\n  }\n  /**\n   * Schedules a command to set Chrome network emulation settings.\n   *\n   * __Sample Usage:__\n   *\n   *  driver.setNetworkConditions({\n   *    offline: false,\n   *    latency: 5, // Additional latency (ms).\n   *    download_throughput: 500 * 1024, // Maximal aggregated download throughput.\n   *    upload_throughput: 500 * 1024 // Maximal aggregated upload throughput.\n   * });\n   *\n   * @param {Object} spec Defines the network conditions to set\n   * @return {!promise.Thenable<void>} A promise that will be resolved\n   *     when network emulation settings are set.\n   */\n\n\n  setNetworkConditions(spec) {\n    if (!spec || typeof spec !== 'object') {\n      throw TypeError('setNetworkConditions called with non-network-conditions parameter');\n    }\n\n    return this.schedule(new command.Command(Command.SET_NETWORK_CONDITIONS).setParameter('network_conditions', spec), 'Driver.setNetworkConditions(' + JSON.stringify(spec) + ')');\n  }\n\n} // PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;","map":null,"metadata":{},"sourceType":"script"}