{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst q = require(\"q\");\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst util = require(\"util\");\n\nconst browser_1 = require(\"./browser\");\n\nconst driverProviders_1 = require(\"./driverProviders\");\n\nconst logger_1 = require(\"./logger\");\n\nconst plugins_1 = require(\"./plugins\");\n\nconst ptor_1 = require(\"./ptor\");\n\nconst helper = require(\"./util\");\n\nlet logger = new logger_1.Logger('runner');\n/*\n * Runner is responsible for starting the execution of a test run and triggering\n * setup, teardown, managing config, etc through its various dependencies.\n *\n * The Protractor Runner is a node EventEmitter with the following events:\n * - testPass\n * - testFail\n * - testsDone\n *\n * @param {Object} config\n * @constructor\n */\n\nclass Runner extends events_1.EventEmitter {\n  constructor(config) {\n    super();\n    /**\n     * Responsible for cleaning up test run and exiting the process.\n     * @private\n     * @param {int} Standard unix exit code\n     */\n\n    this.exit_ = function (exitCode) {\n      return helper.runFilenameOrFn_(this.config_.configDir, this.config_.onCleanUp, [exitCode]).then(returned => {\n        if (typeof returned === 'number') {\n          return returned;\n        } else {\n          return exitCode;\n        }\n      });\n    };\n\n    this.config_ = config;\n\n    if (config.v8Debug) {\n      // Call this private function instead of sending SIGUSR1 because Windows.\n      process['_debugProcess'](process.pid);\n    }\n\n    if (config.nodeDebug) {\n      process['_debugProcess'](process.pid);\n      let flow = selenium_webdriver_1.promise.controlFlow();\n      this.ready_ = flow.execute(() => {\n        let nodedebug = require('child_process').fork('debug', ['localhost:5858']);\n\n        process.on('exit', function () {\n          nodedebug.kill('SIGTERM');\n        });\n        nodedebug.on('exit', function () {\n          process.exit(1);\n        });\n      }, 'start the node debugger').then(() => {\n        return flow.timeout(1000, 'waiting for debugger to attach');\n      });\n    }\n\n    if (config.capabilities && config.capabilities.seleniumAddress) {\n      config.seleniumAddress = config.capabilities.seleniumAddress;\n    }\n\n    this.loadDriverProvider_(config);\n    this.setTestPreparer(config.onPrepare);\n  }\n  /**\n   * Registrar for testPreparers - executed right before tests run.\n   * @public\n   * @param {string/Fn} filenameOrFn\n   */\n\n\n  setTestPreparer(filenameOrFn) {\n    this.preparer_ = filenameOrFn;\n  }\n  /**\n   * Executor of testPreparer\n   * @public\n   * @param {string[]=} An optional list of command line arguments the framework will accept.\n   * @return {q.Promise} A promise that will resolve when the test preparers\n   *     are finished.\n   */\n\n\n  runTestPreparer(extraFlags) {\n    let unknownFlags = this.config_.unknownFlags_ || [];\n\n    if (extraFlags) {\n      unknownFlags = unknownFlags.filter(f => extraFlags.indexOf(f) === -1);\n    }\n\n    if (unknownFlags.length > 0 && !this.config_.disableChecks) {\n      // TODO: Make this throw a ConfigError in Protractor 6.\n      logger.warn('Ignoring unknown extra flags: ' + unknownFlags.join(', ') + '. This will be' + ' an error in future versions, please use --disableChecks flag to disable the ' + ' Protractor CLI flag checks. ');\n    }\n\n    return this.plugins_.onPrepare().then(() => {\n      return helper.runFilenameOrFn_(this.config_.configDir, this.preparer_);\n    });\n  }\n  /**\n   * Called after each test finishes.\n   *\n   * Responsible for `restartBrowserBetweenTests`\n   *\n   * @public\n   * @return {q.Promise} A promise that will resolve when the work here is done\n   */\n\n\n  afterEach() {\n    let ret;\n    this.frameworkUsesAfterEach = true;\n\n    if (this.config_.restartBrowserBetweenTests) {\n      this.restartPromise = this.restartPromise || q(ptor_1.protractor.browser.restart());\n      ret = this.restartPromise;\n      this.restartPromise = undefined;\n    }\n\n    return ret || q();\n  }\n  /**\n   * Grab driver provider based on type\n   * @private\n   *\n   * Priority\n   * 1) if directConnect is true, use that\n   * 2) if seleniumAddress is given, use that\n   * 3) if a Sauce Labs account is given, use that\n   * 4) if a seleniumServerJar is specified, use that\n   * 5) try to find the seleniumServerJar in protractor/selenium\n   */\n\n\n  loadDriverProvider_(config) {\n    this.config_ = config;\n    this.driverprovider_ = driverProviders_1.buildDriverProvider(this.config_);\n  }\n  /**\n   * Getter for the Runner config object\n   * @public\n   * @return {Object} config\n   */\n\n\n  getConfig() {\n    return this.config_;\n  }\n  /**\n   * Get the control flow used by this runner.\n   * @return {Object} WebDriver control flow.\n   */\n\n\n  controlFlow() {\n    return selenium_webdriver_1.promise.controlFlow();\n  }\n  /**\n   * Sets up convenience globals for test specs\n   * @private\n   */\n\n\n  setupGlobals_(browser_) {\n    // Keep $, $$, element, and by/By under the global protractor namespace\n    ptor_1.protractor.browser = browser_;\n    ptor_1.protractor.$ = browser_.$;\n    ptor_1.protractor.$$ = browser_.$$;\n    ptor_1.protractor.element = browser_.element;\n    ptor_1.protractor.by = ptor_1.protractor.By = browser_1.ProtractorBrowser.By;\n    ptor_1.protractor.ExpectedConditions = browser_.ExpectedConditions;\n\n    if (!this.config_.noGlobals) {\n      // Export protractor to the global namespace to be used in tests.\n      global.browser = browser_;\n      global.$ = browser_.$;\n      global.$$ = browser_.$$;\n      global.element = browser_.element;\n      global.by = global.By = ptor_1.protractor.By;\n      global.ExpectedConditions = ptor_1.protractor.ExpectedConditions;\n    }\n\n    global.protractor = ptor_1.protractor;\n\n    if (!this.config_.skipSourceMapSupport) {\n      // Enable sourcemap support for stack traces.\n      require('source-map-support').install();\n    } // Required by dart2js machinery.\n    // https://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/sdk/lib/js/dart2js/js_dart2js.dart?spec=svn32943&r=32943#487\n\n\n    global.DartObject = function (o) {\n      this.o = o;\n    };\n  }\n  /**\n   * Create a new driver from a driverProvider. Then set up a\n   * new protractor instance using this driver.\n   * This is used to set up the initial protractor instances and any\n   * future ones.\n   *\n   * @param {Plugin} plugins The plugin functions\n   * @param {ProtractorBrowser=} parentBrowser The browser which spawned this one\n   *\n   * @return {Protractor} a protractor instance.\n   * @public\n   */\n\n\n  createBrowser(plugins, parentBrowser) {\n    let config = this.config_;\n    let driver = this.driverprovider_.getNewDriver();\n    let blockingProxyUrl;\n\n    if (config.useBlockingProxy) {\n      blockingProxyUrl = this.driverprovider_.getBPUrl();\n    }\n\n    let initProperties = {\n      baseUrl: config.baseUrl,\n      rootElement: config.rootElement,\n      untrackOutstandingTimeouts: config.untrackOutstandingTimeouts,\n      params: config.params,\n      getPageTimeout: config.getPageTimeout,\n      allScriptsTimeout: config.allScriptsTimeout,\n      debuggerServerPort: config.debuggerServerPort,\n      ng12Hybrid: config.ng12Hybrid,\n      waitForAngularEnabled: true\n    };\n\n    if (parentBrowser) {\n      initProperties.baseUrl = parentBrowser.baseUrl;\n      initProperties.rootElement = parentBrowser.angularAppRoot();\n      initProperties.untrackOutstandingTimeouts = !parentBrowser.trackOutstandingTimeouts_;\n      initProperties.params = parentBrowser.params;\n      initProperties.getPageTimeout = parentBrowser.getPageTimeout;\n      initProperties.allScriptsTimeout = parentBrowser.allScriptsTimeout;\n      initProperties.debuggerServerPort = parentBrowser.debuggerServerPort;\n      initProperties.ng12Hybrid = parentBrowser.ng12Hybrid;\n      initProperties.waitForAngularEnabled = parentBrowser.waitForAngularEnabled();\n    }\n\n    let browser_ = new browser_1.ProtractorBrowser(driver, initProperties.baseUrl, initProperties.rootElement, initProperties.untrackOutstandingTimeouts, blockingProxyUrl);\n    browser_.params = initProperties.params;\n    browser_.plugins_ = plugins || new plugins_1.Plugins({});\n\n    if (initProperties.getPageTimeout) {\n      browser_.getPageTimeout = initProperties.getPageTimeout;\n    }\n\n    if (initProperties.allScriptsTimeout) {\n      browser_.allScriptsTimeout = initProperties.allScriptsTimeout;\n    }\n\n    if (initProperties.debuggerServerPort) {\n      browser_.debuggerServerPort = initProperties.debuggerServerPort;\n    }\n\n    if (initProperties.ng12Hybrid) {\n      browser_.ng12Hybrid = initProperties.ng12Hybrid;\n    }\n\n    browser_.ready = browser_.ready.then(() => {\n      return browser_.waitForAngularEnabled(initProperties.waitForAngularEnabled);\n    }).then(() => {\n      return driver.manage().timeouts().setScriptTimeout(initProperties.allScriptsTimeout || 0);\n    }).then(() => {\n      return browser_;\n    });\n\n    browser_.getProcessedConfig = () => {\n      return selenium_webdriver_1.promise.when(config);\n    };\n\n    browser_.forkNewDriverInstance = (useSameUrl, copyMockModules, copyConfigUpdates = true) => {\n      let newBrowser = this.createBrowser(plugins);\n\n      if (copyMockModules) {\n        newBrowser.mockModules_ = browser_.mockModules_;\n      }\n\n      if (useSameUrl) {\n        newBrowser.ready = newBrowser.ready.then(() => {\n          return browser_.driver.getCurrentUrl();\n        }).then(url => {\n          return newBrowser.get(url);\n        }).then(() => {\n          return newBrowser;\n        });\n      }\n\n      return newBrowser;\n    };\n\n    let replaceBrowser = () => {\n      let newBrowser = browser_.forkNewDriverInstance(false, true);\n\n      if (browser_ === ptor_1.protractor.browser) {\n        this.setupGlobals_(newBrowser);\n      }\n\n      return newBrowser;\n    };\n\n    browser_.restart = () => {\n      // Note: because tests are not paused at this point, any async\n      // calls here are not guaranteed to complete before the tests resume.\n      // Seperate solutions depending on if the control flow is enabled (see lib/browser.ts)\n      if (browser_.controlFlowIsEnabled()) {\n        return browser_.restartSync().ready;\n      } else {\n        return this.driverprovider_.quitDriver(browser_.driver).then(replaceBrowser).then(newBrowser => newBrowser.ready);\n      }\n    };\n\n    browser_.restartSync = () => {\n      if (!browser_.controlFlowIsEnabled()) {\n        throw TypeError('Unable to use `browser.restartSync()` when the control flow is disabled');\n      }\n\n      this.driverprovider_.quitDriver(browser_.driver);\n      return replaceBrowser();\n    };\n\n    return browser_;\n  }\n  /**\n   * Final cleanup on exiting the runner.\n   *\n   * @return {q.Promise} A promise which resolves on finish.\n   * @private\n   */\n\n\n  shutdown_() {\n    return driverProviders_1.DriverProvider.quitDrivers(this.driverprovider_, this.driverprovider_.getExistingDrivers());\n  }\n  /**\n   * The primary workhorse interface. Kicks off the test running process.\n   *\n   * @return {q.Promise} A promise which resolves to the exit code of the tests.\n   * @public\n   */\n\n\n  run() {\n    let testPassed;\n    let plugins = this.plugins_ = new plugins_1.Plugins(this.config_);\n    let pluginPostTestPromises;\n    let browser_;\n    let results;\n\n    if (this.config_.framework !== 'explorer' && !this.config_.specs.length) {\n      throw new Error('Spec patterns did not match any files.');\n    }\n\n    if (this.config_.SELENIUM_PROMISE_MANAGER != null) {\n      selenium_webdriver_1.promise.USE_PROMISE_MANAGER = this.config_.SELENIUM_PROMISE_MANAGER;\n    }\n\n    if (this.config_.webDriverLogDir || this.config_.highlightDelay) {\n      this.config_.useBlockingProxy = true;\n    } // 0) Wait for debugger\n\n\n    return q(this.ready_).then(() => {\n      // 1) Setup environment\n      // noinspection JSValidateTypes\n      return this.driverprovider_.setupEnv();\n    }).then(() => {\n      // 2) Create a browser and setup globals\n      browser_ = this.createBrowser(plugins);\n      this.setupGlobals_(browser_);\n      return browser_.ready.then(browser_.getSession).then(session => {\n        logger.debug('WebDriver session successfully started with capabilities ' + util.inspect(session.getCapabilities()));\n      }, err => {\n        logger.error('Unable to start a WebDriver session.');\n        throw err;\n      }); // 3) Setup plugins\n    }).then(() => {\n      return plugins.setup(); // 4) Execute test cases\n    }).then(() => {\n      // Do the framework setup here so that jasmine and mocha globals are\n      // available to the onPrepare function.\n      let frameworkPath = '';\n\n      if (this.config_.framework === 'jasmine' || this.config_.framework === 'jasmine2') {\n        frameworkPath = './frameworks/jasmine.js';\n      } else if (this.config_.framework === 'mocha') {\n        frameworkPath = './frameworks/mocha.js';\n      } else if (this.config_.framework === 'debugprint') {\n        // Private framework. Do not use.\n        frameworkPath = './frameworks/debugprint.js';\n      } else if (this.config_.framework === 'explorer') {\n        // Private framework. Do not use.\n        frameworkPath = './frameworks/explorer.js';\n      } else if (this.config_.framework === 'custom') {\n        if (!this.config_.frameworkPath) {\n          throw new Error('When config.framework is custom, ' + 'config.frameworkPath is required.');\n        }\n\n        frameworkPath = this.config_.frameworkPath;\n      } else {\n        throw new Error('config.framework (' + this.config_.framework + ') is not a valid framework.');\n      }\n\n      if (this.config_.restartBrowserBetweenTests) {\n        // TODO(sjelin): replace with warnings once `afterEach` support is required\n        let restartDriver = () => {\n          if (!this.frameworkUsesAfterEach) {\n            this.restartPromise = q(browser_.restart());\n          }\n        };\n\n        this.on('testPass', restartDriver);\n        this.on('testFail', restartDriver);\n      } // We need to save these promises to make sure they're run, but we\n      // don't\n      // want to delay starting the next test (because we can't, it's just\n      // an event emitter).\n\n\n      pluginPostTestPromises = [];\n      this.on('testPass', testInfo => {\n        pluginPostTestPromises.push(plugins.postTest(true, testInfo));\n      });\n      this.on('testFail', testInfo => {\n        pluginPostTestPromises.push(plugins.postTest(false, testInfo));\n      });\n      logger.debug('Running with spec files ' + this.config_.specs);\n      return require(frameworkPath).run(this, this.config_.specs); // 5) Wait for postTest plugins to finish\n    }).then(testResults => {\n      results = testResults;\n      return q.all(pluginPostTestPromises); // 6) Teardown plugins\n    }).then(() => {\n      return plugins.teardown(); // 7) Teardown\n    }).then(() => {\n      results = helper.joinTestLogs(results, plugins.getResults());\n      this.emit('testsDone', results);\n      testPassed = results.failedCount === 0;\n\n      if (this.driverprovider_.updateJob) {\n        return this.driverprovider_.updateJob({\n          'passed': testPassed\n        }).then(() => {\n          return this.driverprovider_.teardownEnv();\n        });\n      } else {\n        return this.driverprovider_.teardownEnv();\n      } // 8) Let plugins do final cleanup\n\n    }).then(() => {\n      return plugins.postResults(); // 9) Exit process\n    }).then(() => {\n      let exitCode = testPassed ? 0 : 1;\n      return this.exit_(exitCode);\n    }).fin(() => {\n      return this.shutdown_();\n    });\n  }\n\n}\n\nexports.Runner = Runner; //# sourceMappingURL=runner.js.map","map":null,"metadata":{},"sourceType":"script"}