{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar os = require('os');\n\nfunction getLoInterface() {\n  var name;\n\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n\n  return name ? os.networkInterfaces()[name] : null;\n}\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string=} opt_family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {string} The located IP address or undefined.\n */\n\n\nfunction getAddress(loopback, opt_family) {\n  var family = opt_family || 'IPv4';\n  var addresses = [];\n  var interfaces;\n\n  if (loopback) {\n    var lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n\n  interfaces = interfaces || os.networkInterfaces();\n\n  for (var key in interfaces) {\n    if (!interfaces.hasOwnProperty(key)) {\n      continue;\n    }\n\n    interfaces[key].forEach(function (ipAddress) {\n      if (ipAddress.family === family && ipAddress.internal === loopback) {\n        addresses.push(ipAddress.address);\n      }\n    });\n  }\n\n  return addresses[0];\n} // PUBLIC API\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\n\n\nexports.getAddress = function (opt_family) {\n  return getAddress(false, opt_family);\n};\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\n\n\nexports.getLoopbackAddress = function (opt_family) {\n  return getAddress(true, opt_family);\n};\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\n\n\nexports.splitHostAndPort = function (hostport) {\n  let lastIndex = hostport.lastIndexOf(':');\n\n  if (lastIndex < 0) {\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n\n  let firstIndex = hostport.indexOf(':');\n\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n\n  let host = hostport.slice(0, lastIndex);\n\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n\n  let port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {\n    host,\n    port\n  };\n};","map":null,"metadata":{},"sourceType":"script"}